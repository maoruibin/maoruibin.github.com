<?xml version="1.0" encoding="utf-8"?>
<ul>
  <li>六⽉，⼀年的⼀半⼜过去了，时间就是这么快。NBA季后赛这个⽉开始了NBA季后赛，我是快船球迷，准确说我是莱昂纳德的⽀持者，我喜欢他。但是这个⽉最让⼈惊喜的不是莱昂纳德，⽽是泰伦卢，卢指导。作为⼀个主教练，连续两轮系列赛完成了0-2的翻盘，这个NBA绝⽆仅有。这期间最让我影响深刻的是快船爵⼠第六场，那场⽐赛，核⼼莱昂纳德已经受伤不能出战，然后曼恩顶替⾸发，前⾯五场⽐赛两队2-3，快船领先，第六战在快船主场进⾏，我在第⼆节打开⼿机⼀看快船落后了⼆⼗分，我想没戏了，后来继续带孩⼦外⾯玩耍，⼗⼀点多回到家后发现⽐分被快船追回来了，简直不可思议，到了第四节，全员发挥的都异常好，没看到⼀个进球都兴奋的乱喊。⽐赛看完后。我觉得后⾯的结果不重要了。快船的成绩最应该感谢的就是泰伦卢，他的调整能⼒在⽬前NBA⽆出其右，他对⼈员的使⽤和激发难以想象，他的⼩阵容总是⽤的恰到好处，佩服。当然，最终还是没能越过太阳，这⾥⾯我觉得最重要的不是保罗，而是安顿，他是五⼩的终结者，他年轻，灵活，有⾃主进攻能⼒，防守也很好，但是进⼊总决赛，他⼀定会⾯临更⼤的挑战，不论卡佩拉还是雄⿅的内线。⽬标⽅向前⼏天看到《激荡三⼗年》⾥提到⼀句话很有道理:⼀个⼈要让⾃⼰快乐其实是⼀件不难的事，你只要给⾃⼰⼀个较⻓时间的⽬标，然后按部就班地去接近它，实现它。结果如何，在某种意义上可能是不重要的，重要的是，在这个过程中，你会⾮常的单纯和满⾜。所以设定合适的⽬标是多么重要，⽬标有短期⻓期之分，短期的这种满⾜感更容易体会到，所以就是说要有⽬标，但是⼈是懒惰的，本性都想着简单，随遇⽽安，⽽不想去做规划，设定⽬标，但是要成为更好的⾃⼰⼀定是⼀个反⼈性的过程，很多事都是如此，想到得到更多就⼀定需要付出，不论是体⼒还是脑⼒，思想上的懒惰是终极懒惰。焦虑前段时间发过⼀则微博⼈最⼤的焦虑往往来⾃于事情的不可控，因为由此会带来诸多的不踏实感，所以解决焦虑的⼀个⽅法就是不断去消灭不可控因素，⽽增加确定更多的确定性。工作生活里就是不断的去解决一个一个trouble，然后不断磨炼、不断升级。追求⼀个⼈⼀⽣到底在追逐什么，不同的⼈答案不⼀样，个⼈觉得任何答案最终都可以归为⼀个：寻找内⼼的平静。</li>
  <li>博客从21年初换了新模板后，博客的评论功能就也就没了，因为本来之前也没什么互动，所以也没有再去折腾评论功能。最近得知还有朋友在关注博客，所以爬上来更新一下。今年工作会很忙，但是每月还是会继续去做总结，我认为做总结是很好的习惯，当然大部分总结只会放在自己的个人笔记中，公开出来意义不大，但我还是想把一些零碎的思考在每月做总结的时候放出来一些，就当给博客增加些”人气”😂总结、回顾的必要性我们会学习很多东西，看很多东西，但是如果不设计一些回顾、总结的环节，一些问题，一些点就不好进行升华，总结回顾的时候，会对一些之前的思考、做法有不一样的认识，或者说更深刻的认识，总之真的做了，就会发现其意义。另外，回顾之前高中时，每天的早自习，或者晚自习，总要花很多时间的看之前的笔记，就是为了掌握的更加牢固，当时是有老师在push，所以没感觉出来这样的必要性。现在大家很忙，看过的书，想过的事可能都没时间去反思，但是如果能给自己设计一些环节去回顾思考，可能会有不一样的发现。投出产出比ROI，对就是它的中文翻译，自己之前可能或多或少的关注过ROI，但是到字节后，ROI的强调宣传都是空前的，这个词自己在很多文章中都不停的被提到，自己也慢慢的对此有了更加深刻的认识。有了认识就要实践，所以工作生活中要找到那些最重要的事，然后投入更多的精力在这些事中。自己之前业余在开发一些软件，在2020年左右花了很多时间，如果单纯从收益看ROI是很低的，但是自己也还是获得了一些内心的满足，同时也发现了一些不一样的东西，但今年，软件已经优化的差不多了，如果继续再去花费太多功夫，就似乎不值得了，而且现在有太多比它重要的事。所以今年不会花费很多精力在上面，后面也只会安排少量的精力去做一些维护。另外，开发软件对我个人而言，有时也是一种放松，自己比较享受实现工具，优化工具的那种感觉。焦虑最近感觉很明显，这跟工作、生活都有关系，很多事情处理的并不好，有时候可能需要把这种感觉写出来。五月的总结暂时就写这么多了。</li>
  <li>这篇总结写在一月初，但是年初因为忙于复习、找工作，一直也就没有发布到博客，如果尘埃即将落定，遂发布。慌乱、焦虑的一年这一年的记忆从自己参加公司体检开始。每年公司都会让员工自己约体检，19年的体检被我约在了一月份，由于公司有亲人优惠套餐，所以给老妈也预约了体检，那天早晨带着孩子还有老妈一起去做体检，每年体检中心的人都很多，那天也不例外，人挤人，花了一个早晨终于完毕，中午把老妈、孩子送到地铁，自己边去上班了。接下来的事，大家都知道了，1月23号，武汉封城，新冠疫情全面袭来，整个中国都陷入了前所未有的紧张状态。过年期间，自己跟家人一起在北京过年，北京这边疫情尽管远没有一线的疫情城市严重，但是整个气氛充满了紧张与不安，每天站在阳台，外面都是一片安静，彻底失去了过年时应有的喧嚣。每天早晨起来关心的就是疫情的数据，也许是大环境+心理作用，过年期间嗓子不舒服，后来还偶尔身体发热，硬是把自己吓的，尤其之前还去体检中心参加了体检，所以内心很焦虑。除此之外，对基金也焦虑，因为年前的基金仓位不小，所以年后开市，必然是一顿爆锤，更焦虑了。为了解决焦虑，后来开始转移注意力，收拾房间，写APP，跟父母聊天，后来春节过去了，远远没有想象中的糟糕，开年第一天，上证指数暴跌8%，自己还加仓了1万（加少了😂）。后面，国内的疫情迅速控制，反而国外开始爆发，一开始全世界关起门来防中国，后来几个月的时间，中国不断开始运送医疗物资，全世界救助，世界变化太快。工作很忙，很差，感觉很失败。从五月开始，项目发生变动，开始去做小视频业务，到现在为止忙了大半年，做了N多大需求，从公司角度，自己算是很好的支撑了公司的业务，但是对自己而言，这些是远远不够的，自己的主观能动性在需求开发过程中很难调度起来，要说收获，主要集中在年末，因为终于有时间可以去研究一些东西了，自己开始去研究业务开发中的基础框架技术，结合自己的日常开发，对技术框架算是有一个更好的认识和学习。反思：在需求开发的过程中，如何提高自己技术水平？深挖需求开发中的技术点，在完成公司需求的同时，也要让自己从需求中学习拓展技术。对于前人已经写好的框架，一定要去阅读源码并学习，然后最好敢于动手的改造优化，不要停留在用的层面，而且应该在可以熟练使用前人轮子的前提下，去重新迭代创造新轮子，没有轮子，也要造轮子，因为只有自己写过的轮子，自己的认识、思考才能更深。这可能有内卷的嫌疑，但确实是经历后自己的切身体会。自我管理工作一忙起来，对自己的管理就变得越来越差。19年的一些好习惯在20年停下来了好多，比如俯卧撑锻炼、听书、算法练习等等，想想还是自律性比较差。看书看书不多，但是看的书不错，我很喜欢今年读过的书。读书、听书能让我安静下来，尤其是听《人性的弱点》，有时自己情绪不好，但是带上耳机，边走边听，就像一位智慧的老人在给你讲故事，与此同时，还告诉你很多真理。这本书让我意外的是，可以学到一些如何跟小孩交流的方式，其中让我影响深刻的几个观点：不要责骂别人给别人自重感多谈论对方让别人觉得这是他的决定他说的这些很有道理，一些也卓有成效，但是真的跟别人交流时，一些技巧并不好实践，还是需要多思考，更加耐心。另外还看了《人类简史》《马斯克的冒险人生》《天生有罪》，这几本书都特别有意思，一字不差的读完或者听完，看书真是别样的心灵旅程。独立开发19年就发布了咕咚云图，这是一个Android工具软件，它用来将手机图片上传到图床，然后生成一个Markdown链接，以便写作时使用。我之前也开发过一些工具APP、比如咕咚翻译，AppPlus等等，但是在咕咚云图中，在今年3月时，自己第一次加入了付费功能，主要是想亲身探索目前Android市场中的用户的付费意识。我依旧记得上线付费后，第一个用户的转账，让我很受鼓舞，一个永久激活码16元，不高不低的一个价格，但是对开发者的那种感觉完全不是数值大小能衡量的。后来陆续有用户不断付费支持我，我也保持高频的迭代更新，从一开始很丑陋的首页，逐渐优化到现在相对比较体面的首页，支持的图床也从一开始的2个，变为后来的9个等等。付费支持对开发者、对用户其实都是一种正向的循环。开发者得到了物质、精神上的认可，用户享受到了更好的用户体验。后面我还是计划了不少优化点，其中完成了一部分，还有一些没完成，主要是后面工作太忙，自己精力跟不上，而且有时确实也需要休息，后来的迭代就慢了，以后节奏应该会继续控制在一个稳定的状态。投资2020尽管疫情飞扬，但是股市却出奇的好，上证300指数上涨百分之二十多，尤其是年末的时候，股市一度要突破3500，感觉身边的人都在赚钱，每个人都是股神。另外，这一年关注了一个很有意思的公众号-招财大牛猫，相信很多人也有关注，他是一个财经博主，每晚写夜报，汇报今日市场情况，他的夜报很有意思，侃天侃地侃股市，从他那可以了解到一些市场信息，同时我更喜欢他对一些事情独立思考的能力。学习意识到了底层技术的重要性，任何知识点，稍微往深挖，无一不涉及到计算机的硬件模型、内存模型、进程模型等，只有更好的掌握了这些底层技术，研才会有深度，代码才会更稳健，所以我想，今年重新学一下大学时没怎么学好的计算机底层知识。总结如上，2020是很特别的一年，很纠结的一年，不好不坏，有得有失，但依旧觉得自己年轻，还有很多激情在心中，对于自己2020很重要的几个感悟就是，把工作做好，系统性的解决问题，不要轻易给自己一个答案，身体上可以懒惰，思维上别懒惰。</li>
  <li>作为开发人员，我们的大部分时间都在跟代码打交道，而代码的世界中充满各种规则（语法规则、设计原则等），为了更好的编码，我们必须按照那些规则去书写代码。但实际工作中，由于个人经验的欠缺或一时疏忽，总还是会写出有问题或者性能欠佳、不合规范的代码。这里，我们分别看几段Java代码。publicclassSerializableParamimplementsSerializable{privateStringnName;//成员变量没有实现Serializable，未来可能是一个隐患publicAdInfomAdInfo;publicclassAdInfo{}}上面的代码会有那些潜在的问题？publicclassDemoNewThread{publicvoidexec(){//企业项目中如果大家都通过newThread的方式去使用线程，有可能导致线程管理失控//而且线程的创建需要资源申请，成本比较高，随意的创建线程可能导致OOM等程序不稳定的情况newThread(newRunnable(){@Overridepublicvoidrun(){//耗时操作}}).run();}}生产项目中这样使用线程会有什么问题吗？publicclassDemoStacktrace{publicvoidtext(){try{inti=10/0;}catch(Exceptione){//打印堆栈时需要去收集当前上下文日志，而且这个过程是阻塞主线程的//所以生成环境最好不要打印堆栈日志e.printStackTrace();}catch(Throwablet){t.printStackTrace();}}}上面三段代码，各有其问题，但是很多时候，第一眼可能未必看出来，因为问题并不会每次都发生，一些问题，只有在特殊场景才会发生，但是从语法、最佳实践角度上，它们又存在100%出问题的概率。比如第一个SerializableParam类，这个类第一眼完全没问题，编译没问题，运行也没有问题，但由于成员变量AdInfo没有实现Serializable接口，未来在一些页面跳转时，如果需要传递SerializableParam实例到其他页面，这时就会出现crash，因为成员变量AdInfo没有实现Serializable接口。java.lang.RuntimeException:ParcelableencounteredIOExceptionwritingserializableobject(name=com.***.***.***.k.g)atandroid.os.Parcel.writeSerializable(Parcel.java:1850)atandroid.os.Parcel.writeValue(Parcel.java:1797)atandroid.os.Parcel.writeArrayMapInternal(Parcel.java:945)atandroid.os.BaseBundle.writeToParcelInner(BaseBundle.java:1584)atandroid.os.Bundle.writeToParcel(Bundle.java:1253)atandroid.os.Parcel.writeBundle(Parcel.java:1014)思考如何提前发现问题？严格代码review👁👁👁👁杜绝使用Serializable？😜通过工具自动检查代码第三种更可行，因为AndroidStudio已经提供了这样的工具-lint。什么是LintLint是AndroidStudio提供的代码扫描工具，可帮助您发现并更正代码结构质量的问题，而无需您实际执行应用，也不必编写测试用例。系统会报告该工具检测到的每个问题并提供问题的描述消息和严重级别，以便您可以快速确定需要优先进行的关键改进。from通过lint检查改进代码|Android开发者|AndroidDevelopers总结一下Lint就是：AndroidStudio自带的代码扫描工具无需执行代码，编码期间实时提示支持Java、Kotlin源文件、class文件、资源文件以及Gradle文件的检查具有可扩展性，可根据项目具体情况自定义lint规则支持自动代码修复AndroidStudio本身已经提供了上百条lint规则，比如在Manifest文件中注册Activity时，如果重复注册Activity，lint就会进行报错提示：如下所示：或者当我们定义了一个类成员变量，并且设置初始值，但是其他地方没有对这个变量进行其他赋值的操作，这时AS也会通过lint提示我们，最好把它设置为final类型，以达到一些优化效果，具体如下所示：以上两个示例，第一个报红了，代码会编译失败，项目不能跑起来，第二个没有报错，只是提示一下，项目可以正常运行。上面这两个规则是Android提供的通用规则，它们有一个显而易见的好处：编写代码时就可以实时提示错误。思考Android提供的原生lint机制可以在编码期间，就能对错误编码进行提示，那针对开篇提到的几个问题，如果也能有这种实时提示的机制，那么开发人员在编写实现了Serializable接口的类里，新增了一个没有实现Serializable接口的成员变量时，直接也能实时提示出错误，是不是就能很好的解决开发人员这个问题，避免页面进行数据传递时，发生Crash。经过调研，最终发现了可以通过自定义Lint的方式，实现上面的假设，最终效果如下所示：自定义LintLint支持自定义，通过自定义，我们可以根据自己的需要，扩展已有的lint规则，自定义Lint的好处显而易见：根据自己项目特点，灵活定制规则规则可积累，形成长效的保障随着不断发现问题，我们可以把能用lint解决的问题，都用规则编写出来，然后不断更新lint规则，这样可以确保同样的问题不会发生在第二个人身上。如何自定义Lintlint提供了几个关键的api，每一个lint规则对应一个Detector的实现，比如要编写上文中提到的Serializable规则，我们需要新建一个Detector，命名为SerializableSubObjDetector，然后继承Detector，并实现接口Detector.UastScanner，然后就是规则的实现。核心代码如下所示：publicclassSerializableSubObjDetectorextendsDetectorimplementsDetector.UastScanner{//定义issuepublicstaticfinalIssueISSUE=Issue.create("ClassSerializable","对象类成员需要实现Serializable接口","对象类成员需要实现Serializable接口",Category.SECURITY,5,Severity.ERROR,newImplementation(SerializableSubObjDetector.class,Scope.JAVA_FILE_SCOPE));//具体检查代码时的判断逻辑@OverridepublicvoidvisitClass(JavaContextcontext,UClassdeclaration){if(declarationinstanceofUAnonymousClass){return;}for(UFieldfield:declaration.getFields()){if(fieldinstanceofJavaUField){//检查当前成员变量是不是实现了Serializableif(!isFieldImplSerializable(field)){//如果没有实现，通过context来reportissueStringfileType=field.getPsi().getType().getCanonicalText();context.report(ISSUE,context.getNameLocation(field),"成员变量".concat(fileType).concat("必须实现Serializable"));return;}}}}}不同的规则，实现的方式各不一样。实现好之后，需要在一个注册器中进行注册。注册器也是一个类，我们的自定义lint工程需要写一个自己的注册器，它只需要继承Issue框架的IssueRegistry就好，如下所示：publicclassCustomIssueRegistryextendsIssueRegistry{@OverridepublicintgetApi(){returnApiKt.CURRENT_API;}@NotNull@OverridepublicList&lt;Issue&gt;getIssues(){returnArrays.asList(LogDetector.ISSUE,SerializableSubObjDetector.ISSUE);}}完成后，还需要在gradle文件中对自定义的注册器进行关联，以便生成对应的jar文件jar{manifest{attributes("Lint-Registry":"com.gudong.lintjar.CustomIssueRegistry")}}可以看到，上面最主要的逻辑就是Detector，自定义lint规则大都是通过开发一个Detector来完成规则检查。详解DetectorDetector是所有检查逻辑执行的地方，要定义一个Detector，主要的步骤就那么几个，下面以上面说到的Serializable为例：定义对应的Issue通过复写方法设置关心的探测点编写lint问题探测逻辑发现问题，然后报告issue其中理解Detector并不复杂，就是一个特定问题的检查器，它里面最主要的逻辑就是根据自己的需求去编写检查逻辑，只要检查到了问题，使用context去报告问题，就OK。另外就是确定检查的时机，比如Serializable这种情形，检查的时机就是类的成员变量，具体可以通过复写visitClass方法，然后在这里进行逻辑检查：@OverridepublicvoidvisitClass(JavaContextcontext,UClassdeclaration){if(declarationinstanceofUAnonymousClass){return;}for(UFieldfield:declaration.getFields()){if(fieldinstanceofJavaUField){if(!isFieldImplSerializable(field)){StringfileType=field.getPsi().getType().getCanonicalText();context.report(ISSUE,context.getNameLocation(field),"成员变量".concat(fileType).concat("必须实现Serializable"));return;}}}}而Log规则的编写（禁止项目中直接使用Log工具打印日志），就需要在复写方法调用的检查方法，也就是visitMethodCall，如下所示：@OverridepublicvoidvisitMethodCall(@NotNullJavaContextcontext,@NotNullUCallExpressionnode,@NotNullPsiMethodmethod){if(context.getEvaluator().isMemberInClass(method,"android.util.Log")){context.report(ISSUE,node,context.getLocation(node),"避免调用android.util.Log");System.out.println("========lintlog");}}Detector是所有检测器的父类，它里面还有很多这种回调，具体就需要根据自己需求去复写。通过Google提供的lintcheck学习lintcase列举除了上面列举的那几种case，这里还有一些常见的case比较符合lint检查：调用parserInt等转换方法时，应该强制提示开发者使用trycatch对代码进行包裹项目中禁止使用newThread去创建线程，只要检查到newThread这种样式的代码，提示开发者统一使用线程池equals判断时，如果有常量，常量提前，防止变量调用equals时可能导致的空指针复写方法父类方法是必须增加Override标识多线程情况下操作List时，如果有remove或者add操作，使用iterator等等我们可以思考归纳下，主要能解决的问题有那些：Crash预防：String转其他类型时，字符串不符合类型Intent传值时使用未序列化的对象map做get操作时自动装箱空指针多线程环境下操作ArrayList安全&amp;性能：避免直接使用原生Toast、Log、Thread类，统一使用项目封装工具类；代码规范：资源命名必须满足约定好的正则表达式；比如story中的资源名称一定要以story开头。Lint检查时机编码时实时检查代码运行通过gradle插件检查commit时通过githook检查代码提交到git仓库后，通过CI自动检查一些问题lint虽好，但是实践过程中，还是有不少问题。API文档目前最新的Scanner是UASTScanner，相比旧的JavaPsiScanner最大的优点是支持了Kotlin，但缺点是没有文档，中文资料几乎为0，所以开发时，很多方法只能去猜，很考验耐心。lint版本不得不说，一开始要跑起来lint的demo还挺费劲的，主要是相关文档太少了，而且没有官方文档，另外Lint版本与gradle版本强关联，如果gradle升级，lint版本也要升级。如何debug在编写自定义规则时，我们可能需要进行调试，但是使用system.out.print是无效的，我们需要其他的手段进行日志输出（比如通过context把日志通过report打印到屏幕），或者使用单元测试，具体可以搜索LintDetectorTest。多项目配置不同的项目，可能需要不同的规则，这就需要对自定义的lint规则库提出了更高的要求，这里仓库RocketZLY/AndroidLint提供了一种态配置的形式，可以参考一下。总结我们在编写的代码中有各种各样的问题，一些问题是业务逻辑问题，一些代码问题，而lint能覆盖到的问题只是一部分，但是lint的优势在于持续积累，如果规则库维护的好，随着项目的不断发展，lint规则库会越来越完善，所以要想发挥lint的威力，需要团队有一致的认识，并不断执行下去。参考资料尽管目前lint资料比较少，但是还是搜索到了一些不错的资料，这里提供出来。实际生产中的AndroidLint实践分享RocketZLY/AndroidLint美团外卖AndroidLint代码检查实践-美团技术团队sollian/CustomLintRules:自定义lint规则使用Lint进行代码检查・PPTing’sBloghttp://tools.android.com/tips/lint-custom-rules</li>
  <li>从去年疫情开始，生活的节奏就逐渐被打乱了，加上后面复工后开始加班，所以之前每天坚持的一些习惯都被冲击的乱七八糟。尤其是俯卧撑，去年应该有连续半年每天都做100俯卧撑，每天早晨洗漱完毕后，做十组，当时还特意从软件市场找了一个循环倒计时的软件。习惯停下来一段时间就很难恢复，这就是身体自己的惰性，直到今年十一假期结束。跟往年一样，每年十一都会回一次老家，今年提前三天回家办事，在老家呆了十天左右，期间见了很多亲戚、朋友。其中我二哥的孩子，也就是我侄子让我影响深刻。今年初三，14岁左右，他小时候很顽皮，不过性格偏内向，后来上学后学习成绩也一般，不过他胃口很好,很能吃，身体总是吃的圆圆的，但也不是那种肥胖。因为我常年在在，跟他见面不多，所以我对他的影响就一直停留在此。今年十一去他家做客，当时还有我两个表弟，见面寒暄没过一会，侄子就要跟我两个表弟掰腕子，一胜一负，其中负的一次是输给我一个在当兵快十年的弟弟，后来看到我，当然也没有放过我，我一开始觉得14岁的小孩应该很轻松才对。后来我赢了，没有放水，但是他的力量明显跟他的年龄不匹配，我后面几乎全力再跟他掰。当时就跟纳闷，这不是之前的他啊，短短一两年臂力怎么会变化这么大。掰完后我让他漏出胳膊让我看，擦，胳膊比我粗，还很强壮，甚是汗颜。后来才知道，他这两年迷恋上了自行车，各种自行车杂耍，他的力量大都是玩自行车过程中练出来的，因为杂耍对臂力要求高。对此，我也支持他，如果不喜欢学习，但能在其他领域找到自己的爱好，也很好，因为兴趣是最好的老师，当自己发自内心的喜欢一件事，兴趣就会产生强大的动力。后来跟我展示了他发在快手上的视频，确实一些动作比较危险，但看着很刺激，后来我还是跟他说要注意安全，建议他最好带上保护措施。后来十一回到北京后，第二天早晨开始，便恢复了每天的俯卧撑习惯。想想如果不继续锻炼，下次跟侄子掰腕子时，输赢就不好说了，说到这里，还得感谢我侄子，让我成功找到了一个继续做俯卧撑的理由。</li>
  <li>compressor是一个Android平台上的开源图片压缩库，使用它，可以对本地图片进行压缩，与此同时，还提供了各种压缩参数的设置选项。使用valcompressedImageFile=Compressor.compress(context,actualImageFile){resolution(1280,720)quality(80)format(Bitmap.CompressFormat.WEBP)size(2_097_152)//2MB}输入一个正常的图片文件，并设置压缩质量，以及格式化类型、最大压缩质量。输出压缩后的图片文件，该文件默认存储应用的沙盒目录下。核心压缩实现该库得功能微压缩图片，具体是通过Bitmap自身提供的compress方法进行压缩，但是这个方法有一定的限制，具体看##细节bitmap.compress(format,quality,fileOutputStream)压缩参数组合通过单例类Compressor的compress方法入口先指定目标压缩文件，具体压缩参数控制是通过第四个参数compressionPatch控制，它有一个默认的实现DefaultConstraint.default()，所以如果不指定其他设置，默认设置就会生效。此外，当设置了自定义的压缩参数设置，这些参数设置项都会保存在Compression的constraints集合中，这是一个图片压缩参数的抽象接口集合，然后遍历参数集合，并调用的实现。compression.constraints.forEach{constraint-&gt;//该策略是否满足条件while(constraint.isSatisfied(result).not()){//如果不满足，就进行处理result=constraint.satisfy(result)}}这样每一个压缩参数的实现结果，都会作为接下来压缩参数的输入，从而达到链式调用的效果，一步一步，让所有的参数设置在一个图片源文件上生效。压缩参数接口Constraint接口是该库的核心，也是一个很巧妙的设计。通常来讲，对于图片压缩，我们可以按照面向过程的思想，只需要定义一个方法，然后在方法中对图片压缩质量、压缩格式、输出位置等按个进行处理，最终进行压缩，这样代码逻辑就会集中在一块里，这样的设计对后续代码的维护并不好，而且不具备模块性，整个是一个大块，看着也不是很优雅。该库通过Constraint的接口很优雅的解决了这个问题。不同的压缩参数，自己去实现自己的压缩方案，这个接口提供了两个方法：interfaceConstraint{funisSatisfied(imageFile:File):Booleanfunsatisfy(imageFile:File):File}第一个方法是isSatisfied，它用于判断当前图片文件是否已经满足参数设置条件，如果已经满足，就不执行satisfy方法，否则就执行satisfy方法，satisfy方法用于具体的压缩选项设置。比如FormatConstraint的实现，这是指定压缩格式的实现类，如果当前图片已经是指定的格式，就进行处理，否则不处理。classFormatConstraint(privatevalformat:Bitmap.CompressFormat):Constraint{overridefunisSatisfied(imageFile:File):Boolean{returnformat==imageFile.compressFormat()}overridefunsatisfy(imageFile:File):File{returnoverWrite(imageFile,loadBitmap(imageFile),format)}}这里当检测到当前图片的格式不是指定的格式，就会执行satisfy方法，satisfy方法中执行具体的压缩，纵观其他几个参数策略的实现，它们大都是通过overWriter去进行具体的图片参数设置。overWrite的实现检查图片格式是否跟指定格式一致，否则更改图片名称后缀删除临时的本地图片文件使用新参数对Bitmap进行压缩、处理，并保存到新的临时文件并返回代码如下所示：funoverWrite(imageFile:File,bitmap:Bitmap,format:Bitmap.CompressFormat=imageFile.compressFormat(),quality:Int=100):File{valresult=if(format==imageFile.compressFormat()){imageFile}else{File("${imageFile.absolutePath.substringBeforeLast(".")}.${format.extension()}")}imageFile.delete()saveBitmap(bitmap,result,format,quality)returnresult}saveBitmap方法具体就是调用Bitmap的compress方法进行压缩。拆分Constraint压缩参数设置的抽象接口，每一种压缩策略必须实现该接口Compressor压缩门面类，入口类，只提供一个方法，用于让调用者设置不同的压缩选项，并启动压缩。Compression一个用于盛放不同Constraint的集合不同压缩策略的实现类DefaultConstraint默认压缩参数的实现DestinationConstraint指定压缩文件输出的文件位置FormatConstraint指定文件最终输出的压缩格式QualityConstraint指定压缩质量ResolutionConstraint指定图片宽高值SizeConstraint指定图片最终的压缩大小细节压缩质量设置对PNG图片无效。这是由于Bitmap自身的压缩限制，它提供的compress方法，即使设置了压缩质量，但是对PNG格式无效。fromBitmap#compress参数介绍如何实现指定大小的压缩#SizeConstraint设置文件最大质量，如果当前文件大小大于最大质量，则继续进行压缩，具体通过设置图片采样率进行压缩，并设置最低采样率为10，另外设置了压缩次数，如果超过了指定的压缩次数，还没有达到大小，则不再压缩，技即使图片质量还没有达到目标值。不足从上面overWrite方法的实现可以看到，每一次压缩参数的生效，都会伴随上一个缓存文件的删除，以及下一个临时文件的生成，这样可能导致压缩会产生比较多的IO开销。但这是一种博弈，这样的好处，是把不同的压缩参数实现拆分到不同的模块类，让代码结构更清晰，而且在我开发咕咚云图（一个手机图床）的过程中，并没有发现IO开销导致什么问题，所以，相比这样设计为代码带来的简洁以及可维护性，这样的IO开销可以忽略。咕咚DeepSource2020/12/03</li>
  <li>已经三周没打球了。往常，每周都会打两次左右，一般都是工作日的中午，会去公司附近的球场打球。但是这几周太忙了，中午也没有时间去，倒不是中午也在工作，主要是整天事情很多，晚上回去也晚，所以中午还需要休息。跟往年不一样，以前时到年末的时候，公司的需求任务都会变少，产品不会提特别大的新需求，因为求稳可能是年末更好的策略，所以开发的任务就也不多，主要做一些性能优化或者bug修复什么的。但是今年不一样，或者说，今年一整年都不一样，大需求层出不穷，开发时间从始至终都被安排的很紧。要说原因，可能有很多，但是作为一线的开发，你很难知道背后的原因。不过今年跟自己对接的产品同学有一点挺好，跟自己之前接触的产品不一样，她很多时候会把一些背后的改动原因告诉研发，比如说，要上线一个功能，是因为对应的策略在线上的数据很好看，或者也会告诉一些大佬们的想法。这是一种互相信任的感觉，当知道背后的驱动力，开发的时候有不一样的感觉，有时也会有虚无的成就感。可能是公司在变得焦虑，所以今年才会很忙，但是反观自己，貌似变得焦虑，而且一些事跟自己想想的并不一样。比如加班，以前不怎么加班，觉得如果加班，应该也OK，身体精神状态，应该都不是问题，但是真的连续加班的时候，会发现并不是，加班会产生连锁反应，影响工作，影响生活。明天周六，但昨天刚接到新需求，还需要加班。正巧今天穿了球鞋，所以今晚BasketballTime~</li>
  <li>之前，自己也会用一些市面上的订阅软件，比如Inoreader，Rolly等，但是前者不稳定，需要fq，后者，个人觉得操作有点奇怪，我理解订阅软件的首页都应该是信息流，而不是订阅源流。对于订阅软件，自己的需求比较简单，订阅+阅读，后来从一篇文章中得知了一个名叫Feeder的软件，设计简单，体验稳定，深得我心。但是首页总是看的拥挤。后来一个周末的早晨，睡醒后思考了一下订阅软件的逻辑，其实非常简单，主要就是解析订阅源，加上自己之前有咕咚云图的开发基础，所以说干就干，用了一天时间，便开发了一个最基本的软件模型，然后第二天就上架了谷歌商店。这其实就是一个月前的事，后面自己又不断优化，到这个周末，陆续又加入了以下功能自动夜间模式设置时间段，默认为晚上八点到早晨六点，会自动软件为夜间模式，有利于更好的阅读。收藏订阅文章有时会看到一些不错的教程或者其他文章，可能想要标记一下，以便后续阅读使用，所以加入了简单的收藏功能，也可以理解标记。目前标记只能通过首页中的文章菜单完成，如果要查看已收藏的文章，需要点击首页左上角，选择已收藏如下所示:提升刷新速度Rss软件的刷新是个难题，如果选择全部，每次刷新都需要把每个订阅源请求一遍，有些源只开放少量的文章，所以还好，但是一些订阅源会把自己博客的所有文章都开放出来，这样刷新就会很慢。原始版本但是串行请求，有时会花费一分多钟时间，还在用了多线程并发请求，速度快了不少。但目前感觉还是慢，我会考虑后续把加载动画做在主页title下方，另外继续研究研究有没有更好的rss订阅源同步方案，如果你知道，欢迎评论区留言。菜单逻辑优化现在首页流中最明显的菜单是文章菜单，点击可以收藏，复制链接。除此之外，点击订阅源名称以及icon，会弹出订阅源操作菜单，如下所示：这版本主要就改了这么多。软件的后续我在开发时，就知道了目前市场不允许订阅软件上架，但是自己还是开发了，主要原因就是自己需要这样的软件，订阅软件可以帮助去人们主动去筛选优质内容，尽管目前市场主流的内容大都是靠推荐，但是在小众的领域内，还是有不少人喜欢这种传统的方式，总之适合自己的就是最好的。另外有人说要不要做个订阅市场什么的，我不会做。通过订阅获取信息，是一种很主动的形式，你需要你才会去订阅，所以订阅的前提是你已经知道了这个订阅源，而不是去搜索。不足目前软件也有很多不足，比如本地html解析，现在默认阅读中的是GoogleChrome的customtab，如果你手机中安装了GoogleChrome阅读体验还不错，如果没安装，会跳转到系统浏览器，可能有点奇怪，但是自己暂时没时间去继续优化本地文章解析，所以暂时搁置。另外导入导出，数据备份也可以通过坚果云做的更好，这些后面根据时间、需要再安排。下载地址目前只上架了谷歌，如果觉得比较麻烦，可以直接通过fir下载，下载地址后续谷歌也不会更新的很勤快，但是fir会更新的比较多，但就是没有什么提示，如果关注这个软件，可以通过关注我的酷安动态或者我的twitter</li>
  <li>以前打仗、发动战争，图的是对方国家的资源，比如金矿、煤矿以及经济作物等，这些资源可以通过战争快速获得，所以战争可以让国家利益最大化。进入现代社会，一个国家的主要资源不在聚集在哪些物质类的东西，更多的是科技，银行，人才等，所以发动传统的战争意义不大，这种情况下，战争的成本就太大了，花了很多资金发动战争，即使最终赢了，也很难从战败国获得最核心的资源。这种情况下，和平就是更好的形式，不同国家互相贸易，这样对自己国家的利益更大，所以即使要发动战争，也会是另一种形式，比如中国跟美国现在正在进行的贸易战。说到这里，想到一个问题，如果一个人真想要报效祖国，参军的意义可能并不大，尽管看上去挺直接的，其实倒不如去好好学习科学技术，或者金融知识，让自己成为科技、金融人才，这样更有利于自己报国的梦想。以上有感于《人类简史》一场永远的革命一节</li>
  <li>早晨大脑中闪现出了一种对自己极具吸引力的生活方式：辞职，给自己放一年假，不工作，并计算设定好一年的基础开支。然后这一年纯粹做自己喜欢的事，比如开发app，写文章（每日经历以及一些思考），去游历，去没去过的地方。体验完一年，再继续决定要不要继续工作。这一年的重点是把自己想做的事都全身心的做了，像现在这样，时不时的处于一种纠结、焦虑的状态，感觉在浪费生命，很难受。</li>
  <li>今天湖人夺冠了，“湖人总冠军”终于不在是一个口号，而是2020一个特殊的标记。一些人质疑今年缩水赛季的总冠军含量，但总冠军本身就是一种肯定，质疑含金量确实有点伪球迷吹毛求疵的感觉。湖人一路在詹姆斯跟浓眉的带领下，取得了最终的胜利，一路上并不容易，都是一场一场拼搏出来的。整个季后赛一共打了四轮，前两轮关注的少，但是后面跟掘金与热火的对抗，充满了竞争与戏剧性，非常好看。掘金作为一直年轻的球队，在约老师跟穆雷的带领下，打的非常顽强，湖人虽然4:1赢了掘金，但是除了第一场，其余的每一场比赛最终比分差距都不大，这一轮湖人获胜的关键应该是浓眉。总决赛中湖人对战热火，热火的三分以及巴特勒的强硬，一度让人觉得有抢七的可能，但是今天，在詹姆斯的强势带领下，最终拿下热火。但是回看，热火已经发挥的相当出色，尤其是在第一场比赛就遭受伤病困扰的情况下，也因此，这轮系列赛也让我认识了邓肯-罗宾逊与纳恩。邓肯罗宾逊的三分太厉害了，这是可以比肩克劳汤普森级别的射手，不能给空，给就进。纳恩，是一个被忽视的点，作为一个突破手，他的三分也相当不错，而且相当果断。他的模样竟然看着有点韦德的样子，希望来年他可以打的更出色。最后说说老詹。今年35岁了，但是在当下的联盟，他依旧是独一档的存在，他的身体状态保持的依旧那么好，在整个系列赛里，他对自己的身体负荷管理做的很不错，而且他很明白什么时候该怎么打，他有非常清晰的大脑，尽管在一些时候也能看到他会犯一些错，但是整体而言，今年的总冠军经历中，他的经验对比赛的影响更大，他就像一个定海神针。另外不得不提的一个人是朗多，太喜欢他了，有他在，詹姆斯轻松了不少（要说的是，之前在凯尔特人时，那时自己其实挺讨厌朗多的，他就像个坏小子，时过境迁，我很喜欢现在的他。）要说到今年詹姆斯最佳的个人表演，要说西决最后一场比赛，最后关头连砍九分的表演，那真是让人血脉膨胀的表演，在那之前今年詹姆斯都很少中投，以至于让人遗忘了他还会中投…我詹威武，湖人总冠军…</li>
  <li>回家总是高兴的今年十一因为要回家办事，所以提前请了四天假，27号便启程了，机票价格合适，这次定了机票，跟老妈、孩子一起坐飞机回去。这次是自己第一次跟儿子一起做飞机。他很喜欢坐飞机，一路上奔奔跳跳，高兴的不得了，上飞机后主动系好安全带，然后就一直安静的坐在那里。老妈也是第一次在大兴机场坐飞机，大兴机场很漂亮，也很国际化，老妈按耐不住高兴的心情，一路上不停的拍照录像，拍了很多照片。那天天气也不错，所以老妈终于可以在飞机上俯瞰地面，之前两次航行，一次晚上，一次天气不佳，这次终于看到了地下。老家的特色小吃每次回家都要把老家的特色美食吃一遍，这次也是，下飞机后首先吃的便是牛肉面，但味道一般，现在的牛肉面没有了上学时的味道。后来在坐出租车的时候，跟司机打听，让他们推荐县城好吃的牛肉面店，尽管问到了几家，但后来却一直没找到时间去吃，算是这次假期一个小小的遗憾。回家的第二天下午去弄头发，完事后去吃甜丸子，要了一碗混合丸子（土豆丸子+红薯丸子），七元，吃的很满足。后来办事到了镇上，顺便就吃了麻辣粉，一般般，不过最后在，还是在县城又吃了一次麻辣烫，很不错。那次，还一起吃了面皮，那家味道很不错，可肚子容量有限，并没吃多少，倒是又吃了不少甜丸子。办事这次提前回家主要是为了办事，首要的便是分户。回家后的第二天便带着老爹老妈还有孩子去了镇上，自己之前已经准备好了相关的材料，所以很快便办完了，因为在户籍科，所以办完分户后，顺便给孩子办了身份证，他照相时，两边的肩膀总是不平衡，所以花了不少时间拍照，但拍照的过程还挺好玩的。分户最重要的材料是房产证明，证明你有自己的住所。分户后还牵扯到后续的一些补贴发放，但是当天并没有办完，回县城后才想起来，所以第二天自己单独跑了一趟镇上，办惠农一卡通有点麻烦，自己中午单独包了一个车去了乡上开介绍。包车的司机人挺好，一路上跟我聊了很多贷款的事，我也借此了解了一下老家贷款的流程事项。在农村信用社贷款最好的一点在于可以分多年去偿还，而非很多互联网贷款，尽管贷款比较容易，但还贷时间大都是限死的一年。后来到镇上自己又去咨询了一遍，工作人员说信用社贷款只针对当地常住人口，自己不是，所以我没有资格做信用评定，这个自己暂时也用不到，所以只是咨询了一下。回家的第四天，去县城办事处取了孩子的社保卡，一般的流程是社保卡从县城发放到镇上，然后镇上发给乡上的书记，然后发放到具体的村民。自己不想等太久，所以直接去领到了。但是老家的社保卡比较落后，目前貌似只有一个功能：60岁后取养老金。回农村我家在农村，而非城里，但是现在村里没什么人，这里年村里人都在县城租房或者买房住，我回家后一开始也一直在城里，住在老爹租的房间。但是每次回家我都会去老家的村里看看，因为那是自己长大的地方。老家变化很多。我们家的土巷子因为国家农村改造的一系列计划，被拆的面目全非，回家的时候还没有改造完，看上去很狼狈。回家后的当晚发现家里没电，后来发现是因为之前架设自来水管、拆巷子导致的，老爹很生气，自己也没有多言，我想这都是他的是事，就按照他自己的方式去处理吧。在村里只呆了一个晚上，第二天带老妈去了月牙湖，看了一下山顶的亭子，老妈很开兴，中午吃过饭后又去看了小学同学的老家。但是到他们家后门是锁的，跟他联系后得知他在放羊，后来联系到了他妈，他妈带着他外甥便回来了。老妈跟他妈一直在聊天，我则跟他外甥玩，这个小孩三岁左右，刚会说话，跟他玩很有意思，小孩很可爱。亲人老家有很多亲人，有哥哥、嫂子，有伯父姑父们，可能这次回家时间比较久，到回来时，发现自己基本把亲人都走访了一个遍。大妈大妈一个人在农村，对我很热心，知道我们回家后，第二天给我做了南瓜卷卷子，我跟老妈从下湖回去，到家便吃饭了她做的卷卷子，很好吃。二爹二妈回家当晚去了二爹家，二爹尽管年龄大，65岁左右了，但是精气神特别好，现在还是村里的领导，整天很繁忙，每月手机话费都不少。那晚还让我看手机的套餐详情，我帮查了一遍，其中有一个套餐每月19元，但是完全没什么用，我帮他退订了。二爹虽然高龄了，但是手机玩的不错，他喜欢看快手、抖音，期间一直在问，套餐更改后还能看视频吗。除了看视频，他还喜欢喝点酒，那晚我陪他喝了三盅白酒，白酒好辣。三爹并没有打算去看，但是因为村里在改造我们家的巷子，他在那里干活裹墙，所以便谋面了，没说什么，看上去变化不大。四爹四妈四爹之前帮哥哥看商店，后来不合适，但是闲呆着也无聊，所以置办了一个三轮车去回收废品，听他说每天大概可以收入20元，尽管不多，但是有点事干，总比无聊好。四妈一直在帮哥哥打理商店，同时还要照顾两个哥哥的孩子，所以整天比较忙，跑来跑去的就像打仗一样。老爹老爹从八月份回去，一个人住在永昌，平时打打零工，回去的那天他也在打工，晚上回去很晚了，后面的几天再也不去了。老爹胃不好，平时吃的都比较清淡，但很喜欢吃炒面片，回家第二天去办户口的时候，中午便带我们去吃镇上的炒面片，不知为何，现在的炒面总是吃不出以前的味道。哥哥们我有四个哥，大哥今年买了一个拖拉机，自己在经营这个拖拉机，给别人拉菜，这次前几次跟他联系都因为太忙没有见到他，终于在回北京前看到了他人，因为时间仓促，也没能跟他喝酒，下次吧。另外自己的大侄子长得很高，去年我还是我们毛家最高的，这次看到他后，我知道他比我高了，187，以后我只能寄希望于我孩子去超过他哥哥了。另外跟大嫂也聊了不少，大嫂总是很健谈，每次都跟她可以聊很多内容，大嫂很关注两个孩子的教育，挺好。二哥一直是大车司机，这次因为时间原因没见到他，等我联系他时，他已经开车去西安了。去年他还住在平房，今年自己住到了公租房，嫂子把房子收拾的很整齐，这次到县城后叫我们过去吃饭，另外还叫了两个姑妈，嫂子很热情，炒了得有八九个菜。二哥二嫂只有一个孩子，这次得知他喜欢骑车子，我看了他发在快手的视频，年轻真好，他因为经常杂耍自行车，胳膊很结实，虽然初三，但是胳膊比我粗壮。那晚，他见人就掰腕子，不过没掰过我，但是作为同龄人，他应该是佼佼者。三哥，也就是我四爹的大儿子，他一直在经营商店，目前已经有两个商店，并且位置都不错，目前经营的很好，这次十一，他们之前房子合同到期，正在筹备搬商店，他们要搬到隔壁，一个更大的房子。我要回北京前，他们已经搬完了，新的商店更大，看上去更加舒服，相信后续的生意会越来越好。新房子有一个二楼，这也是搬家的主要原因，因为这样孩子就可以更好的学习了，我去了二楼看过，很大，确实很划算。四哥，我四爹的小儿子，他一直在外地打工，主要从事室内装修，这里面他一直做这个，很有经验。他比我大六岁，小时候我跟他交集比较多，我们是邻居，是我小时候真真的哥哥，那时一起放牛，有很多故事。跟我嫂子结婚后，生了三个孩子，不知不觉最大的孩子已经初三了，而且学习成绩很不错。这次我去四哥家时，正巧他们在家，所以上去聊了一会，一起喝了三瓶啤酒。参加婚礼十一是结婚的高峰期，去年参加了自己表哥的婚礼，今年十一要参加一个高中同学的婚礼。这次听她说她叫了不少高中同学，所以婚礼也算是一次同学会，但最终来参加的同学并不多，来了只有六个同学，大家也并没有聊太多，大家最大的变化就是大都有了孩子。结尾十一很快就过去了，每天都有很多事发生，我在假期的每一天坚持写日志，足足写了十二篇，所有的日记都是通过自己的写作app完成的，这些日记大都是在做出租车的过程中写的。写作的过程中发现每天的事情太多了，每天都在不同的地方跑来跑去，我喜欢这样跑来跑去，这次走的地方尤其多。今天回想，感觉像梦一般，这么快，十一便已经过去了，今年回家后的第一个感觉就是明年十一不想回去了。这个感觉以前从来没有，这次不知为什么，回到老家后就不想明年再回去了，也许是倦怠了吧，之前六个十一假期我都回家，明年我更想找个地方去旅游看看，带着老妈孩子家人。</li>
  <li>《人类简史》中有一个有意思的问题。作者问道，为什么最先征服澳洲的是欧洲人，而不是中国人、印度人或者土耳其帝国等亚洲区域的人。事实上，在十七、十八世纪，欧洲的航海等科学技术跟中国等亚洲国家差距并不大，而且，亚洲距离离澳洲更近。作者的答案是：相比其他人，欧洲人更愿意去承认自己的无知。在同样的时代，他们发现对这个世界还有很多未知，而且愿意承认这一点，所以他们不排斥新东西，相反，他们需要探索更多的未知。而其他国家，固步自封，活在自己的臆想当中，骄傲自满，只会止步不前。这一点也可以从当时绘制地图的方式中看出一二。当时其他国家绘制的地图大都是以自己为中心，地图上画满了自己以为的世界，满当当的，而欧洲绘制的地图却有很多留白，可以看出他们接受自己的局限并进行正视。关于这一点，我有这样的理解。在那个时代，很多领域都是空白的，比如生物演化，化学、物理等领域有很多空白，远没有现在这么丰富，人们求知若渴，更加向往探索未知领域，去了解、建立新的知识理论。而现在，经过20世纪一个世纪的科学技术大爆炸，这个世界的知识体系开始急剧膨胀，各个学科都能衍生出一个人一辈子都学不完的知识，而且存储知识的方式也从物理媒介变为了几乎不受限制的电子媒介。所以现在已经不缺乏新知识，而且现在获取知识的渠道更多，知识量也很大，但是人脑还是那个人脑，并没有质的变化，跟几千年前的人脑结构处理速度并无二致，所以现在人们不缺乏新知识，相比而言，我觉得很多人缺乏的是对某一领域的专注能力。</li>
  <li>今天在寻我看到一个博主的文章—我过去一年的卖货经历，他在文末提到了别人说的一句话。Saythisaloud:IdeservetomakealivingdoingwhatIlove大声说出来，我应该通过做我喜欢的事去谋生下去。这是一种不错的生活的方式，他也是那样做的，他是一个创业者，独立开发者，自己做了一些工具，最后做了面包多这个服务网站，用于帮助别人买虚拟的物品，比如他自己做了这个网站后，首先就开始买起了自己的微信号，加他好友需要付款4.9才可以。关于做产品，他在文章一开头又这样一段描述，深得我心。一直以来我都觉得，产品的创造者，应该也是其深度用户。对此，我感同身受，如果要做好一个产品，自己首先应该是这个产品的用户，这样你才可以以用户的角度去审视产品，才可以关注到用户的痛点。我在开发PicPlus的时候，一直保持平时写字插图的习惯，所以不用用户提意见，自己就可以在使用过程中不断去找到优化点，不断完善。</li>
  <li>记得一开始微信把公众号的点赞改为“在看”后，很多人都惊呼这一举措，“在看在微信生态内构建了一个新的信息分发渠道”，同时也引起了“机器推荐”与“好友推荐”，孰优孰劣的讨论，个人觉得“在看”对创作者更有利，点赞对读者更友好。有时看到不错的文章，就想点个赞，但是滑动文章到最下方，却只有一个“在看”按钮。在看是一种表态，而且是一种公开的表态，互联网本身是一个不错的隐藏自己的地方，点个赞只想表达一下对写作者的认可，但是在看后，微信朋友都知道了自己的这个行为，这让人不爽。所以“在看”不能单纯的替代点赞的作用，点赞是一种轻社交，用户使用起来更舒服。这次微信重新开启了公众号点赞，同时原有的“在看”也保留了下来，我觉得这是一种比较合理的做法，对于有分享、表达自己想法的用户，可以选择在看，而单纯觉得文章还不错的用户，也可以继续“随手点赞”分享段永平的一段长文采访（虚拟），内容很丰富…投资要尽量避开产品很难长期做出差异化的公司，比如航空公司、太阳能组件公司。品牌溢价是一种误解，能长期维持的差异化才是护城河公司失败，本质都是因为产品的失败。保持平常心，没什么事情值得生气[小雅模拟深访段永平最完整投资思路梳理](https://mp.weixin.qq.com/s?__biz=MzI1MTYzMDY3Mw==&amp;mid=2247484441&amp;idx=1&amp;sn=1602baa46e11aa618db451e7530af81b&amp;chksm=e9f14127de86c831937930013130e01b055e5611c984a3ba4d8d1ea3d0a03eede7184512a682&amp;mpshare=1&amp;srcid=&amp;sharer_sharetime=1593396216590&amp;sharer_shareid=cf2da1dfac2ad798a3ed77123841da41&amp;from=groupmessage&amp;scene=1&amp;subscene=10000&amp;clicktime=1593398259&amp;enterid=1593398259&amp;ascene=1&amp;devicetype=android-29&amp;version=27001033&amp;nettype=WIFI&amp;abtest_cookie=AAACAA%3D%3D&amp;lang=zh_CN&amp;exportkey=ATY3hyHsXgTIX3C%2FbAw%2FQIQ%3D&amp;pass_ticket=wsHd%2BSgJGxmEiqFL0VrzN7iT8WDx7C3jDfk8BNMK5U0%3D&amp;wx_header=1)</li>
  <li>写字需要状态，如果有时要刻意写，其实并不容易，除非是简单的日记，否则要要写一些思考性的东西，还是需要一种写作的状态，让自己有感觉。写作的灵感有时就是那么一瞬间，那一瞬间，突然就有很多想写的，想说的。我记得有一天早晨在做题，突然有了一些付费相关的思考，然后马上下笔，把当时的想法都记录了下来，整体完成了70%左右，想着后续再补上剩余的部分，结果到现在还没有，一直躺在草稿箱里，所以有时候如果在自己的状态中，可以尽量延续到状态结束，因为这样的状态可能就在那一会…</li>
  <li>LskyPro（兰空图床）是一个开源的图床平台，使用PHP开发，项目主页地址https://www.lsky.pro/这是一个开源图床框架，使用该框架，其他人可以在自己服务器快速搭建一个类似SM.MS样式的图床服务。目前已经有一些图床基于兰空图床开发，这里列举我知道的两个图床，大家可以打开对应图床的主页，看看具体图床的样式以及交互，跟sm.ms很相似（作者也说了，自己参考了smms的UI）远方图床https://tc.ltyuanfang.cn/index/api.htmlYF图床https://img.52ggb.cn/index/api.htmllsky图床框架提供了设置选项，可以自定义图片存储服务，所以使用者可以使用阿里云、又拍云等三方存储来做自己的数据存储，这可以很好的保证自己的数据安全，同时有更好的上传体验。与此同时，它不仅提供了图床存储服务，还开放了API，使用这些开放api可以上传、删除管理存储在图床的数据。鉴于如此优秀的图床框架，所以这两天在发现该图床后，便快速的在PicPlus上对lsky图床框架进行了适配，这样，就可以在手机上，上传图片到自己的lsky图床了。什么是PicPlus:PicPlus是一个图床上传APP，可帮你上传手机图片到图床，并生成markdown链接，支持七牛云、阿里云等主流图床，同时还支持配置GitHub、码云为个人图床。如下所示：具体配置host中填入图床服务器host地址，以http开头，如远方图床，则填入https://tc.ltyuanfang.cn用户名、密码均为在图床平台，注册的账号密码点击测试、或者完成时，PicPlus会自动根据用户名密码去生成一个可用的token，以便上传使用。ps：点击右下角按钮，支持简单管理存储在lsky上面的图片。PicPlus下载地址：https://www.coolapk.com/apk/name.gudong.picLsky-Pro地址：https://www.lsky.pro/</li>
  <li>昨天下午去打球，接波打球，一共三波，我跟一起的同事一波，我们发挥的不错，一直稳坐场上，其中一波对手让我影响深刻。他们是四个小伙，学生样，初中或者高中，都比较瘦，一看都很灵活，而我们四个人，身体比他们大了一圈，力量强于他们，但是速度比他们差了不少。但最终，每一次遇到我们时，他们都输了，其中有一次，他们势头不错，就在他们连续得手时，他们的后卫还有前锋开始跟队友交流：“不要上头，不要上头，我们还落后”当时听到他们这样交流，让我很意外，这里首先说说“上头”是什么意思。有时候打球时，由于自己连续进了几个球，大脑就容易兴奋，然后下次拿球后，就很容易单干，觉得自己无所不能，一定还能进。但很多实践证明，这种兴奋的状态并不能持久，还容易失误，反而被对手抓住机会，然后葬送好局，所以连续进球时，更需要大脑冷静。当他们那样交流时，尤其他们还是学生，让我觉得难能可贵，毕竟这样冷静的意识，一些打球很多年的老手可能都没有。当然，最终他们还是输了，最后一球，利用我们的内外优势，强打篮下，有惊无险送对手下场。但是他们的那个举动让我觉得他们以后会打的更好…因为比赛的关键时刻，有时候，冷静的大脑更胜于球技…</li>
  <li>不少人喜欢用Markdown进行写作，因为它语法简单，上手快，可能不到一小时，即可掌握这种写作方式。而在一般写作过程中，为了更好的表达，大家都会选择在一些时候插入图片，因为恰当的插图会给文章增色不少。但是长久以来，Markdown这种写作方式的插图体验并不好，因为大多数Markdown编辑器要插入一张图片时，需要图片的远程地址，而非本地图片。所以要想插图，就必须先把一张本地图片上传到云端图床，然后使用图片的远程地址，才可以在文章中插图，格式如下所示：![](https://imgkr.cn.com/a2ed2.jpg)如果还不了解什么是图床，可查看这篇文章针对上面所述的Markdown插图问题，其实不少人都有探索。探索之前，经常在电脑上写作，所以很早就接触了到了iPic，它是一个mac端的图床上传工具，使用起来很方便，默认使用微博图床，但是微博默认是匿名图床，所以你永远也不知道那天图片就会消失。后来出现了PicGo，这是一个跨平台的开源图床上传工具，支持mac、windows以及linux。与此同时，还支持配置各种图床服务器，比如七牛、阿里等云存储，此外还支持github以及码云作为图床，很好很优秀。不过PicGo有一个缺点，默认不支持删除云端图片，也就是说可以通过PicGo上传图片，但是如果想要删掉已上传图片，就需要登录对应的平台，才能删除，这对于有图片管理需求的同学会比较麻烦。此外，上面的两个工具都只针对于PC平台，如果你经常在手机上进行Markdown创作，上述两个工具可能并不方便，而且即使我们经常在PC上写作，有时也需要上传手机图片到图床，比如截屏、拍照笔记等。这时我们就需要一个手机端的图床上传工具，而且最好也支持主流图床，如果还能支持Github、码云就更好了。PicPlus鉴于此，加上自己也是一个Markdown写作爱好者，所以在19年便开发了这样一个图床上传工具软件（Android）—PicPlus。PicPlus支持市面上主流的图床服务，如七牛云、阿里云、又拍云、腾讯云，同时也支持了Github以及码云作为图床。此外，为了提高图片最终的加载速度，在上传时会对图片自动压缩（可设置），同时，还支持删除已上传到图床的图片文件。系统分享传图另外，为了更好的挖掘上传图片的场景，还支持通过系统分享上传图片，这样不论在任何app中浏览图片，都可以很方便的上传图片到图床，如下gif图所示:举例来说，你可以在浏览知乎或者手机网页时，长按图片，选择分享，然后找到PicPlus，就可以轻松上传图片到图床。上传后会生成一个Markdown格式的链接，你可以选择复制或者分享链接，以便自己使用，同时也支持自动复制，即上传图片成功后，自动复制格式化链接到系统粘贴板。更多PicPlus还有很多功能特性，比如多图批量上传WebDAV同步数据常用图收藏gif图上传、图片压缩质量设置数据自动备份编辑Markdown链接标题等等…更多特性，欢迎下载体验，希望它可以帮你更好的写作。</li>
  <li>工作时想到一个腹黑的问题。在接手的很多项目中，很少有文档写的很详细的，貌似大家都不喜欢写文档。有时别说文档了，代码中能有一些前人的注释也算不错，慢慢发现，项目中能有良好的文档是一种奢求。当然这跟具体团队也有关系，不过自己经历过的大部分团队，文档意识都不怎么样，可能团队中的部分人有文档意识，但是整体对文档大都不重视。我个人算是比较喜欢写文档。开发完组件或者一些对外提供的模块后，总会想着去把文档也写完整，文档感觉就像是一个门面。写文档有很多好处。比如，如果有人要使用自己开发的东西，就可以让他先去看文档，这会降低沟通成本，提高工作效率，也显得自己很专业。这就是我对文档简单的一些想法，在这之前我从来没觉得有什么不对…不过最近有了一些新的想法。当你把文档写的很详细，一方面，如上面所说，可以提升团队效率，但如此同时，以后别人就可以相对轻松的能接手你负责的模块，你在工作中的替代性就大大减弱了。之前本来需要你口口相传才能解释的业务逻辑，现在，别人看文档直接就明白了，完全可以跳过你，相应的，你的价值可能就会有所降低。当然写文档终究是一个行业内大家都推崇的好习惯，但是大家为什么不爱写文档，难道只是因为懒惰吗，还是因为有如上所说这种因素呢，不得而知…不过，如上所述的分析如果要认真来讲，还是可以找到不少的漏洞的，但这里可以引申出另一个问题：效率真的是一枚银弹吗？效率一定越高越好吗？人类社会总是向更快更高更好的方向发展，如果一个东西可以带来效率的提升，大部分人都趋之若鹜。但事实上，观察这个现实世界后会发现，并不总是所有人都想着去提升效率。比如国家的公务员机构，机构为人民办事，理应让办事流程变得简单，方便大家办事，但是不少机构非但不优化流程，反而去设置更多的手续，增加办事难度，为什么？屁股决定脑袋，效率会革他们自己的命，他们恨不得流程越长越好，这样他们才有工作可以干，他们才可以在这个岗位上长久的待下去，亦或者还有其他的原因。类似的例子还有不少，比如送货无人机对快递员，机器手人对仓储分拣工人，前者都带来了效率，但是后者并不愿意去接受他们…总归，优胜劣汰，但是这个过程却并非一蹴而就…</li>
  <li>人有很多烦恼源于对自己不够清晰的认识。越早建立对自己正确的认识，就会越早的避免掉很多烦恼。如果对自己有清晰的认识，就会知道自己的边界，不会去对能力认知范围外的事物抱希望，而很多时候，这种希望往往会落空…脚踏实地，看世界之前先看清楚自己…</li>
  <li>上周末早晨去了附近一个公园，公园坐落于一个水库旁边，比较偏僻，所以人很少，一个人走在公园的马路上，很惬意。一直往前走，后来来到了水库旁边，水库旁边是高高的芦苇荡，发现有些人在走动着，过去后发现是一些观鸟爱好者。说到观鸟，之前并不知道也是一个爱好。第一次知道时，觉得有点奇怪，甚至还有点不解。直到后来，朋友圈里有一个做技术的朋友，经常分享一些鸟的特写视频，我才大概知道了『观鸟』到底是什么。简单说，这就跟钓鱼、打篮球一样，是一个纯粹的个人兴趣。跟大多数兴趣一样，这个兴趣也需要设备，就像打球需要一个篮球，钓鱼需要一个鱼竿，观鸟首先得有一个不错的望远镜，利用望远镜观测记录鸟类的生活活动。具体关于观鸟的解释，百度百科这样定义：观鸟，是指在自然环境中利用望远镜等观测记录设备在不影响野生鸟类正常生活的前提下观察鸟类的一种科学性质的户外活动。那么，观鸟的乐趣和意义是什么呢，一开始并不理解，不过，从朋友的一篇文章得知，他开始观鸟跟自己的眼睛有关。因为软件开发工作的原因，长时间看屏幕，导致眼睛有一些不适，所以后来去户外找鸟，听鸟的叫声，以便让自己的眼睛吸收更多的自然光。后来慢慢发现，原来有一个行业就是跟看鸟有关，所以后来便成为了观鸟爱好者。关于观鸟的意义，后来得知，一方面，这是一个户外活动，有益于人的身心健康，而且，这也是一种很好的与大自然亲密接触的方式，通过观鸟，还可以培养自然环保的生态理念，总之，这是一个小众但是很有意义的户外活动。其实在生活中，总会慢慢发现一些自己不了解，很小众的事，一开始会觉得很诧异，后来慢慢思考，便慢慢可以理解了，存在即合理，任何事有其意义所在。这里既然说到小众爱好了，就继续分享几个我知道、我认为的小众爱好。扳腕比赛扳腕很多人都知道，以前上学时经常跟邻桌玩，但是后来得知，原来还有专业的扳腕比赛，以及扳腕运动员，哦哦，正确的叫法叫斗腕…收藏收音机刚来北京时，同宿舍的一个舍友，家境很一般，但是就是很喜欢买收音机，然后收藏起来。当时就住在潘家园附近，三个月的时间里，他应该买了不少旧收音机。同宿舍的舍友都很纳闷，就问他，买那么多收音机干嘛，他只是说喜欢，而且补充道，家里还有好几十个。最后总归，这个世界有太多的未知，大家都习惯处在自己的小世界里。其实离开自己熟悉的世界，总会发现一些自己难以理解的事和人，也正因如此，世界才更加五彩缤纷…如果你还知道什么小众的爱好…不妨评论里分享一下…😜😜</li>
  <li>好巧，昨天刚提到泰森，今天就看到了泰森的一则新闻：53岁的泰森准备复出参加拳击比赛。泰森从05年退役，过了十五年后，身体状态跟以前完全没法比，而拳击这种对身体依赖特别强的运动，泰森是怎么思考的呢？原来是慈善表演赛，所以更多的是表演性质，就像很多NBA退役球星一样，也会去参加一些慈善基金会的表演赛，毕竟不用正儿八经的打，所以还好，不过既然是比赛，一定还需要赛前恢复训练。泰森以前在赛场外是一个十足的混蛋，他自己也这样说，但是在赛场里，他是少见的赛场君子，打拳很干净，拳拳到肉，不玩虚的，他一直看不起梅威瑟，就是因为这个“漂亮男孩”打拳太难看。泰森的比赛风格很好看，不知道时隔15年后，再次到赛场后还能有如何的表现，拭目以待。另外，他说了，参加表演赛主要为了筹款帮助吸毒的孩子还有母亲，这个动机应该跟他的童年还有过去有很大的关系。他之前生活在纽约的贫民窟，他看到过、经历过很多跟毒品相关的事，而且他自己也曾吸毒，所以毒品对一个孩子、家庭的破坏力，他很清楚。后来看泰森自传时，在一些后面的章节中可以看到不少悔过的表达。他想帮助别人，但是他的财务很糟糕，他的钱被他的经纪人还有拜金的妻子搞的乱七八糟，当然这些也不能一味怪别人，泰森成功的太快，有很多东西不健全，都为之后的一系列事件埋下了伏笔。但是后来写自传时，明显从字里行间可以感受到他想帮助别人的渴望，所以现在慈善表演赛，我相信他是为了帮助别人，而不是一些评论里说的泰森自己缺钱花了…另外关于泰森，有一个有意思的地方，他的偶像之一是毛泽东，他甚至把毛主席的头像作为纹身，刻在自己的肩膀上…</li>
  <li>这周罗志祥的事件上了微博热搜，猛料不少。明星出轨绯闻多了去了，罗志祥这次事件已经不是出轨这么简单了。这次事件让人思考的是这些艺人等有钱的成功人士的私生活可以有多混乱。看了罗志祥前女友的微博，可以见微知著，她留下了很多想象空间让网友自己脑补。看到爆料后，个人倒不觉得有多惊讶，尤其是去年看了泰森的自传后。泰森的自传以第一人称自述，讲述了自己的过往，其中有很多关于自己私生活的描述，混乱程度远胜罗志祥。人有钱了，内心会发生什么样的变化，可能只能到自己暴富了才可以知道。很多时候，有钱后内心的欲望被无限放大，一切变得触手可得，这种时候，危险可能也会接踵而至。所以万事万物，皆有两面性，有能力成功是一方面，还要自己的内心世界健康强大，这样才可以长治久安。之前上学时经常说到的，物质文明要与精神文明共同发展，可能就是这个道理了…🐶🐶</li>
  <li>![篮球场Daily04/22](https://gitee.com/maoruibin/assert/raw/master/pic/2020/IMG_20200422_125507.jpg)今天天气不错，时隔两个多月，终于打了第一场篮球。因为疫情的原因，大多数篮球场都被关闭了，要么场馆关闭，要么篮框被卸掉。之前在家办公，后来想着复工了，公司附近的公园应该可以打，结果公园球场也挂着锁子。目前在国内复工良好的情况下，篮球场只要控制好人数，加强管控，其实是可以进行打球的。这次疫情带来的影响是方方面面的，对各行各业都是一次重构，比如公司附近的公共球场，很可能疫情过后，就会采取管制，其它公共球场，也有可能会有相关改革。因为长时间不运动（其实也就两个多月），第一次剧烈运动，打了一会，明显觉得喘，休息了一会，再次上场，肌肉明显变得迟钝…所以如果长期在家，还是应该保持运动才是。说来惭愧，在家办公的那段期间写了不少代码，但是身体锻炼疏忽了，每天的俯卧撑计划也中断了两个月…让人痛心的事平常因为开发工作的原因，经常需要清除应用数据，所以对清除数据的操作相当熟练，甚至都可以闭眼操作。结果…今天一不小心，在清理微信旁边的一个应用的数据时，把微信的数据清理了…那个痛心…微信数据不同步，有时真是让人头疼，所以重要的数据，有时候只能长按收藏了…关于微信不做聊天数据同步，有很多说法，首先同步数据，微信会面临一些服务压力，面对亿级用户，聊天作为主要也业务，聊天数据必定是海量级别的，所以这会带来不小的开销。不过，同样的qq，却自始至终都在做消息云同步…🤫，所以我觉得服务压力有点说不过去。更有可能还是因为张小龙的执念吧…聊天数据存储在本地，逻辑会简单很多，而且操作速度也快，因为没有了服务端check，所以客户端的本地消息管理会简单很多，出问题的概率也会小不少。细心的你一定会发现，微信大多数页面不支持下拉刷新，比如首页，通讯录等，因为这些都是本地数据，所以不需要检查服务端。一份疫情报告“我们的许多惯常活动突然放慢——或完全停止。但是新型冠状病毒肺炎的影响也带来了其他领域的加速增长和关注。其中大多数都代表了多年来趋势的加速发展。大多数都有数字搭售，”from2020,theQueenoftheInternetreport</li>
  <li>PicPlus是一个图床上传APP，帮你快速上传手机图片到各个图床，支持七牛云、阿里云、又拍云等主流图床，此外还支持配置GitHub、码云为个人图床。酷安主页地址昨天，PicPlus发布了242版本，该版本主要支持了多图上传。一开始并没有在意这个功能，因为自己使用过程中多图上传场景并不多。在逐渐迭代过程中，发现PicPlus的不少用户是学生，他们经常需要把一些读书笔记或者试卷上传到图床，往往同时会有好几张图片，这时如果每次只能上传单张，显得很没有效率。其实，不仅仅是笔记场景，有时我们去旅游、游玩或者参加会议，其中可能会拍下很多照片，这时如果写游记或者记录，批量上传就会很有用，一次性上传多张照片到图床，美哉。此外，如上所述，批量上传操作完成后，往往需要批量复制链接，这样就可以把图片一次性的插入自己的文章中。批量上传+批量复制，这才是一个完整的批量操作，所以这次PicPlus在开发批量上传的同时，也支持了批量复制，批量上传成功后，会显示批量复制的面板，方便用户选择。除此之外，同时也加强了历史页面的功能。现在历史页面也支持了批量操作，可以批量删除图片，以及复制链接，具体可通过两种方式触发批量操作。长按历史记录列表项右上角菜单-&gt;选择PS：不会支持全选以及反选功能以上，就是242版本中的主要功能。功能稳定后，下版本会优化数据备份相关逻辑，同时会支持数据云同步，具体通过WebDAV实现，这也是目前个人软件中最常使用的方式。</li>
  <li>![软件园Daily04/12](https://gitee.com/maoruibin/assert/raw/master/pic/2020/IMG_20200412_092218.jpg)PicPlus是自己开发的一个手机端的图床上传软件，支持市面上绝大多数的主流的图床服务，如七牛云、阿里云等，还支持Github、码云作为图床。对于这个工具软件，核心功能特别清晰，即上传手机图片到图床服务器。尽管功能很明确，很单一，但是开发的过程中，首页如何设计，核心上传交互如何设计，却不是一蹴而就的，相反，在迭代的过程中，到目前为止，首页设计已经改了四次。简单就是生产力，但是太简单有时又显得很单调。这次新版本的首页，调整了最近上传记录与上传入口排列顺序，从操作上看，上传完毕后，最近列表立即更新已上传的图片，操作语义更自然，而且这次把上传进度设计到了首页，所以整体的上传显得更加流畅自然。回顾从开始到现在的设计过程，PicPlus的首页一直在强调上传功能入口，目前它是绝对第一优先级，因为这个app就是为了传图而存在。与此同时，上传历史是一个次要的产物，大多数时候，大家关心的是上传后的结果，一次上传完成后，这个图片的使命就已经完成，所以历史记录图片不会填充满首页。之前有一个版本尝试过首页展示历史记录信息流，后来总是觉得多余，所以即使把首页空着也没有展示历史记录，为了权衡，后来便只显示最近的十张图片。不过也曾想过，有一种场景，用户会特别关心历史上传的图片，即那种可复用的图片，比如自己的二维码或者广告头图，这种其实可以通过做一个收藏功能实现，不过暂时场景并不多，所以暂不考虑。当然，目前的设计依旧是一个不断优化的结果，并不是最好的，后续会继续去探索优化这个工具…</li>
  <li>上周在群里看到有人分享了一部最近上映的新剧，《鬼吹灯—龙岭迷窟》，之前在网上也看到过这部剧，是另一个系列—《精绝古城》，靳东主演，不过并没有看。这次在群里看到推荐时，看到新系列的主演是潘粤明，顿时就来了兴趣。去年在同事的安利下，看了白夜追凶后，不得不说那是相当出色的一部电视剧，当时还特意买了优酷的会员。白夜追凶的剧情很不错，很吸引人，潘粤明以及其他演员的表演也相当出众，看完后对白夜追凶2颇为期待，可2017年已经完结的剧，到现在也没有2的影子，每过一段时间我还回去网上搜索一下白夜追凶2的情况，每次都是没结果。所以这次看到潘粤明演了鬼吹灯，就立刻看了起来。目前看了六集，电视剧的制作水平很不错，电视剧硬是看出了电影的质感，很好，而且我很喜欢王凯旋的饰演者，这个角色挑选的很好，总之潘粤明很他很搭。前六集的剧情也比较紧凑，不过每次到美国那边的剧情，就想快进，还是看胡八一他们比较爽。现在每周只更新三集，有点难受，不过这也是网剧的一般套路，这样才可以有更好的长线消费场景，让网剧有更好的营收，不管怎么说，支持…</li>
  <li>任何人，都只能赚到自己认知范围内的钱。这句话放在股市尤为合适，如果对股市、金融没有做功课，凭借个人感觉炒股炒基金，一般人要做到赚钱是不容易的，有时可能行情好赚了点，但是只要玩的时间长点，很可能凭“实力”赚的钱，还会凭“实力”亏回去，所以如果对它们没有足够的学习，还是少投入一点，先学习学习，不要allin，因为没达到自己的认知范围。其实对于初学者或者股市小白，一开始采取机械式的交易可能更好，屏蔽掉个人的主观臆断，比如采取定投指数基金。其实话说回来，工作就是在赚自己认知范围内的钱，专业能力大部分时间都支撑着自己的主要收入，所以花时间投资自己的专业技术看上去是收益更大的策略。</li>
  <li>上周五接到通知，这周全面复工，还有点小激动，家里呆久了就会想念公司，公司是一个更大的集体，办公条件更完整，而且除了办公，公司里还有不少朋友，可以面对面交流，这种感觉不一样。这个假期从没有想过大学毕业后最长的长假会是这样的方式进行，这个假期有点长，也可能是人生中一段特殊的记忆。两个月的假期一直呆在家里，过年时疫情最严重的时候也曾恐慌，身体还有点不舒服，好在后来都没什么，但是思考了下，一个家庭在疫病年前好脆弱，牵一发而动全身，之前也思考过，不过没有像这次这么深刻过。假期里难得可以有很多时间，可以跟父母聊天回忆过往，有时候陪伴就是最好的礼物。PicPlus在春节前我已经发布了这个图床软件，发布后反响不错，从一开始就想过这个软件会做付费，所以在假期里趁着有时间，发布了付费版。说是付费版，其实也没有什么付费才可用的功能，只是对部分免费功能做了一些限制，所以我的引导语是“付费支持开发者”，其实更多的是捐赠支持。发布后让我很意外，第一天有10多个付费支持的同学，这在我之前是很难想象的，这侧面反应出目前国内android用户的付费意识明显比以前好很多，我觉得这里应该感谢纯纯写作的作者Drakeet，国内这种良好的android软件付费氛围跟他之前成功开发了纯纯写作有密切的关系。后面陆续有付费的用户进行购买，任何可持续的事情，我觉得正向激励很重要，软件更是如此，当有用户不断使用，不断付费这种动力就源源不断。不过对于工程师而言，最难的可能不是开发能力，而是产品规划以及设计能力，这个感觉在开发PicPlus的过程中感觉尤为深刻，一些很简单的问题可能并不需要写代码，只需要改变一下交互方式就可以很优雅的解决，总之，凡事真的要做时需要很多功夫，时刻保持谦虚。假期花了不少时间完善优化，尤其是支持了不同云存储，目前PicPlus已经支持了世面上所有主流的云存储服务，比如七牛、又拍、阿里。还有一个功能呼声很高—多选上传。由于旧的交互设定限制，所以全选上传这个功能不好设计，所以最近花了点时间重构了老的上传的交互，新交互实现后更容易实现多选上传，但是目前并不打算上这个功能，先把新的上传交互发布到新版本运行一个版本再考虑让全选功能，最近公众号新增长的粉丝不少都是PicPlus的用户，这里发布一个内测版本，可以体验最新版本，下载地址：http://d.6short.com/da9q</li>
  <li>昨天一早起来，发现有一个微信好友申请，看申请信息既不是来自群聊，也不是好友推荐推荐，而且没有打招呼的内容，一度以为是广告，后来打开对方的朋友圈，看到朋友圈的背景正能量满满，所以便通过了申请。没多久，看到他发过来一张支付宝转账的截图，我一看，欣喜万分，原来是付费购买PicPlus的用户，他已经完成了支付宝转账，但是我却没有发送激活码，所以才加我微信。这之前的好几个月里，业余时间一直在开发完善我的Android手机传图助手PicPlus（其实一开始的名字叫咕咚markdown助手，无奈名字太长了，所以就有了现在的名字），它的主要功能是把手机里的照片方便快捷的上传到网络图床，以便获取到图片对应的网络链接，然后使用这个链接就可以进行文章插图，这主要对手机端用markdown来写作的人有帮助，因为markdown写作过程中，如果要展示图片，就一定需要网络远程图片，比如这篇文章上方的插图就是用PicPlus完成的。PicPlus-图片极速上传图床，GitHub图床、CDN加速、搜狗图床(name.gudong.pic)-2.1.3-应用-酷安网软件目前只发布在酷安市场，主体功能基本完整，支持自定义图床，如github、七牛云等。同时，为了让软件更好的维护发展下去，这段时间还加入了付费逻辑，免费用户可以正常使用，但是会有一些限制，付费用户可无任何限制，包括后期的任何新功能都可使用。之前自己也开发了一些软件，但从来没尝试过过付费，主要是不熟悉后端，这次在发布PicPlus之初就想过，这个软件一直会走付费路线。但真正开始做付费时，才发现应用市场付费软件司空见惯，但开发起来付费功能时却一点不简单，总之牵扯到“money”，就得小心点，考虑的情形一定要多，容错也要合理。终于，前几周已经开发好了后端的付费逻辑，并且已经跟客户端联调完毕，我觉得有必要试试水，所以前天就先发了一个alpha版本到PicPlus评论区，别人可以通过我提供的链接下载。注意，这里是alpha版，我并没有把软件正式上架到市场，因为这种重大功能如果直接上线，出问题了作为开发者就会很被动，所以我跟谨慎的在软件评论区里发布了alpha版本。最新alpha4版本百度云下载地址（提取码：lxd4）https://pan.baidu.com/s/1Jg6ZMYJEDvZcq-Qvxqy7rg 前天下午发布后一直没反馈，感觉凉凉…然后昨天早晨看到了用户的转账通知，所以便很激动。看到转账截图后，我很快便从床上跳起来，去客厅打开电脑为用户生成激活码。这是第一个用户，后来陆续有几个用户向我购买了激活码，很开心。这也是我为什么要做付费的原因之一，体验不一样的软件开发体验。我之前写了一些免费软件，偶尔也会收到打赏，但是主动付费带来的这种认同感、激励跟打赏很不一样。后来一开始付费的用户给我反馈了一个很严重的bug，花了一点时间后来修复了，还好只是alpha版本，后来为了表示感激，送了对方一个一年期的激活码。接下来要做的事还不少，这不，今天早晨在后台已经发现有人开始尝试破解，尽管我已经做了防破解，但是“不怕贼偷，就怕贼惦记”，我能说啥呢…付费软件，路漫漫其修远兮…</li>
  <li>PicPlus是一个手机端的图床上传工具，支持七牛云、阿里云、又拍云等主流图床配置，同时还支持配置GitHub、码云作为自己的图床，更多介绍可阅读文章-PicPlus：Android手机端的图床利器|咕咚。付费功能有哪些？无限制的使用所有的图床tip:免费版用户，每月每个图床最多可上传20张（后续可能会调整变少）图片，超过后不可继续上传（下月自动恢复额度），但是可以继续使用GitHub图床、牛图图床。坚果云同步（后续版本支持）多图上传（后续版本支持）后续其他付费功能激活码是什么？激活码是使用PicPlus所有功能的通信证，普通免费用户会有部分功能限制。如何购买？在PicPlus中通过支付宝或者微信转账购买，购买后开发者会为你生成唯一的激活码，你可以在APP中激活此激活码，从而解锁付费版本，使用APP所有功能。费用按年付费：9元永久买断：16元有效期年费用户有效期一年，一年后将会降级为普通用户，如需要付费功能，需要重新购买。永久用户，激活码永久可用，可以换设备使用，但是同一时间只能有一台设备激活码生效，另外设备的激活状态将会失效。最后再次感谢你对PicPlus的支持，PicPlus因你的支持而更好。咕咚-PicPlus作者2020/03/16</li>
  <li>PicPlus是一个图床上传APP，可帮你上传手机图片到图床，并生成markdown链接，支持七牛云、阿里云等主流图床，同时还支持配置GitHub、码云为个人图床。这篇文章主要介绍如何在PicPlus中配置GitHub为个人图床，更多关于PicPlus的介绍，可阅读这篇文章-PicPlus：Android手机端的图床利器。准备工作在配置之前，首先需要一个GitHub账号，你可以打开GitHub官网先去完成账号注册。注册账号后，需要创建一个github仓库用来存储图片，如果你已经有仓库了，也可以直接复用，不过如果打算长期用GitHub做图床，还是建议建一个单独的图片仓库来存储图片，这样更容易管理。创建仓库点击GitHub页面右上角的加号按钮，可以选择创建仓库，如下图所示：点击NewReposity后，接下来需要填写仓库的基本信息，这里需要填写仓库的名称（记得用英文，比如MyPic、Picture之类的），建议勾选initialize，它会在初始化仓库时生成一个readme文件。其他的信息默认就好，然后直接点击最底下绿色的创建按钮即可。Note：不要去设置仓库的访问属性，默认公开，不用动，否则上传不了图片。获取token接下来需要为在自己GitHub账号下创建一个token，这个token将用来让app帮你上传图床，它是软件可以上传图片到GitHub的通行证。具体可以点击[https://github.com/settings/tokens](https://github.com/settings/tokens)去创建token，打开页面后点击Generatenewtoken按钮。点击按钮后会进入创建token的页面，这个页面只需要随便输入一个token名称即可，比如pic等，记得用英文，然后勾选下面的repo框就可以了，其余的不用选，然后点击最下方的绿色按钮就可以生成token了。生成token后，这个token很重要，现在立即复制它（刷新就没有了，只能重新生成。），发送到自己手机上，这个信息配置GitHub图床时需要。在PicPlus中配置GitHub图床通过软件中的侧滑菜单，找到图床列表，选择添加图床&gt;Github图床，如下所示：如下所示：下面需要填入四项信息，假定现在已经完成了上面的注册，并获得了如下信息token： xxxxxxxxxxxxxxxGithub用户名：gudong仓库名称：pic默认分支：main如下所示，首行需要输入token字符串，接着输入github用户名，然后输入仓库名称，按照示例分别填入gudong跟pic就OK，如下图所示：关于存储路径默认按照年月日的目录结构进行存储，比如今天是2020年10月8号，那么上传后，图片将会存储在2020/10/08/目录下。你也可以自己指定目录进行固定位置的存储，需要关闭按年月日存储的开关，然后输入自己的目录名即可。以上就是配置PicPlusGitHub图床的所有步骤，希望我说明白了。如果在配置中还有什么问题，可以在酷安私信我，也可以发邮件(1252768410艾特qq.com)给我，说明具体情况，最好有截图，最后再次感谢你的使用。</li>
  <li>还要继续在家办公下周还要继续在家办公，这样真的就在家里呆了一个月了，好长的假期。假期长的好处之一就是可以跟家人聊天，所以这个假期陪老妈陪孩子都比较多。老妈不知不觉在慢慢变老，但是老妈心态挺好，来北京后一直健身，而且形成了习惯，每天都会锻炼身体，所以身体还挺好，希望老妈一直健健康康的。孩子最近这段时间语言上一直在进步，时不时的冒出一些没听过的话，很搞笑，男孩就喜欢跑来跑去，在家里也是，陪他很累，尤其是这段时间还不能出去玩。三国演义今天吃饭时，突然奇想，找到了1994版的三国演义的电视剧，这部电视剧很出名，我妈说那时他们一集不落都看完了，不过到现在为止，我一直没认真看过这部电视剧。第一集是桃园三结义，真的还挺好看，经典就是经典，尤其是台词，就跟三国演义的原著一样，很精炼，文采飞扬，喜欢听到大家说着古文的那种味道。办理出入证其实就是个形式，但还需要去办，老妈老爹没有一寸照，今天就用支付宝里的工具生成了一寸照，还挺好用。后来准备去打印，骑车跑了一大圈也没找到一家打印店，悲催，后来办理时发现没有照片也可以，他们直接复印身份证照片，然后剪下头像当照片。咕咚markdown助手今天打算把app改名，这个名字太长了，打算改为PicPlus，另外新版本支持自动备份，这个功能自己是刚需，后续加入云备份，就更好用了，明后天打算发布…</li>
  <li>湖北换帅今天最大的新闻，湖北省委书记下台，上海市长接替，与此同时，今天上报上来的患病人数达到了最高点，一万六千多人，这操作很有意思。老人下台，顺便把坏账进行披露，舆论也都说的过去，新官上任后压力也小多了，这样的处理方式非常“高明”。用股市里的专业术语讲就是“财务洗澡”，从具体动作还可以说是“利空出尽就是利好”，希望接下来越辣越好。小米10发布会由于疫情的原因，这是小米第一次线上发布旗舰产品，以前每次小米开发布会都会趴在电脑前看一遍。到现在，即使有时间了，也不会去那么着迷的去追着看了，貌似自己慢慢的对小米退烧了。</li>
  <li>再说面向对象之前，先简单说说面向过程。面向过程软件在机器中运行，并用来解决实际问题，解决一个问题一定有先后顺序，只要把问题拆解开，然后一件一件的顺序完成，问题大都可以解决，这就是面向过程的编程。但是对于更加复杂的模型，如果继续使用面向过程的编程，一些程序就会变得不容易控制了。面向对象为了更好解决问题，需要对这个世界进行抽象，把一个任务、一个程序拆分成更容易控制和理解的小块，小块间定义好规则，然后在大块中，用逻辑把所有模块都运行起来，有相同特性的模块可以通过抽象、继承去更好的管理，还可以定义一些接口约束，让模块都具有同样的外观，等等，这就是自己理解的面向对象。面向对象的基本原则：万物皆对象。这世界中不论具体存在的事务还是虚拟的东西，都可以当它当成对象，比如现实世界中具体存在的轮船、飞机，还有虚拟的东西，比如任务进度、商品评价，都可以把他们当做对象，只需要对它们进行抽象，就可以把一切都构造为对象，然后用编程语言把他们组装在一起，加以逻辑处理，界面展示，用面向对象就可以解决实际问题了。面向对象三大特征面向对象有三大特征：封装、继承、多态。这也是整个面向对象的核心，只要理解了这几点，就可以写出面向对象的程序。封装可以把独立的东西包装成一块。经过封装，一个对象就成型了。比如要封装轮船，它有很多属性，比如重量、大小、速度、使用年限等，还有很多功能，比如启动、停止、装卸等方法，这些所有的属性、方法都包在了一个类里，然后提供出去，这样别人拿到包后，就可以直接使用，这就是封装。继承可以更好的利用已有的设计、封装。对于有共同特点，有继承关系的对象来说，通过继承可以方便的共享父类逻辑，更好的控制程序。多态主要通过接口实现，在运行时根据具体类型，调用同样的方法，但是实现由具体实现类控制。面向对象六大原则面向对象很好，但是同样是面向对象，不同的人可能会写出完全不一样的程序。为了让大家写出好的面向对象程序，前辈们总结除了六大原则，只要能够理解并应用这些原则，大家就可以写出不错的面向对象程序。与此同时，如果大家都按照这些原则去设计编写代码，那么在日后互相阅读代码、理解代码也就变得更加容易了。以下六大原则具体说明参考自网络资料，面向对象六大原则和设计模式单一职责一个类而言，应该仅有一个引起他变化的原因。也就是说一个类应该只负责一件事情。就是说一个类、一个方法应该只做一件事，这样可以保持类、方法的单纯，没有任何杂乱因素，使用和维护都会变得很容易，Lessismore。开闭原则尽量通过扩展应用程序中的类、模块和函数来解决不同的需求场景，而不是通过直接修改已有的类、模块和函数。一个软件实体类，模块和函数应该对扩展开放，对修改关闭。在软件的生命周期内，因为变化、升级和维护等原因，需要对软件原有的代码进行修改时，可能会给旧代码引入错误。因此，当软件需要变化时，我们应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。已有的类、方法可能已经运行了很久，他们也许有问题，但是尽量不要直接去改动它们，风险很大，不如对它们进行包装，通过外部方式提高他们。里氏替换里氏替换原则就是依赖于继承、多态这两大特性。里氏替换原则简单来说就是所有引用基类、接口的地方必须能透明地使用其子类的对象。通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何报错或者异常，使用者可能根本就不需要知道是子类还是父类。但是，反过来就不行了，有子类出现的地方，父类未必就能使用。依赖倒置高层模块不应该依赖底层模块，两者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象高层模块不应该依赖底层模块，两者都应该依赖其抽象。抽象不应该依赖细节。细节应该依赖抽象。接口隔离客户端应该依赖于它不需要的接口：一个类对另一个类的依赖应该建立在最小的接口上。根据接口隔离原则，当一个接口太大时，我们需要把它分离成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。迪米特法则一个对象应该对其他对象保持最小的了解。只提供自己该提供的，只了解自己该了解的。这一点具体实践指南就是，不要暴露出过多的方法、属性，优先把它们设计为私有的，只需要需要用到了，再去考虑开放访问权限。参考链接面向对象六大原则和设计模式2019-04-16：对于面向对象的六大基本原则了解多少？·Issue#29·Moosphan/Android-Daily-Interview</li>
  <li>前几天看了上海华山医院感染科主任—张文宏关于流感的一个演讲，视频内容挺不错，文末有视频链接。在之前虽然经常听到流感，但一直并没怎么在意过，流感跟感冒到底是什么关系，看了视频受益匪浅。流感的全称是流行性感冒，虽然也有感冒两字，但流感不是感冒，他们完全不一样，就像Java跟JavaScript一样，尽管都有Java的字样，但是是完全不一样的编程语言。流感是由流感病毒引起的，有传染性，有潜伏期，症状比普通感冒强烈的多，而且每年流感病毒都可能会变异，而普通感冒则由人体自身的病毒引起，即使发病，感冒症状也很轻，好的也快。如果要对比它俩，可以借用视频中的一个比喻，流感假如是老虎，那么感冒连猫都算上，甚至连兔子都不及🐰。总之流感跟感冒完全不一样，流感需要去医院治疗，而且实际上，流感的死亡率也不低，流感的死亡率有9%。我记得很清楚，前面一个同事在冬天的时候请了一周假，后来回来才知道他得流感住院了，回来后跟我们说自己怕的要死，因为会死人。对于病毒引起的疾病，最重要的一点是确定是什么病毒，只要知道了病毒，了解了它，才可以去更快的治疗，才可以去从根本上解决它。所以任何新病毒的威力都比较大，因为医生的数据库里没有这个病毒的资料，如果没资料就不知道如何对症下药，不光是对医生如此，对我们的身体也是。身体的免疫系统对新病毒也是没有任何历史记录，所以面对新病毒，我们免疫系统也很慌。上面说了流感的死亡率是9%，非典的死亡率是10%，但是说到非典人们更害怕，因为人们恐惧，人们之前没见过这个病毒，对于未知的东西，所有的生物都会一样感到害怕，我们讨厌未知。更多关于流感的介绍，建议观看下面的视频。https://v.qq.com/x/cover/mzc00200r3dzy7k/v3061pk3z1f.html</li>
  <li>前言之前开发了PicPlus，这是一个用来上传手机图片到图床的Android软件，后来还支持了GitHub图床，不过对于普通用户，配置GitHub图床稍微有点麻烦，所以就有了这个教程。另外一些人可能对图床跟GitHub这两个概念比较陌生，所以为了更好的这里也简单介绍一下，如果对它们已经了解，可以选择跳过下面的两部分，直接阅读正文部分。图床图床是用来在网络上存储图片的服务。可能有点抽象，这里先说说图片，图片是我们上网时除文字以外最常看到的东西，关于图片，如果通过存储形式区分，可以把图片分为：本地图片网络图片本地图片很容易理解，比如我们用手机拍的照片，这些照片拍好后，它们会存储在手机的存储卡上，只有自己可以操作，你可以对它进行编辑、删除等任何操作，但是除手机主人之外的所有人都不能访问，因为它们在你的手机存储卡上。但是在上网过程中，为了让自己的照片被别人看到，本地图片就不行了，现在必须把照片上传到网络服务器上，让它成为网络图片。比如现在想要在微博上展示自己做的菜，那么就需要把自己拍的照片上传到微博的服务器，这样大家就都可以看到这个图片了，因为微博的图片服务是公开的，上传后的图片会有一个网络访问路径，任何支持网络请求的设备都可以根据路径下载展示那个图片。使用网络图片的场景很多。比如现在要写一篇文章发表在网上，文章里需要插入一张图片，应该怎么办，本地图片肯定不行，这时就需要找到一个可以存储图片的网路服务器，把图片上传到网络服务器上，然后拿到这个图片对应的远程访问地址，然后就可以在文章中使用这个远程地址来展示图片了。一些网络文字编辑器，比如知乎、公众号后台、印象笔记等，它们支持把本地的图片上传并转化为远程图片。上面说到的，能提供图片存储的网络服务就是图床服务。目前，国内有很多产品可以提供这种图床服务，比如主流的图床服务有七牛云、阿里云、腾讯云、微博图床等，还有不少小众的图床服务，如SM.MS等。GitHub这是一个国外公司开发的网站，这个网站主要为程序员提供了可以共享代码、文件的服务，比如你开发了一个程序，现在为了让更多人参与这个项目，一起开发，一共贡献idea，就可以把代码上传到上面，GitHub提供了友好的协作机制，然后大家就可以共同提交代码，共同维护项目，不少公司或者个人都选择用这样的方式去开发项目，这也是开源的力量。上面说到的GitHub可以提供文件存储服务，所以它一定也支持图片存储，而且只要创建仓库时，仓库的访问属性是公开的，那么存储在这个仓库里的图片就可以为互联网上的所有人访问到。所以GitHub也就可以作为图床服务，而且GitHub可以免费使用（有付费版），存储空间也没什么限制，很好用。PicPlus咕咚Markdown助手如上面所述，如果你觉得七牛云操作麻烦、腾讯云还要付费，那么你就可以选择用GitHub作为自己的图床，来存储自己的网络图片。只需要注册一个GitHub账号，创建一个仓库即可，然后直接在浏览器里进行上传，或者通过git命令这种极客的方式去上传。但是不论那种，其实都有点麻烦，而且很多时候，我们需要把手机中的图片上传到图床，如果要使用GitHub可就太麻烦了。其实不光是GIthub图床，所有图床在手机上要上传都不方便。所以前几个月我开发了一个Android软件—咕咚Markdown助手，其中最重要的功能就是上传手机中图片到图床。于此同时，还支持上传到GitHub图床。目前该应用只发布到了酷安市场，咕咚Markdown助手主页地址，点击可访问。实际上，当你下载PicPlus咕咚Markdown助手后，无需任何配置就可以把本地图片上传到图床了，只不过默认使用的牛图图床，牛图图床有一个缺点就是上传后的图片无法管理，比如重新编辑、删除等，不过对于一般的使用场景倒也够用。如果你对自己的数据管理很在意，咕咚Markdown助手支持设置GitHub作为图床，所以你可以使用GitHub图床，不过还需要一些配置才可以使用，这些配置还是稍微有点麻烦，但是好在只需要配置一次，以后就不需要在折腾了，也划得来。具体如何在PicPlus中配置GitHub图床，请查阅这篇文章，如何为PicPlus配置Github作为远程图床后记这个软件的开发初衷是自己使用，目前支持GitHub图床、搜狗图床以及牛图图床，后续也会逐步支持七牛、腾讯云以及码云等其他主流图床。另外除了在软件内上传图片，还支持在相册中以及任何支持系统分享的地方，通过系统分享上传图片，这样你就可以在浏览相册、系统截图或者其他文件分享时，找到咕咚Markdown助手的传图入口，然后进行上传，如下所示：咕咚Markdown助手是为Android手机开发的图床上传工具，没有iOS版本跟PC版本，不过PC版也有不少这样的工具，比如PicGo，支持多平台，支持的图床也很丰富，其中就包括GitHub图床。还有MAC平台上很知名的iPic，也相当不错，操作体验很好。另外目前咕咚Markdown助手还在不断更新迭代中，后续会不断优化，添加新功能，如果你喜欢它，欢迎把它分享给更多的人。关于作者咕咚，软件工程师，独立开发者，喜欢开发、打磨效率软件，之前还开发过支持划词翻译的Android应用软件-咕咚翻译，更多应用可以查看我的product页面，我经常活跃在酷安市场，你可以搜索「咕咚」找到我。此外我也是一个写作爱好者，每天都会坚持写作，分享一些感悟点滴，文章会发布在公众号、博客以及酷安，如果感兴趣可以通过如下方式关注我：公众号：咕咚同学博客：咕咚的个人博客微博：大侠咕咚酷安：咕咚</li>
  <li>如何复制JSON字符串中指定节点元素？问题场景有时我们会有一串很长的Json字符串，如下所示：这时我们需要摘出其中一个节点，也就是拷贝某个节点的json内容，比如上图中的sk节点，现在我们可以手动用鼠标去选择复制。但是对于一些特别大的JSON数据节点，它的内容很长，这时手动选择复制就很容易出错。解决方案Google的Chrome浏览器提供了可以精确辅助的功能，如下图gif所示，通过Chrome提供的copy命令就可以非常方便的做到这点。操作步骤复制目标json内容打开Chrome开发者工具选择Console界面粘贴JSON代码到控制台并回车点击已输入的JSON串，右键菜单选择StoreasGlobalVariable这时原来的json串会被转换为一个变量名称temp1用copy命令进行复制，copy的参数可以是temp1，还可以精细化，指定到json节点，总之你想复制那个节点，指定就OK执行完copy命令，复制的内容已经到系统粘贴板，到目标地方复制即可。参考链接jquery-Javascript/Chrome-Howtocopyanobjectfromthewebkitinspectorascode-StackOverflow在线正则表达式测试百度翻译</li>
  <li>刚打开电视看到了科比的一个专题片，这个片子记录的是2009-2010赛季，总决赛湖人对阵凯尔特人的过程。这个系列赛很精彩，尤其是最后一场，也就是抢七。之前的五场比赛打完，凯尔特人在输了总决赛第一场的情况下，后来居上，取得了3:2的领先，第六场在湖人主场，湖人全队大发神威，在第六场成功扳平了大比分3:3，来到了至关重要的最后一场。第七场比赛，凯尔特人打的不错，一度取得了11分的领先，当时记得很清楚，看当时的比赛情形，对湖人很不利，感觉要完啊，这可是面对凯尔特人，从它们手里扳回11分的分差是不容易的。当时自己都开始有点担心甚至沮丧，但是，这就是职业体育的魅力，在面对如此大的压力下，我不知道杰克逊如何鼓励湖人队的球员的，在接下来的第三节里，湖人队突然就发威了，尤其是费舍尔的那以及扳平的三分球，影响太深刻了，职业球员的心理素质太强了。后来成功的逆转了11分，到后来科比进了两分后，湖人领先凯尔特人4分的过程就像梦一样，那场比赛看的自己热血沸腾，最后看到科比抱着球激动的冲上看台，我想这就是职业体育的魅力，永远也不知道接下来会发生什么，永远也不知道结局是什么。看到自己喜欢的球队赢球，也是一种巨大的快乐，每每想起那场比赛就觉得太精彩了、太好看了。那个赛季是科比最后一次的总决赛之旅，最后一个总冠军，也是科比最看重的一个总冠军。但科比在总决赛的表现并不是超神，这主要是因为凯尔特人针对科比有足够的准备，他们对科比的防守是那年季后赛里对科比最成功的，而湖人最终赢得总决赛更多的是靠整体的发挥，费舍尔、阿泰斯特、加索尔等在总决赛里都有很出色的发挥。不过湖人那个季后赛之旅中，科比在整体的系列赛里真是超神的表现，一个词形容就是得分机器，在面对雷霆、太阳时，几乎无解，那真是赏心悦目的进攻表演。季后赛结束后我看到了网友制作的一个科比季后赛里的微纪录片，特别喜欢那个纪录片。纪录片一开始对比了科比跟乔丹的动作，很美，纪录片里几乎记录了科比那个季后赛里所有的关键表现。当时还把那个纪录片下载到电脑，没事就翻出来看，百看不厌。前段期间科比意外去世，我再去找那部纪录片准备重温一遍，却发现就像意外离开世界的科老大一样，再也找不到了，sosad…</li>
  <li>这个假期确实有点长。自从大学毕业后，就和寒暑假告别了，说真的，还是很怀念那种放假一个多月的感觉的，不过无论如何也想不到，再次有这样的长假会是现在这种方式。这次假期比较长，但却没有以前寒暑假的那种快乐，相反，这次的假期一度让人焦虑，后来便开始找一些事转移注意力，而收拾房间是一种很好的方式。其实如果平时没有彻底收拾房间的习惯，你会很容易找到一些可以收拾的地方，假期里我相继收拾了自己的衣柜、书架以及今天的写字台。收拾东西让人感到舒服。首先这个事比较简单，都是一些体力活，完全力所能及？再者，很重要的一点是，收拾的过程可以加入自己的想法，比如如何归类书，如何更好的摆放东西等等，而且这些事很快就可以看到结果，这个反馈特别及时，真真的所见即所得，所以收拾东西这个事是有一些创造性的，人们都喜欢创造的感觉。还有就是，收拾的过程可以发现一些无用的东西，然后就可以丢弃了。我喜欢扔东西的感觉，总觉得少一点就更舒服，这种感觉很像删无用代码或者冗余代码的感觉，很享受。一些思考世界原本的状态应该混乱，而不是大家都喜欢的整齐。通过观察可以发现，我们都喜欢整齐、干净的东西，但是，与此同时，要想让它们整齐，就一定需要额外的动力源。比如想要让屋子干净、整齐，就一定需要我们花时间精力去打扫整理，否则按照自然的状态，屋子一定会越来越乱。这里面有一个熵的概念，杂乱的事物熵值更大，就像烧水的过程，热量从燃料传递到水中，随着水温度的上升，水分子开始剧烈的碰撞、运动，最终水开了，熵值从煤炭转移到了开水，而世界的变化，不论从微观还是宏观宏观也都是一种熵值的转换。收拾房子也是如此。收拾的过程也是熵值变化的过程，经过收拾，自己消耗了熵，然后转移给了屋子，杂乱变成了整齐。这个理论或许可以解释以前的一个说法：房间越乱、工作台越乱，越容易激发一个人的创造性，其实这也就是熵值越大，可能性越大的提现。关于熵，我很喜欢阮一峰的这一篇文章，墙裂推荐：熵：宇宙的终极规则-未来世界的幸存者</li>
  <li>不可捉摸的股市上周2月3号开盘后，因为冠状病毒的原因，周一大跌。在开盘前很多人也做了预测，大跌是必然的，不少人预测会是5%左右，结果周一开盘，上来就跌了8%，而且一整天的交易时间内，几乎没什么像样的反弹，到下午2:30后也是如此。在假期的时候就设想过如果面对大跌，周一犹豫了一会，最终还是选择了加仓，当时是这样想的，对于3000点以下的A股，大跌大买，而且历史上的任何一次股灾、大跌最终都会回去，即使是08年的金融危机，很快在09年便得到了修复，所以面对A股的这种大跌，最差的操作就是杀跌，当然要具体还要根据自身具体情况。在加仓时，并没有完全抄底，设想第二天如果继续跌再买，而且根据那天的情况，一整天都没有反弹，上证指数的曲线完全被按在地上。在收盘后，我看到有两个博主说，对于这种阵势，大概率大跌还没结束，第二天还会继续跌，结果剩下的四天也看到了，即使疫情并没有获得明显的控制，但是大盘还是逆势连涨四天，😌，完全不是预想的那种。搞不懂…Android写作软件这段时间在酷安下载了很多写作软件，发现对于写作体验这个事，大部分的软件处理的很一般，大家都是简单的实现了编辑功能，实际上结合自己手机上写字的体验，编辑文本这个事可以优化的地方还是不少的。对于写作，三点很重要：连续、不打断的写字体验安全不丢失文字流畅便捷的符号插入我在春节期间开发了自己的写作软件，后续会不断的通过自己的软件写作（包括这篇以及前面三篇都是通过自己的软件编辑），不断发现问题，不断优化，让它成为很好的写作软件。</li>
  <li>今天从一早晨开始，被李文亮刷屏了。这是一个普通的医生，求学、工作、成家立业，跟大多数人的人生轨迹一样，被大家关注皆因为他是“八谣”之一，比较特殊的是，作为一开始告诫大家注意安全的人，后来被感染了，直到昨晚医治无效身亡。这是一个悲剧，发生在普通人身上的悲剧，尤其看到他被训诫后按的手印，再结合现在全国上下被疫情折腾的鸡飞狗跳的样子，就觉得这事太魔幻了。他是普通人，他一开始发消息也只是发到大学同学群，提醒朋友同学注意安全，他的出发点只是帮朋友，他不是那种大众意义上要拯救地球的英雄。但这些不重要，在今天他就是人民心中的英雄，他代表了理性的声音，他更反衬了训诫一方的＊＊＊＊。这种时候，这些事发再多的感叹都意义不大，真心希望通过这些血的教训可以去触动一些有价值改变，否则作为普通人，谁也不知道谁会是下一个…</li>
  <li>![下了两天雪Daily2019/02/06](https://cdn.jsdelivr.net/gh/maoruibin/assets/pic/2020/IMG_20200206_180031.jpg)因为这次的冠状病毒，很多企业都延期上班，我们公司也是，在放假期间便确定了在家工作的方案，从2月3号到2月10号，节后的第一周都在家办公。到今天已经在家办公四天了，说真的，以前经常听远程上班，但却一直没体验过，其实国外就有一些公司这样干，比如gitlab，他们大部分的员工都分散在全球各地，只有每年开年会时才会聚一次。这听上去这很酷，很不可思议，但他们就是这样做的，当然gitlab这样做有天生的优势，他们本来就是做团队协作的，所以员工在意识上，这种线上协同工作的意识就比较好。关于远程上班，之前的第一感觉是：这靠谱吗，离开了熟悉的办公环境大家能按时完成任务吗？而通过这几天的工作发现，其实远程工作是一种很好的方式，尤其是像软件开发这种通过网络沟通就可以解决问题的工作，所以在国外可以看到一些工程师选择远程办公，同时一些公司也提供这样的职位。对于远程工作有几个优点。节省上下班通勤时间，这样不仅可以免去了身体奔波的劳累，还省出了不少时间，尤其是上下班还要来回，现在整天就在家里，时间富裕了很多。有效沟通更多。因为是远程工作，大家的交流都是线上交流，当然，实际上即使在公司办公，大家的很多交流也是通过qq、微信或者其他办公软件进行的，但是在家办公后，大家会更愿意选择用语音通话或者视频会议室进行，更高效。另外，关于远程工作，最考验的还是领导的统筹、组织、管理能力。其实只要领导可以把全局把控好，每天只需要检查大家的进度，整个团队的工作就可以有条不紊的进行。而且远程工作对于领导来说可能收益更大，因为只要他规划统筹的好，作为领导可能会更加轻松。写的软件被少数派报道了开心，昨天就有人在酷安市场提醒我，少数派报道了我的软件，今天在少数派的公众号就看到了推送。被推荐是一种认可，感谢感谢，目前app的日活用户稳定在60左右，还有很远的路要走，而且已经在酝酿几个不错的想法，也会逐步加入到未来的版本中，比如后台上传，更快的图床，不过目前软件缺一个好看的图标，个人设计能力有限，如果有设计人员对此感兴趣，欢迎py…</li>
  <li>昨天的文章被删了昨天的文章主要写这次春节的疫情，其实在发文以前，已经听说最近的审核变得很严格了，所以点击群发时，还在想会不会被退回来，结果发送很容易，一下子就群发成功了，不过终究还是没能躲过审查。过了没一小时，就收到了文章被删除的通知，😂这是第一次在公众号遇到文章被删除的情况，想不到平常不到20个阅读量的小博主也会被检查过滤…如果有人没有对被删除的文章感兴趣，可以点击原文去阅读，原文发表在酷安软件市场，大家貌似更愿意点赞。写了一个写作app是的，昨天跟今天的文章都是用自己的app码的字，之前一直用纯纯写作跟一本日记这两个app，都不错，纯纯写作安全可靠，体验不错；一本日记功能全面，都用了很久，而且都买了付费版，不过用纯纯写作写了七八十篇Daily后，总是觉得有一些不舒服的地方。具体就是纯纯写作的交互用着有点别扭，而且我对文章分类比较在意，而纯纯的分类操作起来总是觉得麻烦，一本日记也是，同时一本日记不能打开就写作。所以趁着这个假期有时间就动手开发了。目前基本功能已经完成，还有很多细节需要完善，暂不打算公布，自己什么时候觉得用的很舒服了再考虑放出来，否则太早公布要面对很多用户的建议，还是自己先用舒服了再说，关于这个应用的更多细节考虑之后专门写篇文章外介绍，不过如果有人对此应用有兴趣，可以私信我，我可以提供体验包。分享关于创新，埃隆马斯克引爆了一个概念，回归到事物本质，看透问题本源的思维叫“第一性原理”，它不是一个定律也不是真理，而是一种思维模式。from本质思考是产品创新的基础</li>
  <li>我的Daily从放假后就停了，休息了十多天了，任何习惯只要停下就很容易永远的停下了，所以保持连续性很重要，假期停下了好几个习惯，现在该恢复了，今天就从Daily开始。2020的春节注定是一个全国人民刻骨铭心的春节。从一月末新型冠状病毒被专家确定人传人开始，一场没有硝烟的战争拉开帷幕。发展到今天已经有20471人感染，其实一开始就应该有不少人感染了，只是确诊受到医疗物资限制，直到后面各方援助不断支援，加上冠状病毒潜伏期长，所以随着时间推移，数据也越来越大。看到这么多人，每一个数字后面都是一个家庭，真的很痛心。2003年典那会，还在老家上初中，虽然当时看上去也挺严重，但是老家那边，到非典结束也没有出现感染的例子，所以做了很多消毒、防护工作，但最终感觉就像是看了一场演习，而这次在北京，战争就在身边，这种感觉明显就不一样了。从一月末国家发布公告后，公司同事上班都带着口罩，坐地铁也是胆战心惊，甚至一些人开始打车上下班，公司开始统计大家的出行情况，只要过年回家经过武汉的，年后到北京了都要在家隔离14天，包括后来专家也倡议，春节不聚会，不走亲戚。所以今年过年时就非常特别，大家都呆在家里，还有段子说看自己微信好友的步数统计，如果超过100步就跟他绝交，在这样的情况下，过年时路上特别的冷清。还有段子说，以前人类肆意的把动物关进了笼子，这次换做动物把人关进了笼子，这个笼子还是自己给自己盖的，是不是很讽刺。说到这个，不得不提蝙蝠这个事。昨天看报道，貌似专家已经基本确认这次的冠状病毒来源于蝙蝠？（也有说病毒泄露于武汉病毒研究所？？微博），所以这就是一次人类自己作死的代价。李永乐老师在视频中说，蝙蝠竭尽全力的把自己长的不像是个食材，但最终还是没能躲过上餐桌。跟老鼠一样，蝙蝠身上特别容易携带病毒。在今年疫病爆发之前，我完全没想过蝙蝠居然可以被用来吃，不可思议，我甚至觉得蝙蝠都不能算野味，这东西跟食材完全搭不上边嘛，总之吃蝙蝠这个事是一种违背常理的事。人类生活在这个星球上，应该跟大自然和谐共存，互利互惠，不能一味索取，而且应该保持底线，无底线，无限制，不科学的行为终究会收到惩罚，况且在17面前果子狸就惩罚过一次，人类总是很容易忘记过去的疼痛，只要时间够长。看了这篇报道，才知道野生动物市场有多吓人by余晟对比，我觉得国家真的应该从源头抓起，认真规范落实一下关于野味的市场，否则下一个17年谁知道又会是什么病毒呢。这个假期因为疫情衍生出的问题不仅仅局限于疫病，通过每天24小时不断的新闻爆料，关于政府、医疗、捐助、红十字会等等，各种消息每天铺天盖地，真的是应接不暇。看到那些消息，只能摇头，我想每一个问题都有深层次的原因，而且不是一朝一夕的。之前也说过，任何问题，归根结底是体系问题，绝不是单纯的人本身的问题，如果解决不了根本问题，这样的问题还会继续发生，这次暴露的是武汉、湖北的问题，那其他省市呢，会有多好呢？不得而知，甚至在发生这一切的时候，当事政府真的会反思自己的失职吗，还是会惺惺于自己运气不好呢，这些出工不出力的败类…假期的前几天每天都沉浸在各种消息中，每天都有新消息，这些消息不知不觉带来很多负面的东西。这次的疫情因为时间点刚好跟春节交汇，所以很多措施很激进，比如湖北的封城，北京这边封小区，总之搞的大家人心惶惶，恐慌的情绪有过之而无不及，自己也是，身体的一点不舒服就让人心惊胆战的，人一旦开始胡思乱想起来就会把事情想的很严重。但是，当认真思考疫病对一个家庭的影响时，那真是很绝望，尤其是面对这种传染性疾病，一个普通家庭太容易被疫病打倒了，疫病不仅仅耗费的是财力，更多耗费的是人的心气。当家里有一个人生病，全家都会为此团团转，相信武汉有不少这样的案例，所以看到那20000多个数据，就很痛心，不知道这背后有多少泪水，多少悲伤，多少无奈。对一个家庭如此，对国家也是，这次的疫情作为一个黑天鹅事件，对国家的影响方方面面，比如出行、餐饮等各个行业都深受其害。大年初四我去外面买菜，回来时发现小区外面有一团人很热闹，过去一看，原来是附近一家大餐厅由于年前囤了不少蔬菜，但是因为疫情，今年过年不能营业，于是便开始清仓甩卖蔬菜，所以疫情的影响太多了，各行各业几乎都受到了不小的冲击。昨天股市开盘，大盘一下便跌了8个点，真是一站回到解放前，去年可能一整年的收益就因为这一下就灰飞烟灭了，微博上不少人说如果要举行比惨大会，自己一定赢。但是说到底，我还是相信国家会处理好这次疫情，相信勤劳勇敢的中国人民，相信国家强大的调度管控能力。就像股市，这不今天已经开始强力反弹，不过创伤不小，还是需要时间去修复…2020，加油…加油…</li>
  <li>科比他走了…了解我的朋友大都知道，我喜欢打球，可以说打球是我最大的乐趣了，我从高中开始打球，那时科比是一个遥远而模糊的影子。高中时住校，很少能看NBA直播，对NBA球星的认识大都停留在贴纸上。高一的我篮球技术一般，但是在室友的带动下慢慢喜欢上了篮球，又在同桌（包子）的带领下，我认识了NBA，到高一下学期时NBA球星的名字已经了解的差不多了，那时要是多知道几个球星的名字，甚至会觉得很自豪。那时还有一个手掌大的黑皮笔记本，笔记本的后面几页贴满了贴纸，姚明、科比，麦迪可能是我贴的最多的，这个笔记本现在还在身边。那时的科比是模糊的，对他的了解大都来自同学间的口口相传，单场81分，各种绝杀等等。第一次看科比直播的那场比赛记得特别清楚，那是07-08赛季的揭幕战，湖人主场迎战火箭，姚麦对科比，比赛交替领先，很精彩，直到最后才决出胜负，当时记忆犹新，是巴蒂尔的一记底角三分让火箭赢得了比赛。大学后渐渐的，看直播的机会越来越多，以前高中那种直播的匮乏在大学得到了彻底的满足，对科比印象最深刻的一个系列赛就是09-10赛季了。那个季后赛里的前三轮他就是杀神，无人阻挡，对他印象最深刻的一球就是对阵太阳的系列赛里，在比赛的决胜阶段他接管比赛，连续得分，当时防守他的是希尔，太阳队知道球一定会交到科比手里，所以当科比接球后，太阳队教练金.贝利安排两人去夹击科比，科比被两人挤到右侧底角，几乎没有什么空间，但他依旧用后仰跳投完成得分，得分后，科比回防时拍了拍金.贝利的屁股，金.贝利无奈的笑着然后冲科比不停的摇头。很多人不喜欢科比，认为科比太独，经常到了关键时刻，哪怕别人有更好的机会，他也会选择自己干，而不是传球，但这就是科比，对此，他有自己的解释，但不论别人怎么说他，批评他，他对关键时刻自己干这个事始终都是绝对相信，他的谢幕战也是如此，从头干到尾，这就是科比。19年的总决赛第五场在加拿大的多伦多举行，猛龙队只要赢下了这场比赛，就可以在这里完成夺冠。第三节时猛龙队还落后于勇士队，这时莱昂纳德突然开启杀神模式，一阵狂轰乱炸，连续得了十多分，瞬间反超了比分，当时杨毅作为解说员很激动的说：“看直播的各位观众朋友，如果你们没有看过以前乔丹、科比是怎么打球的，那就是像现在这样”科比很特别。一直都说他的天分并不高，他只是对篮球比别人更热爱，付出的更多而已，而且他对自己的要求也很高。他不光对自己要求高，对队友也是如此。他看不惯别人对篮球嘻嘻哈哈，他不能接受懒惰，跟霍华德搭档的那一年，他指着霍华德的鼻子骂“软蛋”，后来霍华德离开湖人，直到去年，霍华德在一次采访中才说到，他误解了科比，还跟科比道歉，说科比都是为了激励他。严格意义上自己也不算科比球迷。从一开始打球，看球，还是关注詹姆斯多一点，詹姆斯全面，打球合理，力量出色，打球更具力量美，所以大家把詹姆斯的打法比作坦克，科比的投篮优美，进攻技巧出众，他的打法被更多的人比作落叶，他俩是两种完全不同的打球类型，也吸引了不同的粉丝群体，所以也就有了詹密、詹黑、科密、科黑这四个群体。自己更关注篮球本身，所以更像是一个詹密和科密。我喜欢科比那种不服输、严谨的篮球态度，以及那种关键时刻舍我其谁的英雄气概，同时也喜欢詹姆斯强力的突破方式，还有恰到好处的传球。非常巧，昨天詹姆斯刚刚在比赛中完成了NBA总得分对科比的超越，赛后科比还第一时间在twitter对他的兄弟詹姆斯进行了祝福，但是今天凌晨四点，科比跟自己的女儿就因为直身飞机故障而离开了这个世界，让全世界为之动容、颤抖。借用微博网友的一句评论性格孤傲的科比，甚至不给我们这一代人看他老去的机会😭foreverkobe</li>
  <li>今天一早就推送武汉封城的消息，这个消息昨晚就有传言，今天落实了，从今早10点开始封锁出武汉的各种交通形式。没封锁之前，在国家的呼吁下，很多人可能也不打算出城，因为家在哪里，但是封锁的消息出来后，这种感觉就不一样了，隐隐的一种压迫感袭来，不过以大局为重，这可能是更好的限制疫情扩散的方法。我忘了以前非典时，北京有没有类似这样的封城，无论如何，封城都是很少见的防疫策论，可见目前的重视程度。中午看到了财新网发表的管轶的那篇文章，读完后马上就感到焦虑了，字里行间的那种紧迫感呼之欲出，但是很快就觉得应该去查查这个人，他的消息不一定是真实的，尤其是最后那耸人听闻的“十倍与非典的结论”，后来微博不断曝出这个人之前发表的结论，总之他的言论并不靠谱，不可全信。这是微博上关于那篇文章的一些讨论https://weibointl.api.weibo.cn/share/115076667.html?weibo_id=4463906443091278也许是因为封城，也许是因为管轶的文章，今天股市大跌，沪生指数跌了快3%，很少见，这在美国就是股灾了，我第一眼看到有点慌，后来想了想，我还是更相信国家，相信勤劳的中国人民可以战胜这一切。目前也有一个好消息全国首发！疫情防治的协和解决方案，最新升级版来了！</li>
  <li>今天是官方公布肺炎消息的第三天，早晨地铁里戴口罩的人明显变多了，不过今天明显感觉已经没有昨天那种人心惶惶的感觉了，在各个机构不停的发布消息的同时，各种预防措施也越来越多，总之感觉这次官方的宣传还不错，目前感染人数也没有出现特别大的波动，这都是好的方面。到公司后，不知道是公司集中采购的口罩还是国家集体投放的口罩，公司通知大家凭工卡，每人领取两个3M口罩，跟同事去领口罩时，发现人太多了，都在排队，自己又没有戴口罩，索性还是再等等，口罩总会有的。前天收到了年会中奖的邮件，昨天太忙，没顾得上，今天便去领取了自己的年会五等奖，kindle，操作了一会，并不是我想象中的完美，自带的操作操作很迟钝，感觉回到了功能机时代，但是质感挺好，经同事提示，后续可以给kindle换一个多看的操作系统，操作体验会有明显改善。中午去球场打球，遇上了上次打球的黑人，他很高，接近两米，体重应该在240斤左右，篮下技术很扎实，很会打球，中文说的还很不错，跟他同事打听后，原来他是科特迪瓦人，在中国上学，已经呆了13年，很友好的一个人。下午发布了咕咚markdown助手的2.0版本，年前的最后一次更新。晚上本可以早下班，但收到故障报备组的邮件，跟同事查问题查到九点，今年的年末是一点都不太平啊…回来的路上路上一路通畅，空无一人的西二旗地铁站，过年好啊…🤣</li>
  <li>前天凌晨一声惊雷，官方公布了最新的疫情进展：图片来自全国新型肺炎疫情实时动态-丁香园·丁香医生224例，然后这两天全网都在热谈冠状病毒，大家都开始高度紧张起来。昨晚完美世界公司，因为一个员工武汉探亲回家身体发热，提前给公司员工放假，然后给公司消毒，员工甚至不让回公司拿东西。今天早晨坐地铁时明显戴口罩的人变多了，到公司后，在工位办公时大家甚至都戴着，然后任何休息的时间都能听到各种讨论的声音。这次的病毒能引起这么大的效应跟之前2003年的非典有关系，因为它们都很多相似之处。非典时刚上初中，那时互联网并不发达，但是那时真的是人心惶惶，学校里每天早晨要大扫除卫生，开窗，然后消毒，不仅有消毒液，我记得还用到了白石灰。当时我妈刚好在外面打工回到家，班主任知道后把我叫出教室，跟我说明了情况，说让我回家呆一段时间（隔离），不用上课了，当时心情还挺难过的，因为感觉收到了区别对待。后来我们那并没有出现非典疫情，很快就好了，但那是第一次感受到了疫情的威力。对比以前的非典，这次官方处理、曝光信息还是很迅速的，除了武汉那边。我觉得这种时候，官方就应该发挥自己的控制力，把正确的信息输送给公众，让更多的人了解疫情，预防疫情，而不是打肿脸充胖子，说一切都会没事的。此外，国家应该加急制作、投放一些医疗防护设施，比如口罩。现在公布的情况还不算差，但是春运在即，这是每年人流量的最高峰，所以最具挑战的考验还没来到，年前回家，年后返程，大家再次回来的时，不知道情况会是如何，所以真真的考验可能在年后回来。鉴于此，目前有不少人已经开始改变自己的行程，其实回家主要就是团聚、看亲人，可以的话，其实不差这几天，可以等过了这阵，等年后五一等假期再去回家也不迟。</li>
  <li>心情不好！！！负能量一篇…😭出bug总是很让人难受，工作中兢兢业业不出问题，别人也不会说你的好，但是如果你出问题了，就会拿你说事，其实很多事情都是如此。所以干工作可以照此分几个不同的等级，从最好到最坏完成工作并超出预期（卓越）无差错的完成工作（靠谱）完成工作但偶有问题（一般）其实能保持中间的状态就很不容易，这样的人也是领导比较喜欢的。当然工作中的问题是多方面的，一个问题的后面一定不是简单的bug那么简单，开发流程，测试流程，产品上线如果要细究都是可以找到一些优化点的，不过大部分公司面对问题就是去解决问题本身，而很少思考问题背后更深层次的原因，或者去找一些更好的系统方法去拦截这些问题，作为个人你也无能为力，这种时候能做的就是想想自己以后怎么更好的避免或者减少这些问题。这是一个方法论的问题，很有意思，我过去几年在工作中遇到的让我印象深刻的问题，大部分都是小问题，小毛病，这些问题一些是测试人员测不出来的，一些可以很容易的测出来，但是忽略了，因为case太多了。我看多了国外的开源软件，他们有一点做的很好，就是自动化测试case代码，各种小细节都会有与之对应的case覆盖，尽管这些代码总会占据他们很大的代码量和工作量，但是他们对比却依旧坚持，国内的很多产品开发，更注重迭代速度，对各种case的代码覆盖测试几乎不怎么关心。我觉得前者更科学，后者可能更适合国情吧，我只能这么解释了。碎碎念于等媳妇下班的大厅…</li>
  <li>罗辑思维曾在2015、16年很火，看得人很多，我当时也看过一段时间，是自己同事安利的。罗胖的每一集中会讲一些自己学到的东西，很多是一些大故事、大道理，内容很庞杂，但是罗振宇讲故事的能力很强，很多故事被他讲出来就很耐听，就是那种谆谆教导的感觉，而且他的表述很口语化，很容易拉进于听众的距离。但是后来网络便有很多反对罗辑思维的声音，各种声音都有，贩卖焦虑、不懂装懂、知识包装等等…实际上任何节目只要是个人IP强绑定，就都容易被攻击，不说具体攻击原因，其实任何人或者团体红了后都容易收到各种攻击，这是必然的，也是这个社会的规律，大家总能找到一些批判的点，而靠讲道理、讲知识火起来的人或者节目貌似更容易被攻击。国内有罗辑思维，国外有TED。这个节目很多人应该也很熟悉，每一个视频18分钟，演讲者一般为各个领域的成功人士，演讲的内容一般都特别有吸引力，在网上很容易引起病毒式传播。TED的演讲一般要提前准备，还要做大量的提前演练，TED会确保演讲的质量，演讲完毕TED会把演讲视频精心制作，然后传到Youtube、Facebook等各个社交平台以便更好的传播。跟罗辑思维不一样，TED是非盈利性的，但即使如此，国外也有不少反对的声音，比如批判TED的精英主义（ted为邀请制，只邀请各个领域的大拿参加）等等…个人并不关系这些批判，倒是TED有一套成熟的演讲选择挺好，值得分享：Frameyourstoryasapersonaljourneyofdiscovery.Asuccessfultalkshouldfeellikea“littlemiracle,”changingyouraudience’sperspectiveontheworld.Ratherthantryingtocovereverything,focusononespecificissueandgiveexamplesofyourpersonalcontribution.把你的故事设计成一个个人的发现之旅。一个成功的演讲应该感觉像一个“小奇迹”，改变你的听众对世界的看法。与其试图涵盖一切，不如专注于一个具体的问题，并举例说明你的个人贡献Don’tuseateleprompter;instead,memorizeyourtalk.Putkeypointsonnotecardsifyou’reafraidofforgettingsomething.不要使用提词器，相反，记住你的讲话。如果你害怕忘记什么东西，把关键点放在记事卡上Makefrequenteyecontact.Pickfiveorsixfriendlylookingpeopleindifferentpartsoftheaudienceandlookatthemasyouspeak.经常眼神交流。在听众的不同部分挑选五六个看起来友好的人，在你说话的时候看着他们Don’tmovearoundtoomuch.Peopletendtoswayfromsidetosidewhenthey’renervousbutit’sdistracting.Yourbestbetistostandstillandusehandgestureswhenimpressingapoint.不要走动太多。人们在紧张时往往会左右摇摆，但这会分散他们的注意力。你最好的办法就是站着不动，在表明观点时使用手势Usevisualaidslikeslidesandvideossparinglyandonlytodemonstratehighlyvisualconceptsthatcannotbeeasilyexplained.有节制地使用幻灯片和视频这样的视觉辅助工具，只是为了演示那些难以解释的高度视觉化的概念</li>
  <li>今天看到一篇文章—巨型白鲟:新十年宣布灭绝的第一个物种“根据1981年至2003年期间210次目击到的白鲟，我们估计它们的灭绝时间是在2005年，不迟于2010年。”它是最大的淡水鱼之一，也是第三个灭绝的长江栖息物种，仅次于2006年的白暨豚和2015年的中国鲱鱼。白鲟也叫剑鱼，主要生活在长江流域，它是一个可以追溯到7500万年前的谱系的2个现存成员之一，它的灭绝是生物多样性的缺失。至于灭绝的原因则跟三峡大坝有直接的关系，因为白鲟属于是洄游类鱼类，所以它的繁衍需要逆流而上，到上游产卵才能进行正常的繁衍活动，但是三峡大坝阻断了它们，后来它们不得不放弃原来的地方，转而去寻找其他地方洄游，然后一切就变得糟糕起来了。三峡改变的不止是鱼，还有很多，也不好评论，总之，感觉还是糟点更多一些，去年看了贾樟柯的《三峡好人》，并没有看完，但是看到很多居民搬家的场景也是很感慨，人为造成了那么多的迁徙值得吗？人要迁徙，动物也要迁徙，有些甚至面临了灭族，真的值得吗？人与自然昨晚在腾讯视频看一集《七个星球》的纪录片，这是一部很不错的纪录片，貌似还获得了去年的奥斯卡奖项。我很喜欢看动物类的纪录片，从小就如此，那时我记得每周只播一次《人与自然》，好像是周一深夜才播，那时主要是因为老爹比较喜欢看，每次他都熬夜看，受此影响，我后来便越来越喜欢看这类动物类的纪录片。尤其配上赵忠祥老师富有磁性的声音，总觉得看《人与自然》是一种享受。时间真快，昨天赵老师已经去世了，借此缅怀一下…分享心理学上有这么一句话：人的后半生所追逐的，都是在希望补全童年的缺失。小镇青年，李诞是这样；艺术二代，池子亦是这样。池子有王冠，李诞有钱by东半球第二正经の</li>
  <li>今天公司举办年会，跟之前两年的年会不一样，今年的年会很利索，看节目、颁奖、抽奖，然后各回各家。其实大部分人开年会就一个目的，抽奖，所以不用搞那么多的节目，还是速战速决抽奖来的好，而且相比前两年的节目，今年的节目内容比较正，没有那种很俗气很油腻的节目。今年的特等奖是5个五万5个十万，而且是抽工号，估计是因为去年抽现场座位，一些人因为没去现场而错失奖项后，不少人觉得这不公平，所以曹总今年改抽工号，来不来现场无所谓。也因为去年抽现场的原因，今年大部分人都来现场了，今天下午出发前，我还在工位犹豫要不要去现场，从结果来看，真应该在公司撸代码才是良策。不过今天运气不错，被1%的概率砸到了，中了一个五等奖，一台kindle，之前还考虑过买一台，不过目前我觉得微信读书挺好的，这个kindle到手后再看看吧~另外今天年会有一个细节还挺温馨的，公司给曹总制作了一个20年回顾的视频短片，里面记录了曹总过去的一些回忆记录，曹总本人看着应该很有感触。其实很多人不知道，新浪的创始人并不是曹国伟曹总，而是王志东，新浪的前身叫四通利方，1993年成立，后来到98年与华渊资讯这个公司合并才有了新浪，而曹国伟是1999年入职，后来公司经过一系列的变动，曹总成了新浪的掌舵者，这里面有很多故事，我之前也是简单了解了一下，但是无论如何，能让一个企业存活20年还是了不起的成就。over~</li>
  <li>天气不错，今天中午去打球，一个人去后球场就我一人，然后热身投篮，不一会儿，来人了，三个男生两个女生，因为球场另一边有雪，所以大家就只能在没雪的这边玩。那三个男生我以前跟他们打过几次，很面熟，但是两个女生就没见过，不过她俩也会一点篮球，其中一个身高高点，投篮还挺好。后来又投了一会，来了一群网易的同学，那边五个人，很巧，也有一个女生。不一会儿他们便提议打5v5，网易那边打我们这边，整好两边各一个女生，很公平，这边的另一个女生不怎么会，就在旁边看着。跟我一队的三个男生，比较灵活，但身体一般，那边水平普遍比我们高，当然这都不重要，因为两边有女生，所以我们打的比较松。开打后两边进攻都不错，而我发现跟我一组的女生篮球意识竟然挺好，尤其是空切意识，当我持球时，看到她有空切的机会，会毫不犹豫的传给她，尽管我都是用比较快的速度的球，但她都能接住了，只不过篮下一般都是男生，或者距离太远，所以很少进球，不过她能有很好的空切意识还是很让我惊讶。有一个回合，我在外线，她在篮下不远的位置，而且篮下周周没人，发现这个机会后，我顺势把球吊篮下，她成功空切，拿到球，进球近在咫尺，大家都在为这次配合暗自喝彩时，重点来了！对面的大哥们却“非常及时的”补防上去了，球被成功干扰掉。一下子，嘘声四起，包括网易那边的队友们，开始对哥们冷嘲热讽，这还不算完，人群中突然听到一句话：“你是不是没有女朋友？？”貌似哥们确实没女朋友，我看着这哥们，表情顿时就石化了…他队友那边很快传来了“真相了”“暴击”之类的字眼…当事女生随即说，“打球就打球，还搞起了人身攻击，没关系…”说话的男生意识到他貌似真的没女朋友，然后赶紧趴地上做了两个俯卧撑以示友好…于是大家继续愉快的打球…微信为订阅号支持付费阅读今天上线的新功能，微信只要上线新功能，整个互联网都会讨论，这个功能，最大的赢家可能还是苹果，😂。不过如果微信引导的好，日后确实可以促进公众号内容生产者生产更优质的内容，而减少博主投放广告的比例，不过这样用户买单的方式就从看广告就成了真金白银，孰好孰坏，只能交给时间了。</li>
  <li>下面最近听《人性的弱点》一书时的一些笔记思考。听书让人安静如何面对批评当一个人能力越大，影响力越大，就越容易被别人批评，因为对一些人来说，批评比自己更厉害的人容易让自己感觉良好，他们也因此愈发的喜欢去批评别人。对于批评有两种，一种是不公正的批评，就如上面所说的，为了批评而批评，批评别人只是为了满足自己虚无的优越感，用当前的眼光看，他们就是网络喷子哪一类，出口便是人生攻击，并习以为常。另一种是建设性的批评。他在批评你的时候充分发现了你的不足，并给予指出，这样的批评对自己的成长很有帮助。事实上，不论那种批评，人都不喜欢被批评，这是人性使然，大家都喜欢好听的话，但是千篇一律的赞美不能让你成长，所以要想让自己变得更加出色，就要乐于去寻找、接受那些建设性的批评。此外在别人批评自己之前还应该经常性的自我批评，“吾日三省吾身”，这样会不断矫正自己的行为，同时也使得自己更坦然的面对别人的批评。那如何面对那些不公正的批评，我们应该“一笑了之”，不要浪费任何感情、精力，不要与他们纠缠，不要进行任何回复，也不要期望通过辩论可以说服他。就如以前经常听到的一句话，如果狗咬了一口，你还要回去咬它一口吗，一旦你真的那样做了，在咬人这个专业领域，你明显不是狗的对手，总之，不要搭理，不要理睬，尽快离开就是。所以面对批评，我们首先要做的就是分辨这是哪一种批评，不同的批评采取不一样的处理方式。建设性的批评接受它，还要感谢别人对你的批评，尤其要仔细聆听敌人对你的评价，而那些不公正的批评，评价，就由它去，一笑了之。而且很多事，你做也该死，不做也该死，那就尽自己最大的努力去做自己认为对的事。几点感悟要嘴下留人，不经大脑的批评有时随口而出，但对别人的影响却非常深远。大学时有一次我看到舍友在玩扫雷，我站在他后面随口说了一句“能不能玩点有品位的”，就因为这句话，后来他便很少玩了，尽管当时他表现的很释然，但对他还是造成了影响，后来跟他道歉解释，让他别太在意，但还是有点晚了。阮一峰面对批评做的很好，他常年在互联网写教程，写书，经常收到批评，几乎很少看到他回应。而对待错误及时改正，面对谩骂从不回应，他真是很好的榜样。</li>
  <li>一个木函昨天在逛酷安的时候注意到了一个软件—一个木函，这是一个android工具应用，它里面包含了特别多的常用功能，主页如下所示：可以看到它提供了非常多的功能，看到它我就想到了PC时代的hao123，如果你想找一些工具软件，不用去软件市场，直接在它里面搜就可以了，当然hao123后来曾一度成为互联网的入口，一个木函小而美，它主要是为那些不愿意装各种工具app的用户提供另一个选择。我昨天注意到它主要是因为它71个功能里面有一个功能跟我做的咕咚云图功能是相似的，就是图片转链接，这个功能可以让用户选一个本地的图片，然后快捷的传到云端，它的功能很简单，很轻量，我的因为是一个独立的app，所以功能做的比较细致。但它用的图床很有意思，搜狗图床，支持cdn加速，上传速度也超快，昨晚抓了包，很快就把咕咚云图的默认图床也改为了搜狗图床，体验很不错，还有一点，搜狗图床的图片对微信公众号支持很好，我试了下，markdown格式的文章中如果使用了搜狗图床的图片，公众号的编辑器会把图片轻松的加载出来，这比github图床要好。所以咕咚云图的下一版本会马上使用搜狗的图床。玲琅满目的写作软件另外我发现市场里有一类软件很特别，写作软件，总是有很多公司，个人愿意开发，光我们知道的就有很多，比如印象笔记、有道云笔记、OneNote、WPS便签等等，还有每个手机厂商出厂时都会给手机内置一个笔记软件，很多时候都叫它便签，这里面不乏一些很出众的软件，比如锤子手机的锤子便签，还有魅族自带的，都不错，而且他们大都支持云同步，而我最喜欢的是mac自带的便签，那是我最喜欢的系统便签，功能强大，界面简单，操作起来很舒服，这是我用过最舒服的便签，但是无奈他它不支持手机，只能在mac上使用，很遗憾。除了这些公司做的，个人开发者也特别钟爱开发笔记软件，比如一本日记、simpleNote、Typora、纯纯写作等等，其实还可以列举很多，不过这几个是自己用过的。有时回想，为什么写作软件这么多，原因有很多，我觉得有一个原因就是写作这个需求的可能性太多，可以拆分出来的需求场景太多了，所以不同的开发者都会发现一些独有的场景，然后便诞生了形形色色的笔记app。而且很多开发者平时都有写作的习惯，这样他们就更容易找到一些需求点，一旦发现别的写作app不好自己就有动力去写一个。比如我，尽管我觉得纯纯写作很好，我用它写daily，但用着还是有不满意的地方，比如它大量的长按交互、过多的dialog交互、markdown预览不方便等等，偶尔也有冲动自己写个简单的markdown写作编辑器，不过终归时间有限，不划算。打球下午去附近的室内球场打球，打的很舒服。这半年大都是跟认识的人打球，很久没跟不认识的人打球了，我在高中、大学时都喜欢跟不认识的人打球，主要可能是我比较友好吧，跟不认识的人打球也不会产生什么冲突，再加上球技还不错😊，乐于传球，所以跟一些陌生人打球反而可以认识一些不错的朋友…只是最近打球有点腰疼…悲剧(╥ω╥`)</li>
  <li>对于同一个文章主题，如果分不同的时间去写，可能会写出完全不一样的文章。昨天的那篇文章其实写了三篇，发出来的是最后一篇。关于那个主题，是洗澡时想到的，后来写了一半，当做草稿，但是再次写时，觉得之前的草稿完全没用，而且先入为主，感觉有很多限制，索性根据自己的理解再写一篇，昨晚继续编辑的时候，发现还是不够直白，最终又写了一遍。一些主题还是需要时间去理解和消化，当然也可能是自己跟自己太较真了。关于昨天成功与喜好的一些思考源于前段时间看到的一篇文章，这里贴一下，希望对你有启发一个讨论了很久的问题，我有答案了周末愉快…</li>
  <li>我那天看到别人的一篇文章后，想到了这个问题。对于成功人士，我们看到他的时候，他已经成功了，这时看他达到的成就，以及经历的挫折，会很容易的觉得他们的成功有多么不易。比如周杰伦，他上学成绩很差，连高中也没考上，还有一段时间给饭店打工，很落魄。即使后来到吴宗宪的工作室，他的性格内向，口齿不清，一开始并不受大家喜欢，直到后来，因为自身的天赋＋运气+实力最终登顶人生顶峰。或者马云，一开始做黄页，做网站都不顺利，连应聘肯德基都被淘汰，最终经历了很多，取得了成功。如此看来他们的成功都可以用艰难来形容。但实际上，如果问这些成功人士，他们怎么看自己的成功之路，他们大都会说的轻描淡写，因为这个过程确实不是别人想的那么艰难。相反，他们在成功的过程中应该一直享受着快乐，即使在真正的成功前，他们一定是找到了自己最喜欢的事，否则，如果他一直在做那些让自己感受不到乐趣的事，即使可以坚持的了一段时间，也坚持不到终点。所以他们的成功有一个很关键的原因，他们找到了自己真正喜欢做的事，就如乔布斯说的followyourheart，翻译过来就是要找到自己内心深处最喜欢做的事。当一个人在做一件自己喜欢的事，便很容易自我驱动，这种驱动力之下他的生产力、能量都是不可估量的。其实很多人，或多或少在自己的成长过程中，都会有这样的一段经历。当在这种状态下，只会觉得时间太少不够用，生怕流逝掉一分一秒。雷军以前被称作中关村劳模就可能是这样的原因，去年马云发表过一个关于996的观点：能做996是一种巨大的福气，很多公司、很多人想996都没有机会。其实作为员工，如果能在顶尖公司做自己最喜欢的事，公司还能给你提供优越的办公环境，丰厚的薪资报酬，那这确实一种福气。当然，并不是只要找到自己内心最喜欢的事，就可以成功，成功的因素很多，成功人士的成功离不开他们所处的大环境。可能他们全身心投入的那件事那个环境下正好处在初级阶段，这样的条件下，他们的成功便会变得更加容易，试想，如果周杰伦晚出道十年，那么还能达到现在的高度吗，很难。所以鉴于此，有人会信命，就可以理解了，因为一些事能不能成，可能就在毫厘之间，有时候你再努力，因为不在一个正确的时机，所以就可能成徒劳。成功的模式有很多种，简单总结一下这种模式就是：找到自己最喜欢的事，自发的、全身心的、不知疲倦的投入，然后一不小心，恰巧因为老天的眷顾就成功了。而很多过往的历史告诉我们，当全身心投入自己喜欢的事时，貌似被老天眷顾的可能性也越大。当然在这么多人的基数下，能成功还是少数，但不论如何，对于我们，这也有相当的借鉴意义：那就是不论何时，如果要发挥自己的最大潜能，就一定要去寻找自己最喜欢做的事。哪怕最后成不了，但这个过程中，一直都在做自己真正喜欢的事，这何尝不也是一种成功。</li>
  <li>Daily是自己的一个专栏，每天一篇文章，每篇都会有一个主题，但今天不小心写的文章有点长，感觉一时半刻整理不完，决定明天再发。另外关注咕咚云图的朋友们有一个好消息，还不知道咕咚云图的同学可以看这里，咕咚云图马上支持github作为图床，并默认支持CDN加速（使用jsDelivr）。自己使用了一天，效果良好，加载速度不错，只不过配置github图床时需要去github网站生成一个token，稍显麻烦。这篇daily中的两张图片就是刚刚用咕咚云图上传到github图床的，大家可以体验一下加载速度如何。同时新版本还加入了解析url链接为带title的markdown链接功能，比如输入链接https://www.baidu.com，就会自动解析为百度一下，你就知道这样的Markdown格式链接，这对于手机上有时插链接很有用。另外，下一版本，咕咚云图将改名为咕咚markdown助手。咕咚云图介绍详见：咕咚云图：Android手机端的图床利器</li>
  <li>从2015年知道了个人博客，后来自己搭建了自己的博客，然后开始在上面写文章，主要都是技术文章，开始定位也是技术博客。刚搭建好的一段时间内，很有写博客的欲望，就连续写了不少，但是质量很一般，所以很快困惑就出现了。困惑一：博客上要不要写一些非技术的文章。其实这是一个博客的定位问题，如果你把博客定位一个纯粹的技术博客，那就只写技术文章。而一开始自己并没有想过定位问题，只是看到一些写的不错的技术博客后才开始思考，后来想还是不定位为技术博客，而是定位为自己的个人记录博客。困惑二：要不要把写的很初级的文章放上来。尤其是看其他博客的时候，有时看到一些博主，写文章写的很好，然后看再看自己的，觉得写的好low，相形见绌，所以有时写技术文章时，写到一半就不想写了。其实这两个问题现在看来，都很容易想通。做自己的博客，用博客记录真实的自己，不用攀比其他人。怎样舒服怎样写，不要太在意别人的眼光。</li>
  <li>本来应该前几天写的，但是一直没有抽出时间，因为年终总结不像每天的日记，即使碎片的时间也可以写完，我一直在找一个安静的时间去写，但是从1号一直拖到今天，已经是5号了。昨晚想写，但是有点累，加上周五晚上喝酒，脑袋一直发晕，是不是还头疼，所以昨晚就早点睡了，今天下午也是在床上睡了一个小时，只为今晚能够留出精力时间，可以安心把年终总结写完了。2020有一点特殊，我记得在14、15年的时候，有时会畅想2020会怎样，觉得这是好遥远一个年份，但不知不觉现在已经是2020年的1月5号晚上了，时间太快了。工作年初还在Feed，今年做过两个比较大的需求微博首页Tab结构重构微博正文页结构重构这两个算是自己入职微博后做的比较成功，比较有价值的两个需求。前者是为了解决产品要对首页tab排序进行AB测试的问题，而之前的排序是固定的，所以重构的主要目的是动态化，可配置顺序。后者是因为微博转评赞在不同的业务场景都有使用，但是代码不可移植，所以进行重构设计，让其设计为可扩展结构，方便视频接入。第二个做完后，本可以继续优化，但是当时人员变动，我去了另一个业务部门，后续后续并没有什么接下来的优化。后来负责了发布器，一直到现在，不过一直在做需求，今年做了发布器投票、抽奖（小程序）、18图、自动存草稿等等，有时做需求的时候会排斥，很枯燥。孩子今年三月份，调研了附近的幼儿园，最终选了一家私立幼儿园，整体环境不错，价格也可以接受，感觉是比较合适的一家。今年一年他的变化很大，这也是学前教育的好处，让他更早的去进行团体生活，今年他的语言、思维能力都有特别显著的变化，记录每个月都有新变化。我在3月份开始写月总结，每月写到他，总能发现不一样的地方，这一年对他而言，真是进步巨大的一年。他也给我们带给了非常多的欢乐。他现在喜欢上了堆积木，实际上积木是今年初卖给他的，一开始他并不喜欢，他只知道把积木往高里堆，但是慢慢地，到上个月他开始去创造一些东西，比如船、航空母舰等等。对于孩子的教育，家长很重要，但是作为爸爸，很多时候也很无奈，自己也会不知道如何去引导他，我只能尽力的去多鼓励他，但是不能确保所有的教育方式都是对的。不过我会不断看书学习，跟他一起成长。个人成长在技术上，技术人永远都不能停下脚步，我在年初跟同事一起学习了一段时间的Flutter，打算用它做一个微博客户端，但是最后坚持了两周左右，还是失败了。感觉还是驱动力不够，但是Flutter的理念确实很超前，目前看来它是最好的大前端解决方案，2020年要继续深入去学习，而且客户端也有接入Flutter的意向。在追逐新技术的同时，技术的根本也很重要。对于技术人员，数据结构和算法都是基础，自己这方面一直比较薄弱，今年买了极客时间的课程，但还是觉得学习方式不对，一直难以找到学习数据的正确姿势。后来的感悟是，要不断做题，然后在结合理论知识可能更好。尤其是做题，写代码的过程，会让自己对数据结构、算法有更具体的认识，2020要养成刷题的习惯。健康从2019左右，身体有了一些不好的信号。胃不好，这是一个老问题，对于自己，要做的就是少吃，忌油腻，忌辛辣，饭后健步。最近几个月已经好多了，我觉得跟我中午的健步习惯有关系。左脚跟腱连接部位疼，12月初还去积水潭医院新街口园区检查了下，然后去了一家康复中心做了冲击波，当时做的时候挺痛的，但是后来效果一般，还是平时打球注意才是，不要疲劳打球。今年鼻子被打，做手术。人生的第一次手术经历献给了篮球，这次手术经历让我收获还是挺多的保护自己，爱惜自己凡事把握好度，适可而止相信科学旅游去了越南芽庄，这是一次很不错的旅行，具体见我的游记2019芽庄之旅|咕咚好习惯今年，尤其是在下半年养成了几个不错的习惯，感觉收获颇多。听书我从10月份左右听书，直到11月份，才真真喜欢上了听书，喜欢上听书的另一个原因是《代码之外的生存指南》这本书本身。每天一节，他讲的内容也正是自己喜欢的东西，所以每天听书变成了一个很享受的事，每天听书就像在汲取能量一样，如果那天没听，会觉得缺点什么东西。有时晚上到家9点多了，吃过饭，我还是要去小区，一个人绕着小区听一章。在听这本书的时候，还建立的另一个习—做读书笔记。每听一章，我都会停下来，写一点思考到我的手机软件，强迫自己输出，强迫自己的思考，这样慢慢的思考的习惯就养成了，同时养成了写字的习惯。从这个习惯的建立，让我明白了一个道理，对于任何一个习惯，最理想的状态，就是把这个习惯变成一个兴趣。健步每天中午公司午饭后，我都会去绕着大厦听书，边走边听，这真是一个两全其美的方案，既可以减轻胃的压力，同时还可以听书、思考，健步完后，1点多，回去再睡一觉，2点开始上班，这是一个非常好的节奏。但是实际执行时，有时并没有很好的执行，尤其是睡觉，2020继续努力。Daily这个习惯很大程度上归功于听书这个习惯，11月份，正在听书，里面讲了写博客、持续输出、以及效率提升方面的内容，我对他的内容很感兴趣，后来试了番茄工作法，觉得非常好，加上我一直有个想法，就是每天可以输出一小段话到公众号，我喜欢短点的文章，所以这个想法很久了，那段时间，突然就觉得要写了。从11月14号开始，一写写到现在，已经快要来两个月了，我想第一个周期定为100天。现在想想接下来还是要继续优化一些Daily的写作方式，同时再次明确以下写作目的：目的：锻炼写字的感觉使用自己的工具，打造个人写作flow（咕咚Markdown助手）记录思想，分享价值，形成写作体系写作方式格式简单能不插图就不插，通过公众号助手发布固定周期发布干货文章结合时事热点寻找那种内心平和的写作方式，不激动，平常心看书今年我看的书并不多，但是贵在慢慢找到了读书的感觉，发现了听书这个好习惯。2020继续保持那几个好的习惯，不断优化，不断思考更好的方式。在好习惯基础上发展新的习惯，刷题运营维护、发布自己的付费工具APP，让它更好的服务更多的写作爱好者。学习Flutter，结合到工作中继续看书，做笔记，更好的输入更好的输出。</li>
  <li>今天下雪了，雪很大，跟往年不一样，今年北京的雪格外的多。这次下雪时没风，所以树上都是学挂，很漂亮。大家都很喜欢雪，我觉得跟雪的颜色有很大关系，还有雪的形态，但同样是水气的产物，雨就不受大家的待见。下雨总有阴沉沉的感觉，古诗里也是，提到雨，很多就是离别的场景，如雨铃霖中的“念去去，千里烟波，暮霭沉沉楚天阔”或者“山雨欲来风满楼”。而提到雪，大多都是正能量，“千里冰封，万里雪飘”“忽如一夜春风来，千树万树梨花开”，等等。我很喜欢公司大厦内那个牛的雕塑。为什么喜欢牛，主要是跟我童年有关系，小学、初中每年暑假都去山里放牛，牛带给了我很多美好的回忆。与此同时，牛的性格也是我特别喜欢的。牛很低调，还很踏实，没有华丽的外表，但是沉稳有力量。关于牛，我特别喜欢在冬天看它反刍的样子。每到冬天，也是自己寒假的时候，牛从早晨要从牛圈里赶出去，让它们去外面的湖摊里吃草喝水，下午它们回来会趴在牛圈外，不停的嚼动着嘴巴进行反刍，看着让人特别舒服。就像于谦于大爷在十三邀里说的，他能看牛反刍看一个下午。</li>
  <li>这里记录自己读过的书。关于读书，其实自己一直有很多话想说。从小没能养成一个好的读书习惯，到后来，尤其是工作之后，发现读书真的是一件特别有意义的事。现在我正在把以前漏掉的掉下的书读起来，灵魂和脚本总要有一个在路上。这里面会有不少技术相关的书籍，每一本书自己会简单写几句点评。其实读完每一本书写一篇读书笔记也是未尝不可的，而且会是一个非常好的读书习惯。2020《人类简史》2020/10/23读完书中从人类进化的开始讲起，聊到了农业革命、工业革命，一直到现在，最后展望未来，书中有很多有意思的观点。共同想象《天生有罪》今年疫情期间知道了崔娃，后来又通过一篇公众号文章得知了这本崔娃的自传，当时推荐这本书时，作者主要说提到了关于语言的一些观点。自己真的开始看这本书，到今天（2020/10/21）看完，给自己最大的感触是她的妈妈。这是一个强大的妈妈。她有强大的内心，而且难能可贵的是，她的思想也非常独立，直到全书读完，我还是始终没找到她妈妈这种独特性格是如何养成的。她的妈妈思想很独立。他想给那个瑞士人生一个小孩，这个小孩就是崔娃，从一开始这就是个错误，所以从一开始她就打算独自带孩子想法，不依靠爸爸。她妈妈跟幽默，很聪明。从很多细节可以看到，她妈妈心思很缜密，可能也真是这一点，练就了崔娃的三寸不烂之舌。不过全书没提到他自己如何一步步成为主持人的，应该是他有意隐藏，不过最终读完，感觉这个也不重要，全书其实就是在写妈妈，一个强大的妈妈。书的结尾妈妈中弹了，而且是被自己的丈夫开枪的。她妈妈这种强悍的性格，我甚至觉得不应该找亚伯这种人，两者的搭配就是错的，她妈妈跟亚伯的关系太难理解了，也许就是这样，并不是所有的事都可以解释。一本好书，关于儿子跟妈妈的书，强悍的妈妈，开朗的儿子。2019《代码之外的生成指南》构建自己的被动收入来源，提前退休，不一定要等到退休年龄才去退休番茄工作法，日拱一卒不要把钱看太重Todo:读书笔记必须补上《鱼翅与花椒》喜欢上了川菜买了两瓶豆瓣酱吃到现在（2019/01/06）去甘肃的故事姑娘很性情，译者翻译的很好《斯坦福极简经济学》经济学入门2018《拳王泰森自传：永不后退》真实的泰森强大跟脆弱就在一线之间人生导师-库斯，幸运也不幸高阳版《胡雪岩全传》1做事滴水不漏2017《第四野战军》从北打到南，第四野战军的经历就是整个解放战争的缩影。祖国大地上那些炮火岁月兵荒马乱，乱世出英雄《把时间当做朋友》我们可以用自己的大脑控制大脑玩自己的大脑2014《影响力》如何让别人不拒绝你的请求。《打造Facebook》书中讲了Facebook的招聘理念，以及自己带团队的经验，还有Facebook整个公司的一些文化。在读书的过程中，对比自己所在的公司，感觉与Facebook这种大公司的管理相比，自己公司的管理水平不忍直视。但是也从中学到不少管理相关的东西。作者最后离职Facebook回国做天使投资，其中一节让自己对天使投资也有了一些认识。真的是一本非常好的书。真实的Facebook新人训练营黑客松《从0到1》这本书是自己刚工作后，第一个老板就推荐的，从0到1也是老板经常说的一句话。书中有很多跟创业相关的内容，我本应该在读完书后就应该动笔写点读书感悟的。</li>
  <li>很长一段时间，我都认为生病就是身体的机能出了问题，是纯粹的身体问题，只要坚持锻炼身体，保持好的作息饮食规律，疾病就会远离我们。后来慢慢了解到，人的人体很复杂，实际上疾病的成因并不是那么简单，引起疾病不仅有身体本身的原因，还有一个很重要的因素：心理状态。当一个人的心理处在一个糟糕的状态，比如整天忧心忡忡，处于忧虑当中，久而久之身体就会出现很多疾病，也就是说这种不健康的心理状态可以激发那些潜在的疾病。下面是一个因为忧虑致病的故事：所以一个积极健康的心理状态对人的身体健康真的至关重要。如果仔细观察周边那些长命的长者，可以发现他们大都有一个共同点—积极乐观。面对任何事情总是采用乐观的态度，好像永远看不到他们发愁的样子，这也印证了一句话：生活就像一面镜子，你对它笑，它就对你笑，你对它哭，它就对你哭。最近在看《人性的弱点》这本书，这里分享书中一个解决忧虑的方法：1.忘却忧虑和恐惧，列出最坏打算。2.认可最坏打算的结果。3.列出现存问题及可能的解决办法，并行动。分享前天在微博看到快手在央视新闻联播后投放的一个两分钟广告，《真正热爱生活的人，不会被生活打败。》跟今天的主题比较搭配，具体可点击查看。</li>
  <li>前几天B站2020跨年晚会上了热搜，但没有仔细看，所以今天特意在手机上看了一会。晚会分为三个章节，还是挺长的，我只看了少两章节，不得不说第一章太惊艳了。一开始的那个舞台创意特别好，一哥们独自一人，走到电脑桌旁边，打开电脑，戴上耳机，然后一个舞台穿越特效，现实世界转换为游戏世界。接下来的舞台上都是魔兽世界里的角色，我不玩魔兽世界，那些怪兽我都不认识，但是舞台效果真好，那些怪兽跟着节奏跳舞，他们的服装很真实，我尤其喜欢那五个熊猫人的表演，背景音乐很好听，中国人+游戏，很棒。前奏结束后，上来了主持人，一看，上来的男主持人居然是央视主持—朱广权。我在想bilibili这样一个二次元视频动漫网站，为什么要请一个央视主播这样严肃的主持人呢，后来在b站里搜索了朱广权，他人气真不差，而且朱广权真的很有意思。他是我印象中第一个打破央视主播那种严肃风格的主持人，时不时来段rap，很有意思。另外B站的这次晚会还请了不少大咖，我比较喜欢GAI的那首华夏，真好听，喜欢这种中国风的rap。还有这次他们请到的交响乐团，很给力。B站晚会的音乐总监赵兆是北京奥运会开幕式和闭幕式的音乐团队的核心成员，在场的还有靳海音弦乐团（《歌手》御用班底）、新九州爱乐乐团，可谓顶级配置。除了大咖，里面还有很多的B站up主登台表演，感觉很接地气。还有一些国外的音乐人，尤其对那个大提琴师印象深刻，演奏很好听，很有激情。看下来，对晚会感觉还挺复杂的。水准挺高的，不论舞台效果，明星，还是交响乐图，不过主持人的数量相比春晚或者其他节目貌似有点少，但贵在合适。还有一个感觉就是路子有点野，尤其是习惯了春晚那样的演出。不过也确实符合Bilibili的风格。其他可说的地方其实还有不少，但面面俱到也是不现实的，不同人感兴趣的地方可能不一样，还是自己看一遍更好。总之这是一次非常不错的晚会，这是Bilibili成立十年第一次举办跨年晚会，不仅如此，仅仅因为一个成功的晚会，Bilibili的股价也蹭蹭的往上涨，可见这个晚会的影响力。</li>
  <li>工作后，每年年终领导都会跟大家吃一次饭，吃饭貌似一个一个约定俗成的规矩，但是相比大学时的喝酒频率，工作后喝酒确实少多了。在喝酒的场合，谁能喝酒貌似一种可以炫耀的资本，但酒量这个事真的是天赋，不能强求。我一开始喝酒应该是高中，那时老爹比较喜欢喝酒，但自己一开始并不喜欢喝酒，不喜欢酒的味道，直到后来到了大学，不知不觉便开始喝酒了。大一时喝酒很多，每次室友过生日，大家都要吃一次饭，当时在内蒙上学，那边吃饭是一定要喝酒的。在老家，喝酒都是要猜拳，但我一直没学会，后来到了大学，发现那边并不猜拳，而是换了一种方式—劝酒。猜拳靠实力，劝酒靠嘴巴。大一时两个舍友一个湖南、一个东北，劝酒真是厉害极了，他俩不怎么喝，但是就是能说，他们吃饭的乐趣就是劝酒。但那时真的开兴，六个人做一桌，喝酒吃饭吃蛋糕，总觉得未来都在脚下。尽管大学喝酒比较多，寒假回家跟哥哥们也喝酒，但是很少喝醉，唯一一次喝醉还是大四毕业时。当时从北京回学校毕业，有一天跟大学球友喝酒，打球的朋友都特别能喝，尽管自己也挺能喝，但是跟我那些内蒙的朋友还是差了不少，那天第一次喝醉，喝的不省人事，晚上怎么睡觉的都不知道，第二天还去找丢失的手机。工作后就很少有这种喝酒的机会了。为什么人会喜欢喝酒，这件事我一开始想不通，直到后来自己也喝酒了便开始慢慢明白了。喝酒是一种让大脑进入另一个自己的有效方法。当喝酒喝到头脑发晕，大脑会进入另一种状态，在酒精的作用下，自己会发现另一个自己，这个自己在酒精的作用下往往是内心中那个最真实的自己，所以借着酒精自己找到了内心中的自己，逃脱现实，在酒精中找到自己，这也许就是一些人为什么喜欢喝酒的原因。不过总归人还是现实中生活，适量的喝酒是一种放松，过量就可能是一种对自己身体的一种伤害了，劲酒虽好，可不要贪多…</li>
  <li>很惨，今天中午打球被同事冒了两次。两次都是自己在低位单打时发生的，我选择的出手都是最擅长的勾手，一般很难被盖到，但今天被连续盖了两次，就像是复制粘贴一般，冒得我没脾气。不过回来的路上想了想，两次大概都是因为他对我的防守策略成功了。我喜欢在篮下持球单打，一般我都会用身体优势倚着防守人，不断用力量强打对方，即使别人不靠着我，我也会主动运球靠上去，这是自己很喜欢的进攻方式，直到自己移动到篮下比较合适的位置，用勾手完成终结投篮。但是今天两次，他都选择了相反的方式，没有给我直接的身体接触，两次都是站在我旁边，只是伸出双手，故意给我留空间，然后我在继续单打的时候就很难通过身体感受到他的位置，而他有了更多的移动空间，加上他比我灵活，身高也不吃亏，所以他能更容易的观测到我的出手，并完成封盖。这就是我想到他成功防守我的原因。两次都不是那种遮天大帽，但都成功的阻断了我的投篮。其实两次进攻的时候，当他不主动靠我，而我用身体找不到对抗的感觉时，心里就开始没底了，投篮时更是如此。当你心里没底的时候，问题就发生了。其实生活工作中的问题也是如此，很多事如果心里没底，就贸然行动，那么交学费的可能性就很大。相反，你对这件事做足够的功课，把事情想明白了，不留那种不确定性，做成的概率也就大。之前领导就说，作为技术人员给其他部门人员提供信息时，信息一定是准确的，不要给别人提供模棱两可，似是而非的信息。因为模棱两可的信息容易出问题，就像打球时，当你对防守人不能定位时，你就不知道他会在哪个地方等着你，然后不经意就能给你一冒。所以，如果下次打球，他还采取同样的防守策略，我会换一种方式：持球面框(面对篮筐)打他。😉</li>
  <li>今天突然想起了上周过圣诞节时一个很有意思的事。儿子去年圣诞节时三岁，那时我本打算给他准备圣诞礼物，但是去年还是有点小，第二天即使收到了礼物，但是也无动于衷，因为他完全不知道圣诞老人是怎么回事。19年初他开始上幼儿园，到现在已经上了一年，上学后，他的变化很大，不论思维，语言，交谈都是肉眼可见的进步。加上动画片里的教育，他早就知道了圣诞老人是怎么回事，还有驯鹿、雪橇等。今年平安夜前，他说要给圣诞老人准备一个袜子，晚上我也哄他，让他早点睡，这样圣诞老人在窗外看到他睡了，才会给他塞礼物，那天晚上他睡的格外早。然后晚上跟媳妇给他准备了两袜子的圣诞礼物，主要就是一些糖果，飞机之类的。第二天早晨，他醒的果真比往常要早，醒来后特别开兴的叫我：“爸爸，圣诞老人真的来过来了，看我的袜子，他给我送了礼物，好开心…”说话的时候，他脸上的笑容充满了童真，是那种完全开怀的笑，完全把圣诞老人当做一个真实存在的人物。看到他开兴的样子，会觉得对孩子，开兴真是一件特别容易的事，而且从他的笑容也会感染自己。关于孩子，现在有人排斥生，或者晚生，在当下养孩子难的环境下，可以听到很多不生孩子或者晚生孩子的论调，但是只要有了孩子的人，很少听到抱怨自己有孩子不好。这主要也是因为孩子能带给自己不一样的生活体验，孩子能带来的快乐很事业、游戏的快乐也完全不一样，尤其是你看着他慢慢长大，一点点的变化，看着他开心的笑，委屈的哭，这些都是一种别样的体验。不过终归对于一般的家庭，当下环境，孩子确实需要比以往更多的物质支持，还有教育问题，以及当下城市化变迁带来的漂二代问题，孩子带来快乐的同时，父母、家庭也同样面临着很多让步，所以关于要不要孩子，什么时候要孩子，大家都在寻找一种平衡，自己的选择基于自己所处的环境，没有一概而论的答案。</li>
  <li>这月工资发下来后，发现多了几千，心想这还没到一月呢，如果是一月，扣税是最少的，所以到手工资多正常，但是这是十二月的，现在也没什么奖金，所以还很纳闷。昨晚想了想，是不是之前报个税专项附加扣除报的，媳妇之前提醒让我报个税，直到上月才用个税app报了。我报了两项，一项是房租，一项是子女教育，今天在内网查了工资单，果真是因为个税的原因。上月还有小几千的个税，这月个税扣除为0，所以多的部分就是以前个税扣掉的部分。今天再次查了个税专项附加扣除的具体标准，房租在北京，每个人每月可以报1500，子女教育可以报1000。具体说明如下参考《个人所得税专项附加扣除暂行办法》第二章到第七章内容：第二章　子女教育第五条　纳税人的子女接受全日制学历教育的相关支出，按照每个子女每月1000元的标准定额扣除。第六章　住房租金第十七条　纳税人在主要工作城市没有自有住房而发生的住房租金支出，可以按照以下标准定额扣除：（一）直辖市、省会（首府）城市、计划单列市以及国务院确定的其他城市，扣除标准为每月1500元；（二）除第一项所列城市以外，市辖区户籍人口超过100万的城市，扣除标准为每月1100元；市辖区户籍人口不超过100万的城市，扣除标准为每月800元。不过两个加起来一共2500，实际上以往扣个税要比这多，但这次扣个税为0，两个数字并不能对上，不知道为什么。另外，个税专项附加扣除法是从18年10月份公布，19年1月开始实施，自己前十一个月都没报，按月算下来还是不少数目呢，竟然都没报，很懵。同事说前面的应该可以去税务局提申请补报，还没来得及去求证。</li>
  <li>每年这个时候，不少人都会写自己的年终总结，我也是，从2015年开始就每年写，到现在，我的博客里已经整齐的躺着：2015年终总结2016年终总结2017年终总结2018年终总结不知不觉已经写了四年，再次打开以前的总结文章，看着以前总结中的一些图片，读着以前写过的文字，有时会有一种很陌生的感觉，好像没有发生过一样。但这可能就是年终总结的意义，记录自己的过去，记录自己的变化，记录自己的成长，以后再次回忆时，它们都可以成为更好的佐证，或者是一种溯源的方法。尽管年终总结有时看上去挺有意思的，但是对于平常没有写作习惯的人还是来说，决定要下笔还是需要一些动力的，而且即使要决定动笔了，不少时候，可能写了一半就坚持不下去了。尤其年终总结要横跨一年，串联起那么多事，有时显得并不容易。即使自己一直有写作习惯，但要写出有条理的年终总结可能也需要花不少时间。如何用偷懒的方式，还能高质量写出一篇自己的年终总结呢？自己之前想了一种写年终总结的方式：自问自答，通过问答的形式回顾这一年。具体可以分为三步骤。第一步，整理问题。在写之前，先假想自己是被主持人在采访，然后整理出各种问题，写出来，问题不一定要有序。回顾自己的一年，其实所有发生的事、思考的东西都可以被提炼为一个问题。比如这一年养成了每天锻炼身体的习惯，那就可以提问：今年养成最好的习惯是什么？如果今年去了一个不错的地方旅游，就可以提问：今年最有意思的一次出行是什么？等等…第二步，对问题排序。列出所有的问题后，问题可能并没有顺序，而实际上一些问题前后有某些关联，所以可以对它们进行一次排序，让整体的问答过程看上去有关联性一点，这样最终呈现出来的一体性更好。这一步就像访谈类节目的后期剪辑，剪辑后采访的内容会更加连贯。第三步，回答问题。前两步完成后，就可以按个去回答自己提出的问题了，因为每个问题都是一个小块，主旨很明确，答起来就会比较轻松，最终把所有的问题答完，总结基本也就好了。以上就是自己分享的一种年终总结方式，我的2017年终总结就是通过这种方式完成，感兴趣的话可以点击阅读。另外，年终总结不一定要公布出来，再说也不是所有的事都适合公开，所以选择自己觉得舒服的方式去写作也很重要。</li>
  <li>昨晚做了一套逻辑类的调查问卷，每道题限定60秒的答题时间。题目中有一些是找图形规律的，有一些是给出一大段话或者一堆数字，让你从中总结，可以从报表中得出什么信息，等等诸如此类的思考问题。一共三十道题，一开始还可以专心答，后来越答题越没信心，总觉得注意力很难集中。以前上学考试时，题比现在多，但即使不会做，注意力也一直都会处于集中的状态。现在的感觉就是，看到这种思考题，连续做几道，无法集中注意力，脑袋不听使唤。想了想原因可能有几点。上学时每年都有考试，考试要求短时间内持续集中注意力，而从小学到大学，每学期都在考试，从另一个角度讲，每年都在练习这种聚焦的能力，所以大脑一直有这种随时可以长时间聚焦的能力。毕业后，很少有这种考试，再也不用集中注意力读阅读理解，再也不用集中注意力思考证明题，即使有，比如一般的面试，也可能就是几道题，很少有那种要求你两个小时内连续思考的机会。所以大脑很快就放松了，毕竟任何东西都知道偷懒，大脑也不例外。所以环境对一个人的改变是悄无声息的，可以悄无声息的让自己的大脑变得很强大、缜密，也可以让大脑悄无声息变得懒惰。当然工作后大脑也不是变得更差了。工作后看到资料更多，读的书更多，接触到了更多的思想，大脑在思考的广度方面比以前强多了。而且大脑也不是真真的懒惰，可以发现，大脑喜欢听故事，面对一个逻辑问题，它的状态会比较差，但是如果给它一个故事，他却能从头到尾的看下去，也许这也可以理解为大脑的舒适区。总之，大脑是个很神奇的存在，有时要把大脑看成自己的一个对手，不断的跟它斗争。关于大脑，李笑来在《把时间当做朋友》中有一段论述：作为一个人，这一生中可能遇到的最惊人的经历，莫过于发现这样一个神奇的现象：我们竟然可以用我们的大脑控制我们的大脑。</li>
  <li>今天中午吃过饭后，1点半，然后有点困，就直接睡觉了。自己周末没有午休的习惯，也就偶尔睡几次。今天睡觉前没有定闹铃，一觉睡了三个小时，睡觉睡到自然醒的感觉很舒服。关于睡觉，之前看到一个科学调查，睡眠不足会更容易影响一个人的情绪，比如睡眠不足可能会使人更容易发怒，让人暴躁。而且一些时候，也验证了事实确实如此，所以要熬夜时，就会想还是早点睡吧，或者真的决定熬夜了，就把第二天的闹铃改迟一点。==========================今天给图床app增加了一个编辑标题的功能。因为一些md编辑器支持显示图片标题，如简书等，可以在图片下方展示图片标题信息，如下所示：而要在编辑里为markdown格式的图片链接输入标题有点麻烦，标题都在[]这两个符号中间，通过鼠标或者光标去聚焦都有点困难，所以就让咕咚云图在app中支持了标题编辑，效果如下（该截图通过咕咚云图上传）：该功能会从进入下一版本。</li>
  <li>一看标题，还有四天就2020年了。时间真快，我还记得四月份的时候，有一次看到一个微博的网友每月做一次月总结，当时想要不要自己也试试，这样今年就不用写年终总结了，到时直接把月总结拼起来不就OK了吗。后来我试着开始写月总结，不知不觉已经写了8期，每次都是按照工作、生活、孩子分别去做一次回顾总结，每月总结时给下月设置一些目标。中间还有几个月，想着每月去刻意练习一种思维模式，但是执行的不好，有点想当然。整体而言，对于月总结，我觉得是一种比年终总结更好的总结方式，因为一年的跨度太长，一个月总结一次，会更容易发现一些没完成的事，而且月目标也更容易调整，尽管我后来的月目标也越来越流于形式，惭愧了。但是回想一下，月总结还是一个好习惯，2020年应该继续坚持。已经到年末了，按照以前的习惯还是写一篇年终总结。写年终总结这个习惯是从2015年开始，那时，Android圈如火如荼，技术氛围很浓，年末一个开发者发起了『你好2016，再见2015』的年终总结活动，不少开发者都参与了，我也是。2015也是自己开博客的第一年，玩的很开心，那时才25，擦！！！后来每一年就开始坚持写了。习惯就是这样，当你坚持久了，就不想把它断了，很讨厌断掉的感觉，可能也是一种强迫症。今年的年终总结还没想过，我觉得需要看看月总结列表，但是简单想想，这一年暂时想不起来有那些可以称道的东西，具体留着年终总结里再写吧。==========================今天更新了咕咚云图(name.gudong.pic)-1.0.8-应用-酷安网108版本，加入了很多细节优化，一开始做功能，总是很简单，但是真的要思考产品细节时，会发现把一些交互能设计的简单，一点都不容易，为了一些细节，花的心思比写代码花的时间长的多了。</li>
  <li>我一般都是下班路上写日志，这个习惯很久了，不过以前是写在自己的一个日记本里，现在写在公众号里。一般回家一个小时左右的时间，大多时候也够写了，不过有时想到一些稍微深刻一点的话题则要多花点时间去思考。其实写字最好的状态就是一口气写完，没有打断，但是这种状态并不好找。去年曾有过一个丧心病狂的编辑器，他要求写作者一直持续不断的打字，否则只要中间有停留，编辑器就会开始以一定速度删字，删字，删字……想一想是不是很刺激，我没试过，光想想就觉得压力山大。但其实不少好的文章就是妙手偶得，抓住灵感经过的那一刹那。所以有些人会随身带着一个小本子，记录那些一闪而过灵感。不过现在有手机方便多了，任何时候只要有灵感就可以随手拿出手机记录。我上次买的付费软件就是一个写作软件—纯纯写作，作者是我之前就认识的一个开发者好友，我知道他开发这个软件很久了，自己也下载过，但是搁在手机里一直没怎么使用。那段时间因为每天要去记录一些碎片化的东西，就想到了纯纯写作，我比较喜欢他设计的时光机功能，也算是草稿箱，这对于收集灵感很有用，所以就入手了。现在自己公众号的每天日记都通过这个手机软件完成，这在以前看来是不可思议的，我一直觉得电脑才是最适合写作的地方。纯纯这个软件功能很强大，不过也有不足，就是功能太多了，对于一般的使用者来说，功能有点臃肿，有种pc版office的感觉。其实所有工程师做的软件都很容易陷入功能堆砌的怪圈，因为对自己来说，实现功能是最拿手的，而事实上一个产品能不能走的远，功能只是一方面。而且由于不断堆功能，会让开发者很疲惫，你永远不知道下一个用户会给你提出什么样的需求，而且对于一般的用户，他用到的功能实际只有百分之二十不到，甚至更少。所以如何舍弃功能，对于一个工程师来说就很有考验。最简单的例子，微信，它的功能实际上非常多，但是被安排的比较合理，所以微信给人的感觉很稳妥，尽管应用市场里每天有很多人在吐槽微信，给微信提功能建议，但是它的取舍就做的非常好，它的核心功能一直很明确。即使后来加入了支付，购物这些商业目的很强的东西，但是这些并没有侵占微信的核心功能，相反，微信的产品通过合理的设计，让它们的存在很协调，这才是一个工具产品最难做到的。</li>
  <li>只要逻辑正确，事实就一定发生。前段时间老是看到这句话，第一感觉这句话挺对的，逻辑正确，也就是按照物理世界的规律，这事是完全正确的，它可能不是每次发生，但是一定有发生的概率存在，这样，不论概率大小，这件事就一定会发生。尽管可以理解这个道理，但一开始不知道如何把它结合到实践中。这两天想了想，终于还是找到了几个合适的例子。拿自己身边的一个事举例。公司上班每天都需要打卡，一开始自己一直用工卡打卡，后来小米出了NFC手环，手环支持模拟工卡，然后就可以用手环打卡，所以手环上市没多久，自己就入手了。从那以后，我几乎都是用手环打卡，而且确实也方便，到了公司门口再也不用去翻自己的包或者口袋了。但是手环有一个问题。它需要有电才能工作，而工卡是一个物理卡，它什么时候都可以工作，没有电池这个限制。尽管小米手环续航很好，充一次一般能用半个多月，但是它依旧是一个需要充电才能使用的手环，这是一个客观存在的事实，所以它一定存在没电的情况，所以如果只依赖手环打卡，终有一天，自己会被拒之门外，只因为手环没电。没电这个事发生的概率很小，但是它只要发生了，这个事对自己就是百分百对自己的伤害。其实对任何有概率的事都是如此，只要有概率发生的事，未来就一定会发生，所以对这个小概率的事最好有所准备。后来我尽管一直在使用手环，但是背包里一直都装着工卡，而且目前看来我已经用过多次工卡了，避免自己进不了门的尴尬。手环除了可以刷公司卡，还可以刷地铁，这同样也存在没电时刷不了地铁的问题，所以背包里一直都备着钱包、现金。逻辑上正确的事有很多，很多事都张上面提到的手环一样，第一感觉都觉得发生的概率很小，然后自己就会很容易的忽视这个小概率事件。事实上，只要拉长了时间维度，这个事发生只是迟早的事，所以不要忽视小概率，准备好自己的B计划，不一定那天就可以给自己帮大忙。不过这个道理，更多适用于对事物下限的兜底，如果拿它去搏事物的上限，可能会让自己很“艰难”。比如说股市，逻辑上讲，利用股市可以让人们财务自由，尽管这是一个小概率事件，但这确实存在，按理说，如果去花时间去博这个小概率事件，这个事件一定会发生，但即便如此，你真的敢去博这个上限吗…</li>
  <li>我的个人博客从2015年搭建后，到现在已经四年了，与此同时，我的域名gudong.name也服役了四年。还记得一开始，我最中意的域名其实是gudong.me，但是这个域名一直被抢注，后来就放弃了，慢慢的觉得gudong.name这个域名也还不错。但是这个域名一直有一个问题，不支持备案。因为不支持备案，所以我的博客文章在微信内打开时，总会被微信这样提示，然后二次点击才可以访问。另外，自己最近在折腾各种图床，其中的图床服务之一—七牛云，它的文件存储功能需要绑定一个域名，而且要求域名备案，所以七牛云图床暂时就gg了。然后，前段时间我的.name域名到期了，阿里云短信提示我续费，续费时发现.site域名支持备案，价格还比.name便宜，所以就果断买下了gudong.site的域名。这次一次买了五年期，一共才99块大洋，而之前的gudong.name每年55，而且即使多买几年也不优惠。买下了域名，还有一个问题，我如果直接把博客的域名替换了，我之前所有对外公布的博客文章链接都会失效。所以想了个权宜之计，把我原来的博客fork了一份到另一个github账号，让它继续指向gudong.name，不过每篇文章的最顶部都给了一个黄色的Warning提示，让访问者去访问新站点，如下所示:这样就解决了大量的404问题，不过gudong.name这个域名只续费了一年，明年这个时候就再也不能访问了，saygoodbye~</li>
  <li>微信7.0以后增加了“在看”功能，用来替代以前的点赞。现在，对公众号文章点在看后，文章就会出现在看一看页面。而自己的“在看”的动态会被所有微信好友看到，其实“在看”就是一种更便捷的分享文章到朋友圈的方式，还不能设置分组可见。自己一直不愿意点在看，主要原因就是不想被动的展示自己的“在看”动态，因为微信好友太多，并不是所有的好友都是一个圈子的，或者有时就是单纯的不想让别人知道自己“在看”了什么文章。比如我，就不怎么愿意让同事知道我在这里写东西，😂所以我对自己的文章点了在看，肯定不愿意让同事看到。所以这个问题困扰了很久。我一直想，如果“在看”能跟朋友圈一样，可以选择分组可见该多好。直到上周才发现，尽管“在看”不支持分组可见，但是却支持设置“不给谁看”。也就是说可以设置”在看”黑名单，设置后，这个名单里的好友将不会看到你的任何在看动态，是不是有点意思，反正我看到后觉得很有用，一下子就加了好几十个好友。🤣🤣🤣具体设置路径在看一看页面，点击右上角用户中心，进入我的在看列表，然后点击锯齿形状的设置按钮。接着在下一个页面选择“不让他看”，这样就可以设置自己的在看黑名单。只不过这个设置是一次性的，不像朋友圈，可以在每次发送的时候灵活的设置分组，不过也是一种方案。读到这，要不要点个“在看”去测试一下？==========================今天在酷安市场里看到了最美应用对咕咚云图的一篇报道，备受鼓舞，具体报道地址在下面。三款痛点精准的Android工具，或许刚好有你需要的byMephisto.pheies接下来的业余时间会重点开发自定义图床的功能，还有保持应用的稳定性，再接再厉。</li>
  <li>咕咚云图：Android手机端的图床利器-2019快捷、便利，咕咚云图是专为手机端打造的一款图床上传APP，帮助你更快速的为手机中的图片生成远程地址。更多详情稍后阅读：一种高效阅读方式的探索-2019信息大爆炸后，我们可能需要更高效的阅读方式。更多详情Passbook：我心目中的账号密码存储应用-2018Passbook是一个用Kotlin开发的用于存储密码数据的Android应用，自己曾经在2013年开发过一次相似的应用密码本，但是后来被自己下架了，因为加密问题以及忘记登录密码的问题难以解决。这次一开始是自己为了练习Kotlin才开发的这个项目，目前已经算是一个比较完整的应用，但是考虑的安全，我还是没有彻底的公开，现在这里公开的只是一个有3天体验时间的体验版。更多详情柳叶清单：管理日程的网页清单程序-2018你平时是怎么规划每一天的？发布这篇文章时才发现上一次发文章已经是五个月前了，这段时间博客一直没怎么搭理，日志也没怎么写，主要是工作+生活确实是有很多事。最近根据个人需求开发了一个清单+看板的应用-柳叶清单，使用Vue+Leancloud学习开发一个完成的前端应用，这真是一个有意思的事情，既可以学习技术，还可以解决自己的问题，还能满足自己的好奇心，这篇文章就是自己为什么要开发的初衷。更多详情易剪：手机端的剪报助手-2017为了解决个人在手机上阅读文章时而开发的一个收集笔记内容的Android工具App，核心功能就是帮助用户在移动设备上快速剪贴自己感兴趣的文章片段。https://gudong.site/2017/03/15/about_easypaper.html)更多详情咕咚翻译：Android设备上翻译效率神器-2016咕咚翻译是自己最近开发的一个实现『划词翻译』功能的Android应用，可能是目前Android市场上翻译效率最高的一款应用。https://gudong.site/2016/02/26/gudong_translate.html)更多详情AppPlus：传送、分享APK到其他手机-2015一个主要用Android用户间传送Apk文件、管理手机应用的工具软件。更多详情</li>
  <li>今天是考研的大日子，我有一个同事就是其中的一员，他报考的是北航的在职研究生，今年一整年都在准备，晚上下班后他会都在公司“加班”听课，很辛苦，希望他成功。大学时，到大三的时候，班里已经有不少人开始准备考研，其中不乏一些平时的学渣，而我成绩不上不下，几乎没考虑过考研。那时是这样认为的。计算机是偏实践的课程，考研我认为主要是搞学术，即使考上，还要花两年时间去继续在学校度过，而我那时就想早点工作，那时好像特别憧憬工作。同时认为考研对自己是小概率事件，不想花费那些时间去为争取，而且那时正沉迷在自学Java的过程中，后来接触到了Android，大四便直接来到了北京。后来同班只有一个同学考上了，他一直都是班里的学霸，每次考试前突击备考时没少问他题，他确实是很适合考研的那种。后来毕业后他也来到了北京，我们联系并不多，去年仅有一次电话联系，他目前在一家国企，已经拿到了北京的户口，然后我跟他道喜，他却说户口也没啥用，北京房子那么贵，以后留不留北京还不好说呢，不知道他现在还这样想吗。而我另一个朋友没有北京户口，为了让孩子在这边上学，最后只能买学区房解决孩子上学问题。🤪目前看来，我觉得如果自己有考研的能力，还是应该去考一下，能考下来，这就是跨过了一个门槛，在一些时候可以提高自己的竞争力。一开始我觉得早点工作可以早点积累工作经验，早点体验工作的乐趣，一直到刚开始工作的那几年，我还是这样觉得。直到后来慢慢发现，早点工作，确实可以让自己多积累工作经验，但事实上，人生那么长，提前工作的这两年，并不能保证你在人生长路上可以比别人跑的更远。所以如果自己有考研的能力，或者自己努力努力有机会可以考上，还是应该去搏一搏的。至于自己，如果让自己重新选一次，我可能还是选择工作，为什么呢，我觉得那是内心的声音。</li>
  <li>从11月初开始写，写了一个月的公众号，内容挺分散的，并没有什么明确的主题，大都是围绕自己的小世界，想到什么写什么。但是再次回顾的时候会发现，自己写的主题主要有三类。篮球。这是工作以外最大的乐趣，每周都去打，所以故事也就比较多。App开发设计。这段时间开发维护自己的图床app，任何一个小东西，要真正做的时候还是有相当的工作要做。另外，后续还想开发高级功能做收费版，不过还是挺不容易的，进度跟预期并不一致，耐心很受考验。产品细节思考。有时想想也是闲的蛋疼，整天思考人家微信干嘛，不过跟很多人一样，还是爱去琢磨，只不过我把这些都写了出来。有时代码写的比较枯燥的时候，也会想要不要转行去做个产品经理，但是还是很难离开这个舒适区，况且工程师薪资要比产品高呢，终究还是摆不脱物质的束缚。此外还有一些是关于效率提升类的思考，这个自己一直都在探索，效率提升没有终点，找到自己喜欢的节奏最重要。大概就是这些内容了，每篇不长，也不想写太长，短点的可以更好的review，可以确保不会有太多的纰漏。============================最近股市表现很好，之前一直在定投指数基金，实际上过去坚持定投的人，目前大都应该是盈利的。话说回来，对一般的初级投资者而言，没有比上证指数3000点以下去定投更好的投资策略了。Note:第一次发表投资相关的言论，听听就好，不构成具体投资建议。不过当大家都在推荐定投指数基金的时候，如果用反共识的眼光看，这件事可能会有一些潜在的风险。今天看到一篇关于指数基金可能造成下一次金融泡沫的文章-投资被动型指数基金正在造成下一次金融泡沫？-GeekPlux，文中的观点还有思考方式值得一读，推荐之，点击阅读原文查看。</li>
  <li>人人都是产品经理，关于经常使用的产品，每个人都很容易有自己的想法。对我来说，更是如此，在使用软件等工具的过程我喜欢去思考一些产品细节，尽管我是一个工程师（不过话说回来，目前国内最成功的产品经理也是工程师出身呢。）这篇文章分享一下自己对社交媒体中表态按钮的一些理解和看法。首先分别介绍一下标题中的四个表态词。赞社交媒体一开始就有的设计，用来跟博主形成较轻量的互动，用户如果觉得博主说的好，就可以顺手点赞。对于点赞，博主的内容不一定要正确，但只要有意思，好玩，大家可能都会选择点赞。鼓掌知乎特色。在知乎中发表一个动态，动态下方除了传统的评论、转发按钮，第三个本应该”赞”的位置，被“鼓掌”取而代之，这是一种对赞的更细分探索。个人感觉鼓掌比较新颖，但实际意义并不大。好看这是微信7.0设计之初的一个大改变。为了更好的利用微信拥有的熟人社交优势，以便构建一个靠用户而非机器分发的信息流，微信去掉了原来公众号文章最低部的点赞按钮，取而代之“好看”。好看也是赞的一种细分表示，但是点了好看后，文章会被推到发现页面中的看一看信息流。这么做的用意很明显，更好的解决公众号文章的存量问题。以前公众号文章只能在群聊、朋友圈以及订阅流展示，现在通过“好看”，相当于在微信中再造了一个内容分发渠道，渠道到了，展示的机会也就多了，这样可以更好的利用微信的巨大流量。在看微信7.0没多久，“好看”便被更名为了“在看”，为什么呢？原因很简单，很多用户不愿意点好看，点好看让用户感到压力。以前看公众号文章，随手点个赞，很轻松，别人不会知道，现在点了”好看”，整个微信好友都知道了，因为自己的“好看”，会被推到看一看，而且点好看还不像发朋友圈，可以选择分组可见。与此同时，“好看”有明确的表态。点好看的同时，用户被有意无意的代表了自己观点—这公众号文章“好看”。微信很快发现了这一点，所以就有了现在的“在看”。不过只是解决了上面的第二个问题，即强制让用户表态的问题。即使如此，还是没有解决点“在看”让用户产生压力的问题。思考微信是熟人社交，在这样的前提条件下，任何面对朋友们的表态都面临着大家的审视，所以只要表态，就有可能面临一些社交压力。除非这个表态只有自己知道，就像之前的赞，但微信又想构建新的内容分发渠道，所以就有了“在看”。相比一开始的“好看”，没有明确表态的“在看”可能更符合中国人的”中庸之道”的文化，但感觉还是一种折中的方式，有点牵强，句式上明显没有“好看”“赞”这么强烈，感觉这也是微信的无奈之举，他们一定也在想更好的动作词。既然让用户表态压力大，又想要通过熟人、好友分发内容，貌似这是一个矛盾的事，但这里可以换一种思路：不让用户表态，换一种说法，比如用帮转，帮推，或者帮火这样的词，我们内敛、不喜欢当众表态、说话，但是大家普遍喜欢帮忙，尤其是这种动动手指头就可以帮到的忙，加上文章写的确实还有点水平，有点干货，这种“帮”的行为可能更容易达成。===================================这篇文章实际上上周就写完了，一直在草稿箱里，今天review了一遍，补了几张图，另外今天的图都是通过我的咕咚云图app上传，手机上传图很方便，咕咚云图(name.gudong.pic)-1.0.4-应用-酷安网</li>
  <li>晚上看到群里的同学分享了一个新版本微信，还没注意截图是夜间模式，自己就赶快找到以前收藏的微信内测地址(点击原文查看)，下载、安装一条龙，迫不及待打开新版微信后，亮瞎了！！！？？？微信支持了夜间模式。不过查看微信的设置选项后，微信并没有新增夜间模式开关按钮，所以这次的夜间模式并不是微信从头到尾自己做的功能，而只是适配了AndroidQ版本支持的新特性—暗黑模式。所以别高兴太早，只有自己手机的Android版本是AndroidQ才可以在新版本中看到夜间模式。Note：如果自己手机还不是AndroidQ版本，那就要等手机厂商给你推送了。用了一会，整体体验很不错。尤其是对话界面。说明：截图中的键盘是讯飞输入法，也适配了暗黑模式，看上去浑然一体，有木有~聊天页面最引人注目的是自己信息的背景颜色，鲜艳的绿色，非常吸睛。下面是表情选择以及更多菜单样子。这是朋友圈的夜间模式，以后可以多一个晚上刷朋友圈的理由了。另外这次除了夜间模式一个大功能外，微信扫码页面也重新设计了，扫码框从以前的小方角变为了全屏。走查了一圈，微信绝大部分的控件都适配了夜间模式，目前看上去只有公众号网页没有适配，WebView本身也不怎么支持夜间模式，再说Google的Chrome浏览器现在也还不支持夜间模式，所以这个可以理解，现在只是公众号TitleBar适配了一下，如下所示。不论如何，支持夜间模式，哪怕是只支持AndroidQ版本，这也是对用户的一种爱护。尽管龙哥之前说，不做夜间模式是为了更好的爱护用户的眼睛，但微信已经成为人们生活的一部分了，除非可以完全不用它，否则夜间模式还是有存在的意义的。既然微信已经适配了夜间模式，那现在压力就来到了微博这边…毕竟有了夜间模式，就可以让用户更长久的在微博里看广告了…来总：小兄弟，你重说一遍！！！咕咚同学：…</li>
  <li>今天晚饭后，旁边的同事们突然聊起了Flutter。Flutter是谷歌去年推出的一门跨平台开发技术。什么是跨平台开发技术？以前开发app时，因为不同操作系统的设计架构不一致，所以需要为苹果和安卓平台各开发一个app，而尽管这两个app的功能、样式几乎一样，但两个app的代码是完全不一样的，也就是说，同样的功能需要开发两套代码。目前世面主流的app都是如此，比如微博、微信，它们在开发时，每开发一个需求都需要至少一个安卓程序员和一个iOS程序员才能完成。而谷歌推出的Flutter技术解决了这个问题，现在只需要一个Flutter程序员写一套Flutter代码，两个平台的app就都搞定了。一般人听到这个都应该很惊讶对方的创造力，对谷歌大都是夸奖赞美之词，但是今天跟同事说完，他却说：谷歌这是搞什么，花里胡哨，出了Flutter后我们可做的事不就没了吗？听到他这样说，我倒也不想反驳，因为说的也有道理。毕竟Flutter提高了近一半的效率，往大了说，这是一个可以消灭一半前端工程师的技术。说到这，我就想到了之前的复仇者联盟电影。其实钢铁侠、蜘蛛侠，美国队长这些漫威电影，我还都比较清楚里面的故事，但是后来又出了复仇者联盟，我就开始凌乱了，总是对里面人物还有各种宇宙傻傻分不清楚，后来出现了灭霸，更是一头雾水。直到后来网上看到一个解释，我总算大体上清楚了灭霸与复仇者联盟的关系。这个解释很有意思，它用软件开发来解释灭霸跟复仇者联盟的关系，具体的解释大概是这样:一个公司里有一个陈年老项目，开发维护了多年，代码特别臃肿，但是谁也不重构，也不优化，因为优化需要占用做需求的时间，产品经理不同意；工程师也不愿意重构，因为重构风险太大，很容易出问题，还没有什么额外的收益，一旦出问题，大佬群里一@，大家都得抖三抖。这时，公司空降了一个技术干将，接手项目后，马上就发现了项目的问题，而且由于技术能力过硬，很快他就规划出了完整的重构方案。在这个方案下，代码量会减少一半，后续的维护工作只需要一半人力即可，可以大大减少公司的运营负荷。那多余的人怎么办？按照一般的做法可以直接开除或者内部转岗。这下好了！原来的工程师们不干了，这是要断自己的营生啊…接下来便是这位技术干将跟老工程师们的斗争了，这也就是灭霸跟复仇者的故事。灭霸觉得地球上的人太多了，多余的人就是在浪费地球的资源，他要收集到五颗原力石，然后再用一个响指消灭掉一半的人，这就是他的重构计划，复仇者们当然不愿意，所以这就是复仇者联盟的故事了，这里灭霸具体的动机可能描述欠缺，但追求个大意即可。所以关于Flutter，如果用阴谋论，Flutter其实就可以理解为我们广大前端工程师的灭霸了，那作为移动工程师，我们要怎么跟它斗争呢…八仙过海，各显神通，快来接招吧…</li>
  <li>封面图是我今年买的莱昂纳德的一件猛龙队的体恤，我买这件体恤的时候他已经转会快船队了，我本应该买他快船队的体恤的，但是他上个赛季在猛龙队的表现实在太棒了，为了留下那份独特的回忆，我还是买了他猛龙的体恤。而上周，有一场NBA的焦点比赛，跟莱昂纳德相关，快船队客场迎战2019年NBA总冠军—多伦多猛龙队。为什么是焦点战，因为今年夏天刚刚帮猛龙队拿下总冠军的猛龙队球员—莱昂纳德，现如今NBA的头牌，今年转会到了现在的快船队，这场比赛是他转会后第一次以客队身份在猛龙队主场比赛。要知道就在不久前，他还是这里万众瞩目的英雄。NBA有个传统，赢得总冠军后每个人都会有一个冠军戒指，但这个戒指并不是总决赛打完就发，而是等到下赛季开始，这个球员第一次进入这个球场打球前才会颁发。在这次给莱昂纳德颁发戒指前，猛龙队为了致敬莱昂纳德在18-19的突出贡献，制作了一个短视频，短视频里记录了上赛季他在季后赛里的各种英雄时刻，再次观看历历在目。尽管NBA每年都有季后赛，每年都有总冠军，但是并不是每年的季后赛都可以成为史诗。我从大学开始看季后赛，真正让我觉得好看的季后赛就三次，09-10赛季湖人夺冠，17-18勇士夺冠（骑士虽然输了，但那个季后赛是詹姆斯的史诗），以及今年的猛龙夺冠，这三个季后赛三个主角，科比、詹姆斯、莱昂纳德他们都面对特别严峻的挑战，最终他们靠意志力、个人能力、靠团队拿下了胜利，其中贯穿了很多的个人英雄主义，这样的季后赛才是最好看的。回到文章的主题，世界变化太快，不同的世界不同的驱动力，不同的驱动力驱动不同的世界，NBA的世界在强大的商业驱动力下异常的活跃。一个世界越活跃它的可能性也就越多，NBA因此也更精彩，更有故事性。</li>
  <li>我第一次看许知远的《十三邀》是去年看的，当时因为采访的对象的李诞，而自己刚看过《吐槽大会》，对李诞这个人挺感兴趣，所以就看了这个节目。第一次看这个采访类节目，观感很好。许知远采访时选的地方都很接地气，比如饭馆，酒吧，路上等，这很容易让被访对象打开话匣子，也更容易敞开心扉，观众看的时候也容易被这种纪实的环境吸引，感觉就像在看一个纪实类节目。许知远采访李诞时选的是一个小饭馆，两人吃着火锅喝着酒，两人开始畅聊人生观、价值观，聊各自看过的一些书，聊李诞的一些过去，很有意思的访谈。后来还看了他对姜文的访谈。当时自己刚看过《阳光灿烂的日子》不久（是的，这部93年的经典电影我是18年才看的），那时自己对姜文比较着迷，很喜欢他那种真实的性格。姜文哪一期节目做的不错，他在做姜文哪一期节目时，特意去了当时拍《阳光灿烂的日子》的地方—内务府街。他找到了姜文小时候的住的胡同院子，还找到了拍电影时的那个大烟囱。当时拍电影的地方还在，只是有点破败。看完节目后因为对姜文的喜欢，还有对北京胡同的着迷，我特意挑了一个周末去了趟内务部街，打算去认真的品味一下胡同，还有去找寻那个夏雨爬过的大烟囱。很遗憾，第一次没找到烟囱，但是把东四那里的胡同转了个遍，一个人骑着车子，在老槐树的树荫下不断穿梭，那就是老北京的感觉。后来没过多久，再次路过东四时，又去找了一次，终于找到了那个烟囱。这便是十三邀给我的一些影响。今天看了许知远对王小川的采访，他分了两期。我之前对王小川这个人没什么了解，但是节目内容令我很意外。内容很丰富，王小川特别能说，很放的开，人工智能技术、价值观、方法论等等，聊了很多东西，大佬的世界别有洞天。一个理科学霸的内心世界真是与众不同，也十分有意思，今天的分享小结就选这期节目。另外这一期自己看的断断续续，这周值得重新再看一遍。分享只要存在的合理的东西，再小的概率它都存在。只按照概率把它出现了无数多个宇宙。没有随机性。讨论到自由意志，你可能有八种不同的选择，或八种概率的选择在我的世界观里面有可能都发生了，所以你看到了随机现象，其实在它里面，只是进了不同的宇宙而已。每个细胞如果都特别自由，人就瓦解了，所以我是知道一个人，必须有你的担当，一部分的责任，有你的边界，有你不可为。from许知远对话王小川</li>
  <li>上周去医院检查了脚踝。左脚跟偶尔有一些疼痛感，这种感觉已经很久了，不过平时几乎感觉不到，只有偶尔打球时会疼，然后注意下，过两天便没事了。实际上在今年八月住院之前，我很排斥去医院，总觉得麻烦，或者就是懒吧。今年第一次住院后，发现医院检查其实是一个很简单的事，尤其是现在医保制度下，挂号也很容易，即使一些专家号很火爆，提前一周挂便也差不多。另外，北京有这么多的好医院，这么好的资源，不用多浪费。这次挂的是一个专家号，跟他简单说了下情况，他便说这是跟腱炎，比较常见，两种治疗方式，一种封闭治疗，属于比较严重，我这个没那么严重，所以他推荐我去一个运动修复中心做一个冲击波治疗，一两次就好了。这种运动修复中心是私人机构，不能医保报销，距离医院不是很远，我骑车便过去了。到去后，给我做治疗的是一个瘦高的年轻小孩，首先检查了我的跟腱部位，后来确定具体位置后便开始做冲击波，做了有四五分钟左右，冲击波的过程还有点痛，但完成后很快就没有痛感了。冲击波的原理是打碎堆积在跟的钙组织，这也是疼痛的原因，这个跟长期运动的磨损有关，打碎后让那里重新生成新的。后来完成后，教了自己几个动作让我每天练习，主要就是拉伸小腿与跟腱的连接部位，那里也是这次有问题的地方。最后跟他询问了保养建议，他说不论打球还是其他运动前都要先进行热身，另外运动完要进行放松。热身、放松对我们并不陌生，从小学开始上体育课时，老师就这样教我们，只不过现在大家运动时早把这个忘了，所以归根结底，科学的东西一定是有依据的，还是要去相信并执行。最近每天不打算做波比跳了，因为波比跳还是会对跟腱部位有点影响，以后还是多做几组俯卧撑，况且对自己而言，波比跳比较燃脂，并不利于自己增重。===================================“我小时候…”儿子现在虽然也不小了，前段时间刚过完四岁生日，但不知道他跟谁学的，平时老爱说：我小时候坐过这个飞机这，我小时候爬过这个山，这是我小时候的玩具…等等，实际上他记得的这些事也就是三岁左右的事，不过在他看来，他现在已经很大了。他是多么渴望长大。分享在中国市场不要贸然学习巴菲特，因为是市场造就了巴菲特，而不是巴菲特造就了市场。在中国市场，单纯追求价值投资没有意义，必须要密切留意投机性、杠杆率和波动率。中国经济未来会很像日本，长期泡在低增长、低通胀、低利率的环境中，人口出生率也低。from付鹏：下个十年，如何配置全球资产？by伦敦交易员</li>
  <li>“长按二维码关注我”Daily12/13无意标题党，但这篇说的确实是公众号二维码引导关注的问题。经常看公众号文章的话，可以发现在不少文章都有引导读者关注公众号的的二维码或者图片，它们一般在文章的开始或者结尾处。我觉得这样并不好，影响读者的阅读体验。实际上文章如果真的好，读者会去主动找到作者并关注，除非他们不知道公众号名称可以点击。不过一些读者可能真的不知道点击公众号名称可以去关注，那这样倒也情有可原，但如果每篇文章都占用篇幅去引导，就不好了，尤其是对那些已关注的用户，人家已经关注了，这种引导完全就是多余。关于这个问题，早晨突然想到一个解决办法。微信作为平台方是完全知道当前读者是否关注了作者，那它只要为公众号作者提供一个引导模版，然后在为读者展示文章时，只要根据用户是否关注了作者，然后动态控制是否显示那个引导模板，这样就可以很好的解决这个问题。不过又想了想，傲慢惯了的微信才不会做这样的功能。自行脑补了一下，他们大概会这样解释，就跟我一开始说到的意思一样：创作者应该重视内容本身，好内容自带关注技能，微信不会做任何引导用户关注的事情。听上去是不是很符合张小龙的语气[斜眼笑]===================================听取不同的声音不要过分去崇拜一个人，哪怕他十分优秀，因为一旦陷入崇拜，就不在是你拥有了他，而是他占据了你，所以这种时候可以去关注一个跟他相反的声音，去对冲一下。这对基金经理，微博大V都有效。===================================分享当足够多的人相信一种思想以至于它成为常识的时候，它就控制了我们。不是我们拥有思想，而是思想占有了我们。from反过来想，反过来想，总是反过来想by李善友</li>
  <li>挤地铁时有两类人。一类像我一样，如果看到门口太挤了，自己就等下一辆，或者往后坐一站再上；还有一类人，只要看到还有一点空隙，就会使劲往里挤，把自己挤进去，哪怕自己被挤的不成样子。我认为后者并不是因为时间紧才这样挤，因为时间紧可以早走，每当我看到他们用力的挤，我还有点佩服他们，这应该是一种生活态度。对于自己，如果看到这种需要费老大劲才能做成的事，我都会缓一缓，等一等，而且事情本来不紧急，我觉得没必要这样，我还是更喜欢水到渠成。不过从另一方面讲，也可以把我这种想法理解为懒惰，但也可以把它说成佛系。实际上，在生活中，很多情形下，那种不管不顾，奋不顾身的人，往往却可以争取到更多的资源，这也是不争的事实。归根结底，我觉得都是一种选择，孰好孰坏，不一而论。========================================网易的英文名一直以来，其他公司的英文名都知道，比如Baidu、Alibaba、Tencent、Sina等，唯独网易的英文名自己一直没记住，只知道是N开头，后面的就不知道了，今天经过网易的时候才发现，其实很容易记，NetEase，net（网）ease（容易）。写日志的好处今天去医院检查左脚跟腱，那里只要刻意弯一下就会很疼。实际上17年自己崴过一次脚，我一直怀疑跟腱跟那次崴脚有关，但是现在一直不确定当时崴的是左脚还是右脚，时间太久忘了，当时也没有照片，今天候诊时突然想起来自己博客有日志，然后就真的找到了当时崴脚的记录。实际上应该给自己建立一个医疗档案记录，包括每次感冒时间，吃的什么药，这种信息记录下来，可以更好的跟踪自己的健康状态，以后也可以查询溯源。墨菲定律事情往往会向你所想到的不好的方向发展，只要有这个可能性。比如你衣袋里有两把钥匙，一把是你房间的，一把是汽车的；如果你现在想拿出车钥匙，会发生什么？是的，你往往是拿错了房间钥匙。打球也是，每当打球戴面罩时，别人很少打到自己的鼻子，但是只要不戴面罩了，八成就会被别人碰到。========================================分享如何评价李子柒？可遇不可求。这样的人，很难被包装出来，真的就是真的，假的就是假的，有太多东西，装是装不出来的。from14岁辍学打工，28岁红遍全网：如何评价李子柒？可遇不可求by粥左罗</li>
  <li>有时候，大脑会特别活跃，脑袋中会闪现一些奇思妙想，感觉一定要立即付诸行动才是。就像这篇文章的标题，感觉起的特别好，一定要立即公布出去。但是如果因为这样那样的原因，这些想法被延迟了，过一段时间，再次回看当时的想法时，就会发现，一开始自己认定的那些奇妙想法可能并没有当初想的那么奇妙，而且那种一开始立马要付诸行动的冲动也没有了，甚至还会觉得自己有点傻—为什么当时会那么肯定的认为呢?所以，当大脑中有那种个人感觉良好的想法、点子时，有时应该让它们飞一会，不要着急，过段时间再回看，如果回看时还觉得这是很棒的东西，那八成就没错了，而且回看的时候，往往更容易发现一开始的一些不足、bug，这样再次修补后的想法才可能更靠谱。分享太拥挤的交易，通常都会赔钱。from下一轮次贷危机来了，连配方都一样</li>
  <li>“用了这么久微信，没觉得它缺什么功能…”很多人可能这样想，其实不然，之前就看到过一篇文章，里面列举了十多项微信应该有的功能，其中有一项这样说：语音消息增加进度控制功能为什么会有这个功能建议，背景大概是这样的。功能背景在聊天时有时对方会发比较长的语音信息，而收信人则必须从头至尾听一遍，如果中途退出了，则还需要从头听，有时可能还想从中间听，但微信不支持，这时用户还得从头听起，所以便有了上面的建议，以便用户可以方便的控制语音播放进度。如此来看，这是很合理的一个功能建议，但是微信为什么这么久也没做这个功能呢，我觉得微信内部关于这个需求一定也有过相关讨论。个人分析首先，个人认为这个需求是存在的，但是微信不做也是合理的。为什么是合理的，这里最重要的一个因素就是产品定位。对于一个任何产品而言，不考虑其他因素，完全可以衍生出无穷无尽的需求，但是在产品发展过程中，一定有一个东西在控制和牵引着需求的发展，这就是产品的定位。对微信来讲，它是一个主打社交聊天的软件，最核心的功能就是与朋友进行通信，而微信主打的通信交互方式则是文字，从一开始就是如此，尽管后来加入了语音消息功能，并因为收获一片好评，但是微信首推的交互还是文字。所以对于非核心交互，微信没有必要去增强这个交互的存在感，甚至会刻意去弱化它的存在，否则如果围绕这个交互去设计太多功能，会导致用户在使用的过程中产生迷乱，甚至喧宾夺主。从这一点出发，微信不去做语音进度控制就可以理解。另外，微信可能一直鼓励用户发送短语音，而不提倡语音过长。这一点可以从它的最长长度限制60秒就可以窥探出来。而且对于大部分人来讲，长语音的体验并不好，大多数人还是喜欢简单、明快的沟通，你一句我一言，如果开发了这样的进度控制功能，反而助长了长语音的发送量，从而破坏微信使用体验。同时，反过来想，不设计语音进度控制这个功能也是在倒逼用户，让他们不要发送长语音。再者，长语音在微信内是小众的需求，为了一个小众需求，而去增加业务逻辑的复杂度，得不偿失。</li>
  <li>稳定很重要，不论国家、家庭还是个人都是如此。稳定的国家可以持续的发展，比如近三十年的中国；稳定的家庭幸福感倍增，其乐融融是每个家庭所向往和追求的；对于个人，稳定是一种节奏，一种生活节奏，一种成长节奏，稳定的节奏才让自己跑的更快更远。成功有很多衡量标准，我觉得稳定可以作为标准之一。小学时，觉得当个飞行员、科学家就是成功；后来觉得做个名人，能出现到电视上，才是成功；高中时便开始务实了，觉得能考上大学就是成功；大学时，觉得毕业后可以找到一份知名公司的高薪工作就是成功。工作后也会幻想着创业，然后一夜暴富，这也是一种成功。而直到慢慢生活、工作才明白，能有一个稳定的家庭、生活环境，这就是一种成功，而且难度一点也不亚于当个飞行员、创业明星。</li>
  <li>小孩子们都喜欢工程类项目，实际上，动画片中也是这么教他们的。可以看到，现在大多数孩子爱看的动画片都是工程类、营救类的，比如《汪汪队立大功》、《超级飞侠》等。为什么他们喜欢工程类的项目，我想了想，原因可能是这样的：对于每一个孩子来说，他们都希望自己的价值得到体现，而工程类的项目，往往更容易提现一个人的价值。比如让他们去找一个绳子、拧一个螺丝，甚至跟大人们一起修房子时，让他们去找一个木棍，都会特别开心，因为在这个事情中他们找到了自己价值，这些价值仅仅是通过自己简单的动手就可以做到的。这样，当他们帮助爸爸妈妈去完成一件事，尽管只是做了一点点，但这对他们的内心是极大的肯定和鼓舞。相比于游乐场那种设定好的工程游戏项目，如果生活中就有这种工程场景，我更愿意带孩子去完成这样的工程，因为没有局限的规则，可以在操作的过程中更好的发挥想象力。前不久，屋顶的灯坏了，拖了三天才安装，安装时儿子就开心的不行。他给我找凳子，找钳子，我知道他喜欢这些事，自己就站在凳子去使唤他，让他给我递胶带，递钳子，他开兴的就像要去坐地铁了一样，不停的拍手，跺脚…今天天气不错，带他去了附近河边的一个小山丘，上面有不少树，不高，都是小树，前段时间风大，刮断了不少树枝，散落在地面。看到树枝，我就想，是不是可以带他做一个小房子，跟他确定后，他很乐意。然后他就开始满山丘的跑来跑去找树枝，就像找宝藏一样，没一会，他就给我整来一堆，这生产力真高。做房子倒很简单。找了一颗大树做依托，另外立了两根柱子，然后再用三个顶梁联系在一起，只是没有绳子，后来找了柔软的柳树指，凑活当绳子用，最后在屋顶撒上了柳树叶子，一个房子就好了。后来他还跟妈妈装饰了一下。做了围栏，他还要给房子加烟囱，加门…他很喜欢这样玩，我也很愿意陪他这样玩，都很开心。做好房子后，他自己还非要钻进去住一下…不过他淘气的地方也不少。今天看脱口秀的一个段子，很好笑。“80后吃饭，就着菜，90后吃饭，就着肉，00后吃饭，就着pad”很贴切，当然他吃饭时没pad可就，但是要看电视，还不自己动手吃饭，让人头疼…</li>
  <li>前天就把自己的图床app上传到了酷安市场，今天终于审核通过了。目前十一下载量，十评论，有人说，要火，希望它能帮助写作爱好者更好的写作。再次感谢drakeet（纯纯写作作者）同学的推荐。以前说过，一开始我并没有打算把这个app公布，但是确实比较好用，所以前段时间便优化了一下，目前有模有样，功能简单，体验友好。具体软件详细介绍可查看我的博客文章—咕咚云图：Android手机端的图床利器今天发布后的第一波用户主要来自写作软件爱好者，他们提了一些意见，确实是之前没注意到的，周末抽空改一改。另外，最近写字有点多，尽管写文章时我选择的都是夜间模式，但眼睛还是受到了影响，今天下午眼睛就有点恍惚，要注意保护才是。其实有时写字并没有花很多时间，真正费事的却是格式、插图以及多平台同步之类的周边事情，所以还是应该更聚焦内容。</li>
  <li>就在不久前，自己买了一个手机号，特意用来注册微信小号，注册小号后，马上就把自己不重要的微信群都转移了过去，这样做的目的是减少群消息对自己注意力的消耗。实际上，微信群消息已经困扰自己很久了，自己总是被那些不重要的群信息打扰，尽管自己已经退了不少群，但剩下的还是有点吵，所以希望有一个小号专门去收纳这些群。然后我每天只需要切换一次账号，一次性的把所有的消息过一遍，筛选出对自己有用的群消息。这样，群对自己就成了一种订阅制，自己也成功从之前的信息被动接受者变成了主动查询者。在转移微信群时，我只保留了那些自己真正关心的群，比如一起打球的群，工作群，还有家人群等，而技术群，社区交流群等统统都被自己转移到了小号。然后自己每天固定的去打开小号一次，去查阅一次消息，试行几天我觉得效果挺好。直到最近，我发现一个有意思的现象：我打开小号的频率越来对低，越来越低，到现在，甚至一周才打开一次。我突然明白，那些群其实完全可以退掉。我不看这些群后，对我生活工作基本没有任何影响，反而获得了更多的时间。————————ps———————–实际上，我认为目前的微信群消息设计还是不够合理，群消息太多，有点过载，尽管微信提供了免打扰机制，以及不活跃沉底机制，但依旧没有解决问题。这就像一开始的订阅号，当时也是显示在消息流主页面，结果导致整个消息流被订阅号消息霸占，毕竟订阅号发消息的驱动力更大，后来微信非常优雅的解决了这个问题，也就是现在的方式—子文件夹收纳订阅号。这样，订阅号就如其名，真的成了一种订阅机制，用户想看的时候才打开，不想看的时候，任由订阅号有多少消息，也不会分散用户宝贵的注意力。所以同样的问题，我在想对于当前的微信群，是不是也可以用同样的方式去解决呢？也就是对群消息也建立一种子文件夹机制，把免打扰的群都纳入到子文件夹内，就像这样：当然，这只是自己的一个脑洞而已，仅供参考，欢迎交流。图片打码by纯纯打码（drakeet）微信Markdown排版工具markdown-nice（mdnice）</li>
  <li>layout:mypostauthor:咕咚title:“说点负能量|Daily12/02”author:gudongtags:篮球categories:dailydescription:—昨天写了文章[《搭档的测试妹子离职了Daily12/03》](https://mp.weixin.qq.com/s/0EwvJ15OKgoXJXrfGw_mqg)，我还同步到了另一个社区，获得了不少的关注度。今天一整天都在讨论中，一些人甚至开始八卦我跟测试，那条评论也成了热评；还有几个人收藏了那篇文章，所以有人评论说，是不是收藏的人想看故事后续；还有人说，故事可以写的长一点，但真的没那么多故事。今天中午去打球，但是没戴我的保护面罩，主要是因为最近我感觉好多了，这段时间打了好多次，鼻子再也没有被侵犯过，所以想当然的觉得鼻子安全了。结果今天再次被认识的同事侵犯到了，当然不是很严重的肘击，不过鼻子也有明显的感觉。这让我很生气。完了他没有任何歉意，还说“我不是故意的”。事实上，当时的场景，因为上一个回合，我在他旁边抢了一个他应该抢到的球，所以他有点恼羞成怒，那个球后，嘴里就在骂骂咧咧，因为我们认识，我并没有说他什么。然后他在下一个回合防守我时，就故意用猛力给我颜色看，是的，我比他自己还确定他是故意打到我的。实际上，跟他玩过很多次，他确实就是这样，打球容易产生情绪，一旦有情绪，便不能控制自己的动作，他的体重有190左右，这种时候他就很危险，我一直都了解，所以上次受伤后，我把他列为打球时的特殊名单—不跟他打。但今天还是忘了，中午回到工位后还是生气，因为发现鼻子开始有一些感觉，自己照着镜子看了许久。后来觉得，也不全是他，自己也有问题。明知他有危险，还要在第一回合后继续跟他对位，别人的情绪你控制不了，那你更应该控制的是自己，控制自己的行为，不要主动靠近这样的危险。另外，别人的道歉或者问候可能会让自己好受点，也只是内心的感觉，并不是实际需要的，而且道歉的人可能并不关心你的感受，别指望他能感同身受，所以道歉与否也并非必要，真的应该多从自己找一些问题去改进，别指望这改变别人，没用。本来不想把这些发出来，但这确实就是自己心里想说的，原谅今天负能量一次。今天还有一个认识的朋友说我公众号写的不错，我心里想，还是别夸我，你看，负能量不马上来了吗~</li>
  <li>PicPlus是一个图床上传APP，帮你快速上传手机图片到各个图床，支持七牛云、阿里云、又拍云等主流图床，此外还支持配置GitHub、码云为个人图床。上传时支持自动压缩图片，以获取更好的上传、加载速度，上传后自动生成Markdown、Html格式链接，方便写作爱好者更好的创作。该APP的主要功能特性介绍支持Github、码云为图床拍照上传图床上传前自动压缩可删除已上传的远程图片批量上传相册图片自动格式化图片链接为Markdown、HTML格式支持通过系统分享上传图片支持自动复制链接支持设置Markdown格式的图片标题支持数据导出、导入，自动备份本地数据支持的图床列表下载酷安市场下载Fir下载使用目前APP支持两种上传方式在APP主界面可通过相册或者拍照上传通过系统分享上传，如下所示，你可以在浏览相册或者文件时，点击系统分享即可把图片上传到图床。关于作者咕咚同学，Android工程师，独立软件开发者，喜欢篮球，喜欢写作，喜欢分享。微博：大侠咕咚公众号：咕咚同学博客：咕咚的个人博客酷安：咕咚你也可以关注我的公众号「咕咚同学」订阅我，我会在哪里每天更新一些自己的日志，也可以通过我博客中的Daily频道订阅gudong.site/daily。</li>
  <li>今晚本来有一个有意思的话题要写，但是我觉得40分钟一定写不完，所以延后几天，写完再发。————————Share———————–今天看到一篇定投相关的文章，作者分享了自己的定投经历，作者定投的基金类型并没有选择大众的指数基金，而是选择了股票型基金，定投周期每月一次，定投策略用蚂蚁财富的智能定投，此外作者还分享了自己的一些定投感悟，点击阅读原文可以跳转查看。关于基金、股票投资，每个人都应该学习了解一下，只是很多时候，不少人起初都是碎片式学习，对基金、股票还没有全面的了解就开始实践，这样的情况下，如果急于操作，好的情况下，可能会赚，但赚不了多少，亏也亏不了多少，更糟的情况下还要赔上一笔。自己从14年接触基金，一直也没有去认真系统的学习过这方面的知识，后来也买过一些理财书，但是也没怎么读，或者就是读不懂，也可能是没找到合适的书吧？直到今年初，看到了知乎的一个基金专栏，《基金：从0开始学基金投资》https://zhuanlan.zhihu.com/fundslearning写的很不错，此外还有一个专栏讲股票，都不错，这里推荐。自己看的时候还整理了一个脑图，如下所示:</li>
  <li>昨晚睡的比较晚，主要是整理笔记以及月总结，本来觉得一个小时可以结束，结果整理完已经是两点了。晚上就是这样，当过了十二点，自己如果没有睡着，往往就会进入越来越清醒的状态。自己今天早晨七点又被叫醒了，所以这一天都觉得比较累，不过偶尔熬夜也还好，晚上的注意力更集中，效率更高。记得刚工作的那两年，经常熬夜，一点左右睡觉是常态。那时熬夜都把功夫花在App上了，现在回过头再看，那些曾经的App几乎已经没什么用了。————————Share———————–前段时间，自己有一个合同纠纷的问题，打算去找律师，结果一直拖延没去找，为什么拖延？一方面自己一直没有找过律师，就觉得找律师这事可能很麻烦，另一方面，事情也不紧急，所以就一拖再拖。这周不能再拖了，必须要找了。原本是想去找一个律师事务所，然后找律师进行咨询确认，后来想先网上找找，毕竟现在很多服务都已经线上化了，律师服务不一定也有，而且合同这事，只要发个照片，然后说明情况，操作过程应该不复杂。后来就真的找到了这样的在线服务。图文咨询一个小时39元，语音咨询69元，后来用图文咨询，选了一个重庆的律师，基本解决了自己疑问。————————Daily———————–俯卧撑：30波比跳：56习惯：7/9本来周末想停一天的，但又觉得已经坚持半月了，别让记录断掉，再说坚持一天也不难，只需要坐下来，打开笔记软件…</li>
  <li>String字符串常量，一旦创建，不可改变。这里的不可改变指字符串对应堆内存，当我们执行字符串的加操作时，实际上是复制被加字符串的内容到新开辟的字符串空间中，原来的作废。String是线程安全的，String类是final类，不可以被继承。String的长度是不变的，适用于少量的字符串操作。StringBuffer字符串变量，长度可变，线程安全。适用于多线程下在字符缓冲区进行大量字符串操作StringBuilder字符串变量，长度可变，线程不安全。适用于单线程下在字符缓冲区进行大量字符串操作字符串操作在执行速度：StringBuilder&gt;StringBuffer&gt;String源码分析基于AndroidSDK26版本分析StringBuffer与StringBuilder共同继承自AbstractStringBuilder，二者基本的方法调用都是使用了父类的实现，子类只是简单包装了一下，区别在于，StringBuffer支持多线程，所以它的操作方法均是同步方法。这里使用synchronized关键字标记方法为同步方法，所以它的效率较低，因为调用同步方法时，首先要去获取同步锁。@OverridepublicsynchronizedStringBufferappend(Stringstr){toStringCache=null;super.append(str);returnthis;}AbstractStringBuilder定义了一个字符数组用于进行所有的字符处理，/***Thevalueisusedforcharacterstorage.*/char[]value;使用默认的构造方法时，会指定初始字符数组的大小为16，如果构造时指定了初始的字符串，那么初始容量为字符串长度加16。publicStringBuffer(Stringstr){super(str.length()+16);append(str);}append方法实现append支持空数据。执行该方法时，会首先检查append的值是否是null，如果是，即参数值为null，这时AbstractStringBuilder会把空值做特殊处理，最终在字符数组结尾追加“null”。privateAbstractStringBuilderappendNull(){intc=count;ensureCapacityInternal(c+4);finalchar[]value=this.value;value[c++]='n';value[c++]='u';value[c++]='l';value[c++]='l';count=c;returnthis;}具体追加字符串时，先会根据要插入字符串的长度，对原来的字符容器进行扩容，然后巧妙的通过String的getChars方法进行数据拼接、追加。publicAbstractStringBuilderappend(Stringstr){if(str==null)returnappendNull();intlen=str.length();//扩容ensureCapacityInternal(count+len);//追加str到字符数组容器中，这里会把str追加到value数组中，count原来字符的数量，在参数中是偏移的值，str.getChars(0,len,value,count);//追加完成后，同步一下count的值count+=len;returnthis;}getChars的具体实现跟System的arrayCopy一样，都是native的实现。toString()不论使用StringBuffer还是StringBuilder，在构造、追加完成后，要使用字符串就必须调用toString方法，跟其他方法的调用不一样。它们的父类并没有提供统一的实现。StringBuffer自己做了优化，它定义了一个字符数组toStringCache，在调用toString时，如果toStringCache已经有值，就简单包装返回，如下所示：@OverridepublicsynchronizedStringtoString(){if(toStringCache==null){toStringCache=Arrays.copyOfRange(value,0,count);}returnnewString(toStringCache,0,count);}toStringCache会在StringBuilder被修改时被置为null。/***AcacheofthelastvaluereturnedbytoString.Cleared*whenevertheStringBufferismodified.*/privatetransientchar[]toStringCache;StringBuilder的toString实现没有用到缓存机制，直接用StringFactory提供的工具方法把字符数组转化为字符串。@OverridepublicStringtoString(){if(count==0){return"";}//也是一个native实现，实际上字符串的很多操作都是通过native操作完成returnStringFactory.newStringFromChars(0,count,value);}String加操作开发中如果字符串需要追加字符串，经常这样操作Stringcontent="hello";System.out.println(content+"world");这里给该字符串添加上world时，也就是String在执行加操作时，首先会先开辟空间存储world这个字符串，然后再开辟空间将两个字符串拼接，也就是说，一个简单的拼接工作，String需要开辟三块空间来完成。注意：以上是不准确的解释。实际上上面说对了一半，在Java1.8之前，确实是上面所说的那样，但是1.8之后优化了String的加操作，在编译运行时会根据不同情况使用StringBuilder或者StringBuffer 进行内部优化替换。这一点在String的源码注释中有说明：所以这样说来，平时为了使用方便，完全可以用+号进行字符串拼接了，没必要用StringBuilder。这也是技术发展的趋势所在，好用、简单永远是主流。总结这篇文章从三者的区别说起，是一个经常面试时被问到的问题，后面主要分析了StringBuilder以及StringBuffer部分源码，算是学习研究。说道最终的性能，经过优化的String其实跟StringBuilder一致，性能都不错，所以开发过程中没必要纠结用String还是StringBuilder，但是前提是你要知道String被优化这个事。关于作者咕咚，Android工程师，个人博客gudong.site，公众号：咕喱咕咚</li>
  <li>关于MVC的定义介绍，摘一段百度百科介绍：MVC是一种使用MVC（ModelViewController模型-视图-控制器）设计创建Web应用程序的模式：Model（模型）表示应用程序核心（比如数据库记录列表）。View（视图）显示数据（数据库记录）。Controller（控制器）处理输入（写入数据库记录）。简单也可以这样理解，View单纯负责UI，如果要更新UI数据，则去调用Controller，让Controller去控制UI，Controller不生产数据，数据层都在Model中，而Controller持有Model层引用，所以它会调用Model层然后接受到数据，接着分发给UI，整个流程就类似于这样。实际上，这就是一种简单的分层机制，不同的层次做不同的事，让代码结构更清楚，各层职责也清楚，不用把所有逻辑写一块，导致代码臃肿，而且复用性也差。在16、17年左右，Android领域大家突然开始讨论MVP，也有很多人讨论两者的区别，实际上，个人觉得MVC跟MVP几乎没啥差别，同样的思想只是换了一个名字而已，ControllerVS Presenter，都是控制器的角色。MVP 为什么在Android中被大家所讨论，最主要的原因还是由于Activity机制。每一个Android开发大都是从写Activity开始，一个界面对应一个Activity，所以一开始业务简单的时候，大家会很容易的把所有的操作逻辑都写在activity里，这很正常，因为Activity就是这么一个机制，Google就是这样设计的。后来软件规模越来越大，Activity中的代码越来越多，代码越来越难以维护，原来在Activity中堆代码的机制就受到了考验。实际上，如果正确利用MVC模式完全可以解决Activity臃肿问题，只不过后来同样用了分层模型去解决问题，但是给这个模型起了另外一个名字—MVP。实际上，MVC、MVP不重要，重要的是去理解正确的软件开发理念。分而治之，各司其职永远都是软件开发的真谛。链接2019-04-19：请谈谈你对MVC和MVP的理解？·Issue#33·Moosphan/Android-Daily-Interview</li>
  <li>强引用StrongReference强引用是最普遍的引用方式。JVM执行垃圾回收时，只要是强引用，该引用占用的内存空间就不会释放。软引用SoftReference如果一个对象为软引用，那么在JVM内存足够的情况下，GC将不会回收它，一旦内存不足，垃圾回收器就会将它们的内存回收。示例：SoftReference&lt;String&gt;sr=newSoftReference(newString("123"));Stringnum=sr.get();//num可能为空，使用时需要判空弱引用WeakReference如果一个对象为弱引用，当垃圾回收线程在扫描内存区域时，发现了它，便会对它进行回收，不论当前内存是否足够。由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。软引用跟弱引用都都可以跟一个引用队列ReferenceQueue联合使用，如果它们为回收，JVM将会把他们放入指定的引用队列中。WeakReference&lt;String&gt;wr=newWeakReference(newString("123"));Stringnum=wr.get();//num可能为空虚引用PhantomReference形同虚设，它无法决定对象的生命周期，如果一个对象持有虚引用，那么它跟没有持有引用一样，在任何时候都可能被垃圾回收。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列ReferenceQueue联合使用。总结android开发的多数场景使用弱引用来解决内存泄漏问题，标记为软引用的对象可以在内存不足是被回收，而弱引用在执行GC时就会被回收，很及时，如果有内存泄漏风险的对象使用了软引用，那么它存活的周期还是比较长的，并不能很好的达到避免内存泄漏的目的的。软引用适合用来实现内存敏感的高速缓存。比如Bitmap缓存，或者在浏览器中前进后退页面缓存。软引用VS弱引用软引用在内存不足时才会回收，而弱引用，只要GC开始扫描，它就会被回收。虚引用日常几乎没用到。具体以上四种区别如下表格所示：通过表格来说明一下，如下：引用类型被垃圾回收时间用途生存时间强引用从来不会对象的一般状态JVM停止运行时终止软引用当内存不足时对象缓存内存不足时终止弱引用正常垃圾回收时对象缓存垃圾回收后终止虚引用正常垃圾回收时跟踪对象的垃圾回收垃圾回收后终止参考链接理解Java的强引用、软引用、弱引用和虚引用-掘金</li>
  <li>最近一直都在听一本书—《软技能：代码之外的生存指南》。这本书很不错，可以说是今年目前看过的对自己影响最大的一本书。该书的内容适合于每一个职场人士，作者以过来人的姿态，从各个方面讲了一个职场人士如何可以做的更好。全书分了好几大章，每一章分为若干小结去讲述大章的主题，主题包含了自我营销、如何学习、生产力、理财、健身等每一个职场人士都会面对的课题。书中的内容非常详实，而且实操性很强，每一篇作者都会告诉你如何去Action，作者自己本身也在实践。目前自己还没有听完，自己感触最深的是他对惯例的理解和应用。每天前进一小步，胜过一天前进三大步，但是三大步后原地踏步不再前进，也就是最简单的龟兔赛跑的故事。实际上也是如此，乌龟这种日拱一卒的做法更容易取得成功，因为正确的习惯会让自己走在正确的路上，而且是每天都在走，随着时间推移，这种力量会不断累计，最终的结果可能会让自己都难以置信。作者拿自己写书举例子。这本书一共八十章节，猛一看，这真的是一个大工程，让任何人去面对这样一个任务，都不会很觉得这是一件轻松能完成的事。但是作者是怎么做的呢？他先列出全书的大纲，分出不同章节，并且定好每一节的主题，接着他给自己规定，每天完成一小节，这样分拆后，也就是说，只要坚持八十多天就可以写完，事实上他也是这么做的。除此之外，他在写书时采用番茄工作法，每二十五分钟休息五分钟，一天又被他切为若干个番茄钟，劳逸结合。实际上这样的方法是一种节奏感。建立了这种正确的习惯后，每一天都在一种规律的节奏中，而处在这种节奏中，每个人的生产效率也会大大增加。如何建立这种节奏感？去年我曾加入一个朋友创建的打卡社区，这个社区主要帮助和督促大家去养成一个好的习惯，主要的方式就是每个人设立一个习惯，然后坚持打卡100天，成功完成的人给一个社区奖状，除此之外当然还有别的奖励。去年我算是成功打卡两个任务，其中一个是每天俯卧撑100个，现在想想这样的习惯养成方式并不科学，因为周期太长，很容易被挫败。我觉得如果要从零开始建立一个好的习惯，不能一上来就要完成100天打卡或者说21天打卡这种，而应该继续缩短周期，设立一个更的小周期去check，我认为一周是一个不错的周期。另外开始设立目标的时候目标不要太大，不要设为七天完成七次，而是小于七次，四次、五次或者六次更好，这样更容易完成，甚至一些任务可以设置一周一次。这样的设计可以让自己更好的获得起步时的信心。除此之外，如果一个小周期可以成功完成目标，可以给自己设定好一个奖励机制，比如电影院看一次电影，或者吃一次炸鸡腿都是不错的选择。————————Daily———————–俯卧撑：30波比跳：40习惯：5/9</li>
  <li>在面试中，HashMap是一个被问到概率很大的一个知识点，因为它本身是一种非常好的数据结构，而且从HashMap中可以引申出数组、链表、红黑树、扩容、优化、线程同步等诸多考点，所以很多的面试官都会从HashMap开始考察一个人的Java水平。好文推荐所以有必要认真研究下HashMap的具体原理，这里我极力推荐一篇16年的文章，出自美团点评的公众号-美团点评技术团队。Java8系列之重新认识HashMap这篇文章非常棒，把HashMap的方方面面都讲了个遍，同时还不缺深度。读罢，对作者这种刨根问底的技术态度也敬佩有加。现在的很多面试中，面试官对技术深度的要求都开始变得高起来，如果你只是知道一些表面的东西，是显然不行的。所以对待技术，深度是一定要要有的，而且这个东西很容易考察。那么一般的面试官会怎么考察你的技术深度呢？这里就以HashMap为例来看看面试官怎么一步步来跟你聊HashMap的。问题来了首先问一个简单的问题作为开始。1、HashMap和Hashtable的区别？前者线程不同步，在单线程条件下操作性能较好，后者线程同步，在多线程条件下可以正确操作，不会发生多线程下的操作问题。2、如何使HashMap线程同步？使用Collections的util方法synchronizedMap就可以让原本不支持线程同步的HashMap支持线程同步。答到这一步，说明你对技术细节掌握的还不错，接着问3、Collections的synchronizedMap方法是怎么实现让原本不线程同步的map支持线程同步的？如果你看过源码，你会这样回答“Collections内部有一个实现了Map接口的SynchronizedMap内部类，这是一个实现线程同步的map类，具体线程同步就是在所有的方法实现中都使用synhronized块达到线程同步，不过具体的方法实现统统使用synchronizedMap方法传递进去map来完成，如下所示@Overridepublicbooleanremove(Objectkey,Objectvalue){synchronized(mutex){returnm.remove(key,value);}}可以看到SynchronizedMap在实现remove方法时最终是用传递进来的map,只不过加了synchronized块，其实这就是典型的装饰设计。”如果你没有看过源码，面试官可能会问题，如果让你自己实现，你怎么实现，其实这里要实现线程同步，终归需要使用synchronized来完成，所以思路还是通过这种装饰设计。当然这里如果看过源码你会说的很轻松。这时如果回答的没问题，面试官想进一步增加深度，可能会问下一个问题。4、如果需要在多线程条件下使用HashMap，除了使用Collections的util方法，还有什么方法可以更简单的做到线程同步？如果此时你能提到ConcurrentHashMap，那么面试官已经觉得你对HashMap的了解有一定的深度。接着再来一个问题。5、ConcurrentHashMap是怎么做并发控制的，相比Hashtable有什么优势吗?此时，你心想『我擦？还有完没完，这要问到地老天荒啊…』如果你此时说『ConcurrentHashMap引入了分段锁的机制，该机制对并发控制做了优化』，那么面试官会点点头，心想『这小伙还不错~』，当然他可能会继续追问，6、你跟我讲讲什么是分段锁？这时即使你对这个概念不清楚，你如实回答，面试官对你印象也不会很差，因为你对一个技术点的了解已经有了相当的深度。当然如果你能就分段锁可以展开跟面试官大聊一番，那最好不过了，不过能问这个问题的，面试官本身应该对这些东西有一定的了解，否则他也不会问到这个问题。到此为止，一个问题算是问完了，同时你也可以看到从一个基本的知识点，可以向下衍生出多少问题。当然我说的这些上面那个链接大都提到了，而且文中汇集的知识点更多更全，建议认真阅读，当你读懂了，关于HashMap的一些基本问题大都能答个八九不离十。如何考察一个Android面试者的能力水平？知乎上@扔物线前辈有一个不错的回答，你也可以顺便看看。面试时，问哪些问题能试出一个Android应用开发者真正的水平？这里，如果上面说的有任何问题欢迎留言指正。总结其实写完文章加上最近的一些经历，个人对技术深度有了一个更清晰的认识，而且自己在很多技术点上确实也有很多不足，不过反过来说，让一个人对每一个技术点都要求有很深的了解也是不现实的。但是如果你在简历上写了你的技能，就表示你对他了解或者掌握，所以你要对自己的简历负责。一般有水平的面试官都会从简历中提取一些技术点，然后像上面那样一点点深入，逐步的考察面试者对知识的掌握程度。这也在印证另一个道理：简历上写自己会的东西或者掌握了的东西，不要粘贴复制别人的模板，否则在面试时会很惨。另外。我还是觉得在实际工作中，面对一个实际具体的问题，应该保持啃透的态度，而不是能通过就行的态度。比如最近你在做应用的启动优化，那么你就应该先详细了解应用的启动过程，以及启动时长统计，然后通过打点或者工具去分析应用启动过程。总之每个步骤自己都应该非常了然于胸。当然，说到容易做到难，更多的道理还需要自己动手才会产生好的结果。</li>
  <li>下雪了，今年冬天的第一场雪，很好看。尽管之前有预报下雪，但今天还是忘记带伞了，不过下雪比下雨有一点好，就是下雪时，即使忘记带伞也可以毫不犹豫的回家，下雨的话，你可能就要想想了。今天本来就要下雪，所以气温并不高，中午也是如此。每周我给自己定了只打两次球的限制，到今天还有一次可打，所以中午即使天气一般，最后我还是去了。去之前，料想今天球场应该是没人的，还想着去随便练练投篮、练练运球罢了，所以连面具、衣服都没带就骑车过去了。等停下车子，准备去一号院公园时，已经听到了别人拍球的声音，那真是最美妙的声音。到球场后原来是两个经常打球的同事，很开心看到他们。后来没一会，又来了一波网易的哥们，等到我刚哥到场时，球场上已经有八个人了，新浪vs网易，已经可以搞一波对抗了。在同事的叫嚣下，那边网易的哥们很快就过来了。他们有明显身高和身体优势，四个人都比我们要粗一圈，高度跟我们相当可能还要高一点。一开始瞎打瞎闹打了十多个回合，对方优势很明显，赢了我们不少。我们这边尽打铁，尤其匆忙赶过来的刚哥，没有热身，投篮那叫一个铁，好在只是一时。不一会，有人说计数吧，打五个球。这下好了，一波打完对方就傻了，秋风扫落叶一般的进攻打的对方措手不及，五比零，对方没怎么持球就已经结束了。果真篮球是一种特别能激发人好胜心的运动。当没有输赢时，大家就会无所谓，但是只要计数了，大家的专注力，决心就会大不一样。实际上，尽管对方身体优势明显，但是由于体重比我们大，他们灵活性就不如我们，而且他们的外线人员没有投篮，所以我们防守可以收到内线。他们内线有身高优势，但是只要在内线打，我们的夹击就让他们非常容易失误。所以后来继续打了两波，虽然对方开始进球了，但是最后都是我们赢了，因为我们这边的外线太准了，对，就是一开始那个铁的不行的家伙。我作为内线基本就是抓篮板了，在进攻端很一般（我是不会说我在防守侧是如何限制了对方一号得分手的），不过养生不也挺好的吗？前三波打完，比分三比零。最后一波打七个球，我们有点累，防守开始松懈，对方抓住机会，内线开始发威，7:2，成功赢回了最后一局。一次愉快的午间活动。————————分享———————–我用了不少习惯跟踪软件，各有千秋，有一个用的最久—循环习惯记录，这是一个开源软件，苹果安卓都支持。产品本身而言，不论功能，界面都极致的简单，我用了很久，期间也是断断续续的使用，但一直没卸载，很喜欢它的提醒功能，它的提醒设置也很自由，只是android手机上使用时最好把它加入系统优化白名单，否则后台运行时容易被误杀。————————Daily———————–篮球：50分钟俯卧撑：30波比跳：63习惯：7/9</li>
  <li>今晚团队内部技术分享，这次轮到我分享了，来到这边后，已经很久没有当众分享了，分享前还是有点紧张，为了不出现差错，提前吃完晚饭就去准备。不过等到真的开始分享后，紧张感却慢慢消失了，尤其是当有人进行提问后，自己就越来越放松了。我比较喜欢在分享的过程中不断跟别人互动，这样整个分享的气氛也会好很多，不喜欢那种一个人从头说到尾的分享，总觉得气氛太压抑（当然这种有互动的分享只适合小团队内部分享，大型的分享活动另当别论）。这次分享的主题是—PythonWeb开发介绍，至于为什么选这个课题，原因有几个:作为客户端开发人员，后端开发是一个黑盒子，如果能了解后端的工作栈，可以让我们更好的与后端人员进行沟通交流。就像一个前端开发者，如果懂一些Sketch相关的技术，那么很设计师沟通起来就方便很多，道理都一样。个人开发者如果想要做一些好玩的东西，比如开发一个网页，或者去网站爬取一些数据等，都需要一些后端技术的支持，如果自己有这方面的经验，就都好办。整个分享的内容，一开始讲了网络编程相关的内容，讲了网络协议，如最重要的TCP/IP、UDP协议，接着讲了浏览器与服务器通讯协议—HTTP协议，后来讲了Python中的网络编程，最后着重分享了PythonWep开发框架—Flask，我很喜欢这个框架，并且用它做了不少有用的事，它很简单，是非常好的Pythonweb框架。另外作为压轴，分享了Leancloud作为后端云引擎的使用。通过使用Flask可以开发Web程序，但是没法解决数据存储问题，当然，我们可以自己购买服务器，自己装数据库56，但是这些事对前端开发者很不友好，很容易出错，往往会因此耽误不少时间，让我们不能把精力聚焦在业务逻辑实现上。而使用了Leancloud后，它可以帮我们把那些事处理的很妥当，大大减少了前端工程师的开发阻力。总体来说，这是这个不错的分享主题，尤其对于做惯了客户端开发，适当来点后端的技术学习，也算是换个口味。另外在准备分享的过程中，自己也有不少收获。尤其是在重新准备网络编程的时候，把相关的知识点再次过了一遍，温故知新，对网络编程也有了很多的认识。这里也感谢廖雪峰的在线课程，不仅仅是网络编程相关的知识，自己一开始学Python也是通过它的文章，很不错的老师。————————Daily———————–篮球：None俯卧撑：25波比跳：56习惯：8/9</li>
  <li>该文章为内部技术分享笔记记录，前半部分参考web开发-廖雪峰，感谢老师的在线课程。该文主要分享Python网络编程的一些介绍，自己开始学Python是从廖雪峰老师的在线教程开始，非常感谢老师的教程。文章后面分享到了LeanCloud，这是一个对前端开发者特别友好的服务，非常值得一试，自己有一个在线服务就是部署在LeanCloud上面，柳叶清单，这是一个网页Todo应用，整个todo服务使用LeanCloud做后端数据引擎，使用云引擎开发网络API，非常方便，感谢LeanCloud。网络编程/通信实际生活中我们用的大部分程序都是网络程序，很少一部分是完全的单机离线程序。计算机网络把所有的计算机连接在一起，在这个网络中的计算机可以互相通信，网络编程就是解决两台计算机之间的通信问题。比如现在打开网页访问微博网页，实际上就是我们的浏览器跟微博的某台服务器通过互联网连接了起来，然后微博服务器把网页内容作为数据返回，通过网络传输到我们自己的电脑。实际上每台计算机上的程序很多，不同程序访问的网络服务器不一样，所以更确切的说，网络通信是两台计算机上两个进程之间的通信。网络编程对所有开发语言都一样，Python也是如此，用Python进行网络编程时，Python程序就在这个进程内，然后跟服务器进程的通信端口进行通信。通信协议一开始的计算机网络，各个厂商都有自己的一套协议，互不兼容，接着为了让大家都可以连接在一起，IBM、Apple等大厂一起制定了一套全球通用协议，现在互联网上有上百种协议，最重要的是TCP/IP协议IP协议负责把数据从一台计算机通过网络发送到另一台计算机，数据会被分割为一小块一小块然后通过路由器发送出去，IP包的特点是按块发送，途径多个路由，但是不能保证到达，更不能保证顺序到达。TCP协议建立在IP协议之上，它负责在两台计算机之间建立可靠连接，保证数据包顺序到达，具体TCP协议会通过三次握手建立连接，然后对每个IP包编号，确保对方顺序收到。TCP建立的是可靠连接，而且通信上方都可以以流的形式发送数据，相比TCP，UDP则是面向无连接的协议，使用UDP时，需要建立连接，只要知道对方的ip端口号，就可以直接发送包，到时能不能到达不确定优点，速度快，对于不要求可靠性的请求，使用UDP。一个TCP报文包括源IP地址目标IP地址源端口目标端口PythonWeb开发什么是Web开发一般的，浏览器请求一个服务器地址，服务器把网页的HTML代码发给浏览器，浏览器显示处理，而浏览器/客户端跟服务器之间的传输协议是Http协议，它是TCP协议之上的协议。HTML是一种定义网页的文本，使用它就可以开发网页了Http协议是网络上传输html的协议，实际上他可传输很多网络文件，Http协议用于浏览器跟服务器的通信。Http协议简单了说，就是请求跟响应，这个如果经常用Charles抓包应该很了解，这里使用Chrome的开发者工具，在线再次验证一下Http请求的过程:Http1.1跟1.0的区别是1.1允许多个Http请求复用一个TCP连接，用来加快传输速度。Http请求过程Web开发的基础协议是Http协议，浏览器发送一个HTTP请求；服务器收到请求，生成一个HTML文档；服务器把HTML文档作为HTTP响应的Body发送给浏览器；浏览器收到HTTP响应，从HTTPBody取出HTML文档并显示。Pythonweb开发Python定义了一套WSGI接口，只要实现这个application接口就可以处理网络请求，defapplication(environ,start_response):"""接口实现:paramenviron:一个包含所有HTTP请求信息的dict对象；:paramstart_response:一个发送HTTP响应的函数。:return:"""start_response('200OK',[('Content-Type','text/html')])return[b'&lt;h1&gt;Hello,web!&lt;/h1&gt;']然后只需要一个WSGI服务器就可以运行这个application，这也是一个标准，只要实现了WSGI服务器标准就可以执行WSGI接口，Python内置了一个服务器实现-wsgiref，具体使用如下所示：#从wsgiref模块导入:fromwsgiref.simple_serverimportmake_server#导入我们自己编写的application函数:fromhelloimportapplication#创建一个服务器，IP地址为空，端口是8000，处理函数是application:httpd=make_server('',8000,application)print('ServingHTTPonport8000...')#开始监听HTTP请求:httpd.serve_forever()执行运行，访问8000端口根目录既可看到Helloweb！字样，这就是一个最简单的PythonWeb程序。FlaskWeb框架上面的程序有很大的限制当请求变多，application方法将无法维护，application中会出现很多的ifelse判断，无法维护html代码不能复杂，真正使用时，这样讲无法处理复杂网页所以就有了Flask开发框架，它通过路由、模板引擎成功解决了上面的问题，实际上类似的框架还有不少。pipinstallflask具体看代码就可以知道Flask如何解决问题：fromflaskimportFlask,request,render_templateapp=Flask(__name__)@app.route('/',methods=['GET','POST'])defhome():returnrender_template('home.html')@app.route('/login',methods=['GET'])deflogin_form():returnrender_template('form.html')@app.route('/login',methods=['POST'])deflogin():username=request.form['username']password=request.form['password']ifusername=='admin'andpassword=='password':returnrender_template('login-ok.html',username=username)returnrender_template('form.html',message='Badusernameorpassword',username=username)if__name__=='__main__':app.run()以上通过@app.route成功解决路由问题，使用render_template成功解决html组织问题，render_template接受两个参数，第一个参数是HTML文件名，这个文件必须存在根目录templete下，第二个参数是模板数据，可选，如果需要动态展示数据，可以传入，如下所示：returnrender_template('todos.html',todos=todos)以上指定了模板和数据，我们查看模板文件&lt;!DOCTYPEHTML&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;todos&lt;/title&gt;&lt;linkrel="stylesheet"href="/static/style.css"type="text/css"&gt;&lt;/head&gt;&lt;body&gt;&lt;divid="container"&gt;&lt;h1&gt;&lt;/h1&gt;&lt;formaction="/todos"method="POST"&gt;&lt;inputtype="text"name="content"/&gt;&lt;inputtype="submit"value="新增"/&gt;&lt;/form&gt;&lt;ul&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;这就是一个简单的Flask程序。但是可以看到，使用了Flask我们的数据还是没法存储，这样的PythonWeb程序算不上真正的Web程序，一个Web程序需要有后端数据支持才行。LeanCloud后端云这是国内一个后端云服务商，让我们可以之关系业务逻辑实现，后端数据存储、程序部署等操作，它都统一处理，不需要我们关心，这大大减少了我们的开发维护工作。它提供了一个云引擎，支持各种主流语言，我们可以选择自己的语言进行后端逻辑处理，它负责存储以及服务部署、运行，对开发者非常友好，具体可查看官方文档。使用它，我们可以快速开发一个个人的Web程序。链接web开发-廖雪峰Flask框架后端云LeanCloud</li>
  <li>上周末爆火的网易裁员事件，网上谈论的文章很多，跟任何热点一样，我们获得的信息可能都是只言片语，或者是一方的片面之词。实际上每个人在陈述事情时都会潜意识的去保护自己，给自己争取更好的位置，裁员那篇文章也是。每当看到这样的事件，一开始就义正言辞的批判可能并不好，说不定就有反转。自己不是当事人，事情发生时间跨度好几个月，很多事情的对错并不好说，中间的是非曲直有时可能连当事人也说不清。而每当这种时候，大家看热闹不嫌事大，最活跃的就是一些大V或者自媒体们，仿佛秃鹫一样，看到狮子放倒了一只野牛，就蜂窝而至，坐等吃肉。接下来各种夸张、煽动性的标题开始出现在各个社区，一场舆论盛宴开始了。盛宴之后，一地鸡毛，作为最需要关心的当事人以及企业薪酬福利等根本性的问题可能并没有获得更好的推进。这是时候，作为个体，应该多从他人经验教训中去学习，反思，找到自己可以做的更好的地方，比如注意身体，买保险，劳逸结合，定期体检等等，而不是像有些人说的，赶紧去注册一个公众号(玩笑）。今天看到一个技术人写的关于网易裁员的文章，写的挺好。他没有直面去谈事件本身，而是讲了一些周边类似的案例，我觉得挺好。文章地址https://mp.weixin.qq.com/s/gSVpeNBYp87EIVw5FDjBrQ————————Daily———————–篮球：None俯卧撑：None波比跳：None习惯：6/7</li>
  <li>每天上班后，不少追求效率的人都会先把当天要做的事列出来，然后放在自己的待办事项里，接着开始一天的工作。我自己也曾是这样。早晨坐下工作前会思考今天有什么事要干，然后一项一项列出来，直到前段时间，我发现一个问题。对于自己，罗列当天要干什么并不容易，还会耗费掉一些时间，为了思考今天要干什么，可能还要去查邮件，看聊天软件等等。往往查看邮件、聊天软件时很容易分心，注意力很容易被分散。所以，自己后来改为每天下班前去计划第二天的待办事项。这样做有如下几个好处：下班前自己很清楚这一天有哪些工作没做完，所以对于确定第二天要做的事很容易，不用过多思考第二天到公司后不用思考今天要做什么，自己知道前一天已经规划好了，内心会更容易接受自己的安排，现在只需要确定最重要的事，然后开始工作。提前一天计划第二天的事，这样可能会让自己的工作更有仪式感，会容易产生一种掌控自己的感觉。经过一段时间的实践，明显减少了早晨进入工作状态的时间。————————–Daily———————–篮球：五十分钟俯卧撑：三十波比跳：五十六番茄钟：两个习惯：5/7</li>
  <li>被markdown绑架的我我喜欢用markdown写文章。它很简单，从开始知道这个标记语法后就一直使用。现在不论在什么平台写作都想着用markdown，但实际上很多大平台还是不支持，比如微信公众号，知乎还有豆瓣都不支持用markdown写文章，甚至连小众的酷安社区也不支持。但是自己就是喜欢，所以想尽办法去让它们尽可能的markdown化，誓与各个不支持md的平台做斗争，用插件、工具去费劲巴拉的进行md转化。这时候我觉得我被它绑架了。markdown虽好，但是如果它们不支持，何苦自己为难自己，硬是要去markdown化呢，完全可以用简单的方式去进行写作。比如我一直用#标识标题，其实用数字也可以，另外可以简化文字的样式，少用样式，重点的地方加粗就可以，等等…任何工具都是如此，工具是死的，它们都是各种规则的集合，但是作为使用者，是去使用它，而不是被它禁锢。工具的根本是为人解决问题，理解它的规则，了解它的不足，再去使用它，最后把它真正的当做一个工具，而不是一种信仰。平淡的周一中午去营业厅买充值卡，到今天没充值卡，白跑一趟，回来时，快到公司了，看到平时拥挤的马路这时却只有零散的车辆，马路变得很干净，配合两旁的写字楼很好看。跟自己和解生活工作学习中，总会出现对自己失望的时候，或因为一个失误，或因为自己的不理智或者愚蠢，总会因为这样那样的错误，让自己深陷泥潭，有时候甚至会开始怀疑自己，怀疑自己的能力，否定自己。这种时候很难受，但是作为成长的一部分，认识自己是很关键的一步，有时应该试着去接受自己的平凡，你只是茫茫人海中的一个人而已，不要对自己太过强求。</li>
  <li>人生很长，事情很多，对于每一个人都是如此。貌似我们总有忙不完的事，做不完的决定和走不完的路，但认真想想，一个人每一天要忙的事，操的心，做的决定，基本都是由人生中两三个比较重要的决定所决定的。个人觉得这几个人生决定意义的决定分别是:上学（大学）结婚买房依次往下，重要性递减。可能有人说出身也有特别大的决定意义，但出生自己不能决定，父母生下了你，能给你的就是最好的。这几个决定或者说事件基本决定了一个人的人生形态，这其中包括社交形态，工作形态，家庭形态等等…所以貌似我们每天都在做选择，做决定，但实际上它们都是大决定、大事件的一个子集而已。对于自己最重要的就是做好这几个大决定。大决定要慎重，深思熟虑，需要花时间，花心思才可以做好。但现实情况下，往往自己还没有意识到这样的决定对自己意味着什么，就因为各种各样的原因，或着急，或无知，或太年轻就草草了事，幻想着一切都是最好的安排，然后三分钟做大决定，再用三年甚至更多时间去买单。人生很长，事情很多，但关键的事就几个。人生是选择题还是填空题？见仁见智，个人觉得它更像是填空题跟选择题的组合。每个填空题下面挂了对应的选择题，而只有填空题做的好，选择题才会做的简单。如何能做好这些对人生影响很大的决定，方法有很多，之前就写过一条—不要慌。</li>
  <li>这个月有儿子的生日，所以双十一就在考虑给他买什么生日礼物，后来决定给他买一个巴斯光年，他是《玩具总动员》动画电影系列中的经典形象之一。“飞向太空，宇宙无限”这是巴斯光年在电影中进入战斗状态时的口头禅，他正义，勇敢，还有点可爱，尤其是他认真起来的时候，当然最重要的是他还会飞，儿子特别喜欢他。儿子特别喜欢我给他讲《玩具总动员2》一开场时，巴斯光年大战索克的故事，给他复述了N遍了，他还是很喜欢听，每次都像第一次听时兴奋。不明白一个故事而已，他们是怎么做到持久保持兴趣的。也许当他们不再对这种重复的故事、动画片感兴趣时，说明他已经慢慢长大了。另外今天提前在屋里给他过了生日，买了蛋糕，送了他礼物（巴斯光年），还炒了不少菜，他很开兴，尤其是看到巴斯光年时。自己还做了一个土豆块炖鱼，其实土豆+鱼的组合，完全是自己上周做鱼时瞎想出来的。那天带着土豆炖鱼在公司吃午餐时，同事看到后，也是非常惊讶的眼光，”这也可以！！“，然后我邀请他尝一口，犹豫了片刻，他还是很给面子的吃了一口，“还不错”，我们相视一笑~优化图床APP，很喜欢Kotlin~今天午后的一段时间，自己用了四个番茄钟，继续把之前的图床App进行了优化。主要是优化了程序中的交互以及展示逻辑，让它更加沉稳。另外还把之前的Java代码都转化为了Kotlin，主要是利用AndroidStudio内置的转化工具。PS:工具挺好用，不过如果是把旧的Java项目转化Kotlin，一定要记得在项目根目录中增加Kotlin的插件支持，自己一开始编译不成功好几次才发现这一点。applyplugin:'kotlin-android'applyplugin:'kotlin-android-extensions'为什么要用Kotlin？我有两个个人App都是用Kotlin开发的，习惯了Kotlin，再用Java就觉得很费劲，另外如果都使用Kotlin，很多代码复用就很方便了。嗯嗯，经过这段时间的优化，图床App已经越来越有模有样了….说说我的阅读量其实目前我并不在意阅读量的，更多的还是督促自己，写给自己看，让其成为一个习惯，不断去记录和思考，然后最好也能带来有用、好玩的信息给关注的用户。![](https://upload-images.jianshu.io/upload_images/588640-2682cc34c44e61cb.jpg?imageMogr2/auto-orient/stripimageView2/2/w/1080/format/webp)昨天公众号文章的自然阅读量为30，尽管这与公众号大V们动辄几万的阅读量相比如九牛一毛，但是相比前几天稳定在十个左右的阅读量，这可是成倍的增长幅度啊。按这个节奏，以后靠广告飞黄腾达，指日可待了。🤣惊魂一刻这一次一定要吹一次坚果云。我的文章一般都是在电脑端的Typora编辑器中完成，然后先用github发布到博客，结果刚刚一不小心给误删了，反复查看了几遍都没有找到，那个心凉啊！怎么说，也是一个多小时的成果。就在这时，我想起了我的坚果云。我的文章是在Typora中编辑，但是本地文章被我同步在坚果云，这下好了，去坚果云网页端成功找到了误删文件，救命啊，必须给坚果云好评，好评，好评…</li>
  <li>今天周五，这周又结束了。年末的需求安排不多，也使得自己有了更多的个人时间，很好啊~停止维护App，备战中考今天在酷安搜索应用，发现这样一个App，完成度还不错，UI也很有特色，这些到不重要，最开始吸引到我的是停止更新一年再一看，理由是要备战中考，中考！！中考？？原来这是一个初中开发者。别人为了开发软件而开始学习，小作者却为了学习而停止开发软件…[摊手]购买付费App是的，自己还没有收到别人的付费，就先花钱买了其他作者的App。为什么要买这个App呢？一方面这个App确实做的确实不错，是同类中的佼佼者；另一方面也算是竞品分析了，体验一下付费流程。这里不说App名称了，免得有打广告的嫌疑，毕竟这里每天也有十多个的阅读量呢~纳尼！！Areyouserious?付费后还发现了一个激活账号时的体验问题，跟作者反馈后，很快便接受了建议。投篮找到了新感觉中午去练球。天气一般，球场就我一个人，围着球场练了好几个回合的运球，胯下。周期性的练习我觉得很有用，现在运球的感觉明显比以前好多了。中间还去了一个大爷、一个大妈，他们坐在球场旁边的凳子上一直看我练球，不知道他们坐在哪里看我大汗淋漓的练球时，心里在想什么呢~自己一直想给自己录一段练球时的视频，然后对照视频矫正动作，今天正好球场就我一人，后来就让正在抽烟的大爷帮忙录了一段，对，大爷放弃了抽烟选择了给我录视频。😊今天的投篮练习非常不错。了解我的人都知道，我不擅长投篮，可以说投篮就是自己的黑洞。我自己也知道原因，主要是自己的投篮不够协调，发力方式不对，但是改变了好久也无济于事。今天在练习胯下运球后投篮，突然觉得自己起球有问题，手肘跟身体是一起跳起来的，实际上，应该先把手肘支起来，然后这样投篮就会省力很多，后来的投篮效果就非常好，🏀到底选哪款？每年这个时候公司都要给员工定制文化衫，公司会设计一些预选样式，让大家选，今年的文化衫长这样~到底要选那个样式，我好难。</li>
  <li>要点不同的CPU架构需要不同的so文件NDK平台不是后向兼容的，而是前向兼容的。ABI的概念，每一个Cpu架构对应一个ABI（ApplicationBinaryInterface，应用二进制接口）。ABI定义了其所对应的CPU架构能够执行的二进制文件（如.so文件）的格式规范，决定了二进制文件如何与系统进行交互。所有的x86/x86_64/armeabi-v7a/arm64-v8a设备都支持armeabi架构的.so文件so（sharedobject，共享库）是机器可以直接运行的二进制代码，是Android上的动态链接库，类似于Windows上的dll。为什么使用soso机制让开发者最大化利用已有的C和C++代码，达到重用的效果，利用软件世界积累了几十年的优秀代码；so是二进制，没有解释编译的开消，用so实现的功能比纯java实现的功能要快；so内存分配不受Dalivik/ART的单个应用限制，减少OOM；相对于java代码，二进制代码的反编译难度更大，一些核心代码可以考虑放在so文件中。x86手机对arm的支持值得注意的是原本x86架构的CPU是不支持运行arm架构的native代码的，但Intel和Google合作在x86机子的系统内核层之上加入了一个名为houdini的BinaryTranslator（二进制转换中间层），这个中间层会在运行期间动态的读取arm指令并将之转换为x86指令去执行。Android系统支持其中不同的CPU架构，ARMv5，ARMv7(从2010年起)，x86(从2011年起)，MIPS(从2012年起)，ARMv8，MIPS64和x86_64(从2014年起)，每一种都关联着一个相应的ABI。参考链接ABI管理 | AndroidNDK | AndroidDevelopers谈谈Android的so|Allen’sZone</li>
  <li>昨天提到了自己的个人图床app，就自己而言，我觉得体验还是挺不错的，使用很方便，尤其是我在手机上频繁传图的时候。今天有人问到了可不可以开放到市场，让大家都用起来，而且可以接受付费。实际上，在我一开始开发的时候我就想过这个问题。我做了不少app，开始的基本都是免费，后来做了咕咚翻译，开放了捐赠，后来还是有不少用户进行了捐赠，很感谢他们的支持。图床app“商业化”？不过捐赠是被动的，而且不可以持久，所以我一直也想做一个半付费的app，就是那种高级版收费的app，后来一直没想到好的点子。直到做这个图床app时，我又想起来了，可以做一个付费功能的app，只是需要多花费一点心思，需要把高级功能做的让大家有付费的意愿。但是付费需要解决后端记账、客户端验证等问题，其实做起来还是有不少工作的（别看着其他人通过app付费赚钱容易，实际上真要做事的时候，还是比较考验人的），后来就耽搁了，直到现在。今天经过他的提醒，我想我是可以做这件事的。付费功能，可以让图床支持多个图床服务，普通用户只能使用一个默认的。另外高级账户的图片记录可以支持云同步，普通用户不支持，等等，暂时就想到这两点（听上去简单的功能实现起来可能一点都不简单）。另外，对于后端付费用户记账问题，可以采用支付宝转账，然后发激活码的方式，然后还需要自己写一个激活码的验证接口，这个做起来其实也还好。实际上今天我已经完成了，使用了LeanCloud的云引擎，LeanCloud真心好。团队技术分享今天团队进行了组内技术分享，是其他同学分享的，分享的主题是屏幕渲染机制，以及滤镜原理。讲的内容还是挺抽象的，并没怎么听懂，不过以后屏幕渲染的技术点可以找同事请教了。其实对于技术团队，每周进行技术分享是很好的事，可以增强技术氛围，也可以拉进彼此的距离，还可以分享知识，开拓视野。下周该我分享了，我已经很久没有写过ppt了，小紧张。XXXL买衣服裤子以后看来不能选xxxl了。小！！今年双十一买的上衣跟裤子都小了，要退货，尴尬…还好，淘宝的七天无理由退货体验很好，自己也是第一次用这个服务，退货很方便…</li>
  <li>中午去打球，天气还可以，没风，跟经常打球的朋友玩了一小时。大家战斗欲不强，不过我倒是玩的很开心，今天再次命中了一个三分，这算是自己这么多年来的第二记三分，影响深刻，😭😭😭。另外，今天还优化了个人的图床APP。我的个人图床APP这两年我经常在手机上写东西，很喜欢Markdown，简单易用高效，一套格式走天下，但是在手机码字时，经常需要插入图片，而Markdown要求必须是远程图片，所以如何在手机上快速传图到图床一直是个问题（Mac电脑上有iPic这个神器）。今年初，自己模仿一个安卓软件—图床猫，给自己开发了一个手机传图工具。毕竟记录日志时，很多图片都是在手机里，所以手机中快速传图到图床对我很有用，我博客的很多图片，都是通过这个手机软件上传的。具体使用时可以在系统相册的分享找到传图入口，如下图所示：然后点击上传到图片图标，一键上传，稍等片刻，图片就可上传成功，如下所示：上传时会自动压缩原图，以便图片保持较小的质量，方便使用。同时，上传成功后自动把图片链接格式化为Markdown，复制粘贴到文章中即可，另外如果是电脑端要使用，则用微信或者qq发送即可，非常方便。不过最近发现文章要发布在简书时图片老是传失败（简书会重传图片到自己的图床），今天一看原来是压缩比太大，导致压缩上传后的图片还是质量太大。今天把压缩比例设置到了70%，同时让app支持自定义设置压缩比，妥妥的。同时还优化了上传成功后的交互，图片改变为全屏展示，之前设计的仅仅是顶部展示，所以图片展示不全，另外用了BottomSheetDialog展示上传成功的结果。社交网络一开始社交媒体是一种自由的沟通工具，是一种新的娱乐方式，而现在你真的很难去定义社交媒体了，你会谨言慎行，一切都变了。社交媒体让人感觉到压力，让人感觉到虚假，很多东西都不真实。</li>
  <li>今天一大早就去国家会议中心，准备参加华为组织的软件绿色联盟开发者大会。大会主要邀请与华为有合作的互联网大厂进行分享，参会的公司不少，有百度，阿里，腾讯还有新浪、美团等。参加开发者大会早晨的大会主题都是围绕开发者。csdn、码云、开源中国的创始人都发表了相关的主题演讲。其中讲到了中国的开源生态。整体而言国内的程序员社区还是非常活跃的，但是问题也不少，比如缺少协作，开源协议意识薄弱等等。个人也很有感悟，国内的开发者众多，但协作意识、版权协议等意识都有待提高，不过整个软件行业都在蓬勃发展，相信以后会好起来。早晨的大会稍微有点枯燥，不过下午的技术分会场干货不少。华为HiAI的首席架构师讲解了华为的HiAI框架，得益于人工智能技术和自家的芯片技术，华为做的很不错。其中讲到了多终端联动，随着未来网络传输能力的大大增强，以及硬件设备能力的不断提升，这真是一个未来可期的技术。后面百度的同学分享了AI在百度App中落地的实践。很强！这两年都在说百度allinAI，但实际上如果不怎么关注的话，是发现不了具体变化的，因为很多技术都在看不见的地方。比如使用超分辨率技术，在手机本地用深度学习等技术对低分辨率视频进行优化，从而大幅提升视频清晰度，一般人可能觉得没什么，实际上这个技术可以为公司节省大量成本，因为客户端要播放高清视频，就必须从云端下载，而下载高清资源就比下载低分辨率视频要耗费更多的带宽。使用超分辨率技术，客户端下载时可以选择低分辨率的视频，然后在手机本地进行超分转化，这样将大大减少服务器的开销。当然具体技术落地情况如何，也无法去验证，但明白了这点你就知道这有多厉害了，还有其他的一些人工智能相关的场景分享，也挺不错。会有有一个感悟，移动端大有可为，就像上面PPT所说的。这几年大家都在说人工智能技术，而且越来越热，貌似客户端技术在越来越冷，但实际上，随着手机硬件能力的不断提升，以及芯片厂商持续不断的对人工智能技术的投入，现在手机硬件上对人工智能的支持也越来越好，今天分享的很多技术都在把人工智能技术转向移动端，这样可以最大限度利用移动设备的运算能力，而且还是本地操作，少了跟云端的连接传输，所以操作效率更高，还减少了对服务器的消耗。于此同时，在手机端处理还可以更好的保护用户的隐私。所以在移动平台上还有很多可做的事。谷歌的TensorFlow，百度的PaddlePaddle都推出了基于移动平台的lite版，所以对于客户端，人工智能会是一个新方向，我们应该拥抱变化，围绕不断发展的人工智能技术去不断探测、挖掘手机端的玩法，提供更好的体验给用户。挤地铁早晨因为要去参会，所以提前去坐地铁，8点左右的地铁，那真叫挤地铁，惨不忍睹，各种惨叫，自己还好往后做了一站，才没被挤的太厉害。相比每天都要高峰期挤地铁的大家，每天可以9点左右才去坐地铁真是太幸福了。午间闲逛早晨的会议后，用餐票去国际会议室负一楼吃了午饭，午饭安排的还挺不错，完了跟同事去鸟巢溜达了一圈，今天的天气特别好，很适合打球啊。</li>
  <li>今天周一，改bug，调UI，单调的一天。午饭后听书，在大厦内部绕着大厦转了好几圈，以后只要中午不打球，就争取转圈听书，这会是一个不错的习惯。另外，这段时间的感悟是，不论听书、看书一定要强制自己写笔记，不论笔记多少。下午空闲时间继续折腾WebDAV。准备把我之前做的稍后阅读升级一下，简单说下稍后阅读是一个什么APP。在手机上浏览各种信息时，有时遇到好的文章可能没法及时阅读，那么这时就可以用稍后阅读APP把文章暂时收到待阅读列表，这样，在自己空闲的时候再去继续阅读，效果可能更好。使用场景很简单，其实不少人用微信的文件传输助手做同样的事，不过我觉得用一个APP管理更好，所以自己就在顺带学习Kotlin时把APP开发了。之前的版本里，APP中的文章数据完全存储在本地数据库，这样只要数据清了，所有的文章就都没了，所以这里需要一个备份机制，用来备份自己的文章。现在计划开发把文章导出为文本文件的功能，然后再用坚果云对备份文件云同步，妥妥的…（未来的高级付费功能？？[阴脸笑]）。写代码时状态很好，又没人打扰，效率很高，但是往往一旦进入这种状态，其他计划好的事情就被自己拖延了，一旦拖延，正常的节奏就可能被破坏。（写这篇日志时，还是强拉着自己写的。为什么写日志）稳定高于一切，工作、生活的节奏都是如此，还是应该尽力去让每天要做的事情形成惯例，这样才可以更好的控制工作、生活的节奏。</li>
  <li>今天去看了《决战中途岛》，精彩，好看。电影从中途岛战争中几个关键人物的角度去叙述故事，故事交代的比较客观，不偏不倚，没有对敌人进行丑化，也没有去特意抬高自己。《决战中途岛》中途岛战役是二战太平洋战争中举足轻重的一场战役。战役是多种势力不停博弈才产生的的结果，这其中的构成因素有很多，其实要要真的看懂，需要去了解一下当时的上下文，比如二战整体局势、日本东亚战争局势等等。从上周起，我就开始去看豆瓣那篇点赞最高的文章-《决战中途岛》万字历史彩蛋全解析~艾默里奇挖的坑，都为你填上，万字长文，我看了两遍，里面比较详尽的介绍了整个电影的背景，以及一些细节，在观影前，看看这篇文章可能观影效果更好。看完电影感触有几点：骄兵必败。日本在偷袭完珍珠岛后，产生了傲慢的情绪，尤其是作战指挥官南云，盲目自信，不考虑美军可能有埋伏的情形，致使在具体作战过程中方寸尽失。相反，美军在经历了珍珠港耻辱后，知耻而后勇，“我要求你在72小时内修复”约克城(航母)”号到可以出击的程度。”，显然美国对战争的准备更充分，上下同心，最终赢得了不可能的胜利。日本科技好厉害。整个战争发生在上世纪40年代初，那时日本就有10艘航母，让美国焦头烂额。对比一下那时的中国，这差距实在太大了。所以，现在想想，为什么一个跟中国云南省差不多大的日本，是怎么在中国予取予求的，就非常好理解了。科学技术是第一生产力，落后就要挨打，永远都是，只有你自己变强了，别人才不会欺负你，才会尊重你。世界局势、人生命运有时就在顷刻间被决定。中途岛战役中有一个非常关键的点，麦克拉斯基在到底指定战场没有发现目标后，继续向北飞行了七分钟，最终发现了南云的航母编队，让两艘航母沉入海底，基本决定了战争走势，这七分钟，改变历史的七分钟。这就是今天的一些观影感悟。龙猫儿子很喜欢看《龙猫》，今天下午准备午休时，他吵着要看熊猫，跟他交流了好几个回合，我才知道他要看《龙猫》。第一次陪他看龙猫还是他两岁多的时候，龙猫也是他第一部能够完整看完的电影，他很喜欢看，尤其喜欢小梅第一次发现龙猫的过程，也很喜欢里面的煤煤球。《龙猫》真是一部非常好的治愈系电影。另外推荐一部特别好的国产动画电影，《淘气的金丝猴》，这是一部80年代的短电影，导演胡进庆的作品，是一部水墨风电影，很有诗意，非常中国风，故事还好看，特别适合小孩看。使用WebWAV操作坚果云今天下午跑通了WebWAV的demo，可以在手机客户端添加一个todo，然后立即把数据同步到坚果云。同时写了一套通用的本地文件同步云端的辅助库，用来操作支持WebDAV的网盘，使用起来很便利，后续可以把它用到我的其他个人app中，这样就基本解决了自己没有存储服务器的问题啦，开心。这里一定要再次感谢下面这个仓库，知道的人都知道这是什么，不介绍了…thegrizzlylabs/sardine-android:AWebDAVlibraryforAndroid周末结束，明天还要继续写case。[药丸]</li>
  <li>今天周末，有孩子了周末就基本围着他转。早晨带他去附近的河边溜达，还带了足球，相比篮球，貌似他更喜欢足球，[摊手]面皮好吃今天老爹从老家带了那边的面皮过来，如下图所示，其他地方都叫凉皮，我们那边叫面皮，而且不一样的是，它比较厚，口感也特别Q，使用小麦粉制作，除了面皮还有面筋，面筋是用小麦粉不停洗才洗出来的。尽管很好吃，但实际上它的制作流程相当复杂，小时候家里也曾做过一次，但外面卖的更好吃，尤其是那些小贩做的醋，特别好吃，可以说是我们那里面皮的一大亮点。总之，如果你去甘肃那边了，除了要吃拉面，你真的不应该错过面皮。香港最近香港问题网络上说的都比较多，有不少文章分析的很好，比如姚尧写的这篇的，但也有一些博主为了蹭热点而蹭，对香港没有足够的了解，就开始无脑喷，让人觉得很可笑。关于这样的国家问题，大多数人能看到的都很表面，具体的问题不能单靠社交媒体获得的信息就去批判，很容易不客观。我的观点：如果你没法去hlod住这样的话题，就别去发表相关的意见，真想去发表，那就先去安心研究一段时间再说，有感于最近某些博主为了蹭热点而发表的香港言论。止暴制乱，恢复秩序。认准官方信息动态.独立思考我从18年底起在微博关注了一个大V，他从一开始的基础工作做起，后来做到了天使投资人，自己一路摸爬攻打，算是靠自己赢得了成功。那时他在微博上的言辞很犀利，涵盖的内容包括但不限于投资，对很多事他总能有不一样的观点，让人暗暗称赞，他总说，在信息爆炸的当下，每个人应该保持独立思考的能力，这样你才不至于被信息淹没。受到他的影响，我那时开始关注投资相关的一些事，但是他说的独立思考对我影响更大。实际上，独立思考，这是一个说起来容易但做起来很难的事。这种能力有些人本来就有，无需练习，有些人则需要额外的努力和练习才能习得。对此我认为，独立思考能力应该分两个步骤，首先，第一步应该是先要开始去思考。对，就是是先思考。其实现实中遇到的很多事，很多问题，不少人根本都不去思考，囫囵吞枣，盲目从众，对于稍微复杂点的问题，很轻易的就给自己一个答案，这是很不可取的，至于原因，我觉得首要因素应该就是懒惰，人性中的懒惰，接下来可能是无知。(PS:说到这里，自己也很惭愧，因为自己也会如此。这里与君共勉，共同克服这种思维上的懒惰)一个人如果都不去思考，何谈独立思考。所以凡事都应该先去养成思考的习惯，对自己相关的事，如果不明白，不要从众，去学习，去做功课，去查资料，然后再去分析、思考，这才是一种科学的态度。另外，我认为写作是非常好的培养思考能力的方式。</li>
  <li>今年打球的频率应该是工作后最高的一年。在夏天的时候，经常性的一周会打四、五次，一般都是中午或者晚上去公司附近的球场，那个球场离公司近，球场也不错。也许是因为打球频率太高了，终于还是把鼻子骨折了，很意外。后来打球少了，同时也带了面具，打球时也小心多了。篮球打的多也不好。但是一直以来对打球频率也没有好的限制，同事只要叫了就总想去玩会，所以前段时间特意加了限制，一周最多只能打两次，否则会有惩罚（具体以后在说），现在每周开始时，都会去看十五天天气预报，决定哪天去。这周一天气不错去了，周二其实也不错，但是连续两天不好，所以今天便去了。今天天气比较凉，球场就我一个人，尽管天有点凉，但是玩了一会就很热了。练习了运球，投篮，后来同事来了，跟他一起单挑、比投篮，这样玩玩挺好的，不一定要分组打波。另外，经过了一段时间的胯下运球练习，现在单挑时可以结合运球节奏正面突破，这正是自己一直想学的东西，之前都是各种篮下技术。写测试case，很痛苦，主要是这东西大家并不重视，做好了对质量保证很有效，但是现在高不成低不就，难受。我有好几个个人APP，数据有些在本地，有些在云端（LeanCloud）。之前在用一本日记这个APP时，知道了WebDAV这个东西，然后一直种草到现在，而LeanCloud数据也有一些限制，所以最近一直想试试WebDAV，这样就可以把网盘当做数据中心，这是更好更稳定的数据存储方式。今天下午工作状态不好，便稍微研究了一下，在自己的APP中小试牛刀，挺好，很方便。这里分享一个AndroidLib：sardine-android:AWebDAVlibraryforAndroid用它可以很方便的操作那些支持WebDAV的网盘，一行代码搞定用户身份认证，具体周末用用再说。Happyweekend~</li>
  <li>这一篇文章主要记录AsyncTask相关的知识点。大部分内容来自官方文档，AsyncTask|AndroidDevelopers什么是AsyncTask通过使用AsyncTask，我们可以正确、简单的在UI线程中操作耗时任务，并可以处理任务的进度以及任务结果。整个过程，我们不需要关心任何线程、Handler相关的操作，它对它们进行了封装。//AsyncTask被设计为一个围绕线程和Handler的帮助类，而用来处理任务，但它并不构成一个通用的线程框架。理想情况下，AsyncTask应该用于短操作（最多几秒），如果线程需要长时间执行，强烈强烈建议使用java.util.concurrent包提供的各种API，如Executor、ThreadPoolExecutor和FutureTask。检查为什么要短操作AsyncTask被设计为在后台执行任务，而在UI线程处理任务进度和任务结果。异步任务由3个泛型类型（称为Params、Progress和Result）和4个步骤（称为onPreExecute、doInBackground、onProgressUpdate和onPostExecute）定义。任务执行顺序从一开始，异步任务是在单个后台线程上串行执行的。从AndroidDONUT（1.6）版本开始，被设计为线程池执行模型，多任务可以并发执行，从AndroidHONEYCOMB（3.0）版本开始，任务在单个线程上执行，以避免由并行执行导致的常见应用程序错误。如果真的想要并行执行，应该使用线程池的executeOnExecutor方法。也就是说AsyncTask不建议执行并行任务，它目前只支持任务串行操作，这样做的目的是为了保证多任务并行操作会导致的潜在问题。就目前来看，Android的主流版本已经是5.0以后的系统了，所以几乎可以不用关心因版本而异的执行顺序，开发中用到的AsyacTask都是串行执行的。</li>
  <li>番茄工作法挺好，昨天已经说了，所以昨晚我已经规划好了第二天的事项。不过，事与愿违，今天一整天我却只完成了一个番茄钟，那今天到底发生了什么呢…昨晚马上就要睡觉了，微信群里开始报bug，还是线上问题，那个揪心！！然后开始查bug、找原因，跟同事一起合力找问题，最终找到了原因以及解决方案，那已经是两点了。所以今天大部分的时间都是在跟这个bug纠缠，今天的番茄计划也就泡汤了，直到下午才勉强完成了一个番茄钟，很惭愧…然后今天就发了一条的热修复patch，年底将至，发patch可不是好事。到微博后这是第二次发patch，最近这一年多的时间内，我都没有踩过这种坑，也没有触发过大问题，但是黑天鹅事件就这样发生了。得到的教训就是:对待代码要严谨，尤其是那种底层调用，不论多小的改动，都要确保明白改动的上下文，以及使用影响。开发遇到bug是常态，我认为对一个团队来说，快速解决bug是一种必备的能力，但是更重要的应该是在不断处理问题过程中，逐步去健全发现bug、减少bug的体系。这包括自动化测试case、代码review机制、以及一切其他的工程手段。bug永远有，而一个好的开发体系可以最大限度的降低出bug的几率。打算给公众号换一个名字，但是目前还不知道用哪个。一开始公众号的名字跟我的微博账号一样—大侠咕咚，后来被自己改成了现在的咕喱咕咚，我认为这个名字并不好记，也不好读，现在想换回大侠咕咚，跟我微博名一致。同时还想到了其他可选的名字咕咚的日记本咕咚的小本子咕咚Daily纠结中…😖OK，今天就这样了，明天要继续我的番茄工作计划。还有，明天中午可以去打球🏀啦~开心​~</li>
  <li>最近一直都在听书，《软技能-代码之外的生存指南》，昨晚在听关于生产力的章节，其中作者讲到了番茄工作法。之前对此也稍有了解，但是并没有用过，这次听完后决定在今天工作时实践一次，这也是作者所推荐的，要立刻Action。今天第一次尝试效果还不错。早晨完成了三个番茄钟，下午完成了四个。其中五个均是工作任务，有两个是个人业余的任务。执行过程中有一些打断，这也是工作当中执行番茄钟必须要面对的，我觉得自己处理的并不好，后面继续改进。关于执行番茄钟有什么感受，我觉得感受还挺深刻的。之前工作中对于完成任务的时间是没有计量的，现在使用了番茄钟后，现在对今天的任务用时就很清楚。比如今天要修复编辑微博时的一个bug，这个任务是今天优先级最高的任务，早晨开始便使用番茄钟监督执行，一开始我预计用一个番茄钟的时间（25分钟）就可以，结果最终花了两个番茄钟，后来还花了其他的时间，要算真实时间的话，最终这个任务应该花了有三个番茄钟的时间，也就是75分钟。看，如果像往常那样，不使用番茄钟计时，这个任务的耗时自己是完全没把握的，这就是番茄钟的好处之一，让自己对时间计算更加精确。另外，使用番茄钟还有一个好处就是—Focus，在那25分钟内，自己主要就做一件事，不关心别的事，其他事可以安排到其他的番茄钟，所以内心更踏实，另外5分钟的休息时间内，自己也可以很放松的去看会手机或者刷微博，内心没有负担。以上就是自己对番茄钟的两点认识，后续继续实践，希望可以更好的利用番茄钟。具体我用的APP是番茄todo。在今天午饭前，自己用了一个番茄钟的时间把芽庄旅行记录的文章做了补充。文章是昨晚夜里写的，回顾记录了10月份去芽庄的旅行记录，昨晚由于没有带当时拍照的手机，所以今天主要就是补充了一些照片，重新读了一遍文章，修改增加了部分文字，想要查看我的芽庄之旅文章可以点击文末的阅读原文。下午练习一道Python算法题时，我需要用PyCharm编辑器，但是打开后却发现它需要激活才可用，否则只能用30分钟，便会自动关闭编辑器。然后自己下意识的去搜了下激活方法，都很麻烦。不过稍微想了下，30分钟，不是整好是一个番茄钟的时间吗，那我干脆把它当做一个番茄钟来用岂不很合适，30分钟不长不短，对练习一道题来说，时间刚刚好，到时间了自动提示我关闭编辑器，有意思。我一直有个习惯，每天去记录当天发生的事、或者一些感悟。之前都是记在博客或者日记软件，时而记时而不记，最近有个想法，想把这些内容发表出来，发表在这里，一是督促自己更严谨的措辞，二是将自己的一些想法分享出来，不管有没有人看，不重要，关键在于磨砺自己、不断去输出一些内容。点击阅读原文查看我的芽庄旅行记录。</li>
  <li>每年小组都要组织一次团建活动，之前去过一次黄山，去年去了古北水镇，这次选择了更远的地方，越南-芽庄。出发时间定在了十月中旬，我们一共十个人，让其中一个小伙伴专门处理行程安排，包括机票、酒店、攻略等，整个旅程下来，都安排的很好，特别棒，浩导威武。第一天—启程10月17日从北京首都机场出发，到广州白云机场中转，然后再转到芽庄金兰机场。出发那天早晨，由于对第一班地铁时间判断有误，差点耽误自己上机时间，还好同事及时的提示，让我提前通过南方航空APP在手机上办理了电子登记牌，到机场后，我没有去取票，直接用手机便办理的登机，非常方便。中午达到白云机场，算是自己第一次去广州了。从天空上看下去，广州那一片好大，北上广，现在还差上海没去过了。在广州停留了近两个小时，大家都去免税店买东西，我对此并没有什么兴趣，倒是发现休息区有一个很大的乐迪模型，不少小孩在玩，然后跟儿子视频了一会。下午准时从白云机场出发，开始前往芽庄。自己的第一次出国，还是有点小激动。很好奇降落后会看到什么，那会是一个怎样的国度。（我在去往芽庄之前，几乎没有做任何越南的功课，对芽庄也是没有任何了解。）广州到芽庄，中间大部分距离都是在海上，一望无际的海面，让人心旷神怡，高空的卷积云也特别漂亮，中途还经过了好几个珊瑚礁，非常好看。终于要到达芽庄了。在飞机下降前的一段时间里，看到了很多芽庄的海岛，海岸线，海水很清澈，坐在飞机上迫不及待想要去大海旁边看看。下飞机后过海关，其中一个同事因为购买免税店价格超过了限定额度，被海关耽误了一段时间，最终还被扣了八百人民币。😢下车后，酒店派了专车来接送，到达酒店已经是6点左右了。酒店就在海边，是海景房，特别棒，站在阳台满眼都是大海，然后坐在靠背椅上就可以尽情享受大海了。海边城市的气候跟北京差异很大。那边比十月的北京热多了，到也不是北京8月份那种酷热，这里的空气很潮湿，自己打开阳台看海景的时候，不一会儿就觉得全身汗毛都布满了一层水汽。酒店安排好，收拾完衣服，晚上去了附近的一个club去吃饭，这家消费水平有点高，吃的还可以，口味偏西式，席间还用蹩脚的英语跟服务员要了一杯水，实际上，我完全可以说中文的，那边的人对中文也比较熟悉，最后下来每人大概100多人民币的水平。自从到芽庄，就一直断断续续的下雨，吃完饭回来也是，还好我们都带了伞。吃完饭去了那边最大的超时购物。东西一点不便宜，甚至比国内贵，不过那边的水果好吃，喜欢吃10元一盒的芒果。第二天—教堂+庙+海角+大餐这是旅程正式开启的第一天。从到这里后一直在房间里看海浪，第二天迫不及待的去了海滩，近距离的感受了海浪，很舒服，不少人在海浪里玩耍，我就一直沿着海岸线散步。正式出发前，还去附近兑换了当地的货币-越南盾。10000越南盾=三元，兑换完，瞬间就成了百万富翁。这一片先是去了当地的大教堂，这是以前芽庄被殖民期间，法国人帮忙修的，教堂是哥特式风格，我看的不是很懂，也就只顾着拍了几张照。紧接着去了另一个景点-婆那加占婆塔。这是一个建在小山上的庙，看上去建筑很敦厚，颜色都是橙黄色，很有识别力，我很喜欢这个颜色，里面还有很多陶瓷制品，以及小雕塑，令我意外的是，我发现了太极的图案。接着又去了一个海角-钟屿石岬角。人并不多，哪里有很多大石头，海浪一遍遍的拍打着石头，海水被拍打的好高。晚上去附近找了家海鲜大排档，点了三大盘，特别好吃，吃的非常满足。第三天—晨跑+岛屿+飞艇这个早晨，我早早就起床了，自从看了马特达蒙的谍影重重后，就一直想在海边来一次晨跑，所以这次一定要去海边跑一次步。自己沿着海岸边跑边走，大概跑了有两公里，跑到了一个码头，这里有一些当地人在钓鱼，貌似海里的鱼不好钓。我站在这里停留了一会，拍了不少照片。看着海水一遍遍的涨起来落下去，我留下了自己的痕迹。咕咚来了~晨跑完回到酒店，跟大家吃过酒店提供的自助餐，我们正式开始第二天的出行了，这一片我们要去海岛钓鱼、潜水、浮游。大家包了一个船，然后向海岛出发了。我并没有钓到鱼，但是大家还是有收获的，其中一个同学就钓到了河豚，生气时的河豚好可爱，还钓到了小石斑鱼，最后也都放生了。然后又去潜水、浮游。我并不会游泳，所以这个过程比较无聊，一直穿着救生衣在甲板上走来走去看风景，玩手机。也许是因为北方人的缘故，我一直怕水，对此也没什么好说的。后来去了另一个海岛的沙滩玩，沙子很好，水质也特别好，很漂亮的海岛。晚上吃了大龙虾、海鲜，一如既往的好，另外他们炒的油麦菜尤其好吃啊，回家后想试着做，再也没有那个味道了，过了那个村，就再也没那个店了。第四天—珍珠岛+动物园+摩天轮珍珠岛，这是一个很棒的地方。一早我们就出发，排队进去的过程很漫长，我问了前一天的导游，他说现在不是旺季，所以现在这个排队的规模并不大，还算好的，然后排了差不多一小时的队，我们坐着缆车终于到到达了珍珠岛。这是一个很国际化的游乐岛。上面有很多城堡、游乐设施，很多东西看上去都很新，应该是这两年才开放的，城堡看上去很漂亮，有欧洲的感觉，里面的设施也很现代化，只不过吃饭的地方少，最后没得选，只能吃炒米饭。另外，这边的鸟、鸽子真是一点都不害怕人，我们在餐厅里吃饭，鸽子就在我们桌子底下，钻来钻去的，真是人与自然和谐相处。这里比较好玩的是单人滑行山车，排队的人很多，我们排了好久，先是用机器把你拉上去，然后自己控制小车速度下山，很刺激。下午完了海盗船还有直上直下的高空游戏，很刺激，完后继续上山去看动物园。这个动物园在芽庄很出名，貌似是这里的第一个。动物园很不错，有河马、犀牛、狮子以及最让我们惊喜的火烈鸟。整个动物园都被绿色包围着，而且也没有难闻的气味，真的很想多看一会儿。最后去了那个号称亚洲最大的摩天轮，我们三人一个厢子，那时已经黄昏了。夜幕降临时的芽庄很漂亮，灯光闪烁，很有生机。愉快的第四天结束了，整个行程也就接近尾声了。晚上回去去超市里购物，买了不少干果，最后发现只有芒果干比较好吃，其余的味道一般般。第五天—启程回京早晨我起了大早，去海滩的上面去游荡，发现这边很多人都有早晨去海里游泳的习惯，我看到不少人骑着摩托到海边去游泳，然后再去上班，还看到了不少人在哪里锻炼身体，只不过看到的大部分人都是中老年人，年轻人并不多。接着回到酒店收拾完东西，跟室友一起吃了自助餐，自助餐还挺不错，有煎鸡蛋还有面食，每天早晨都吃的很饱很满足。酒足饭饱，启程回家。其他关于越南对比中国，这边基础建设还是比较差的，道路、支付方式、教育等也是如此，不过他们起步比中国晚，可以理解。于此同时，我记得之前微博上有人在越南投资房地产，这里发展潜力还是不错的。对于芽庄来说更是，这里有非常好的旅游资源，如果这边的政府能正确的引导、发展，这里应该会越来越好。这边交通工具主要是摩托，马路一半留给汽车，一半留给摩托。在这里能开汽车的人就是富裕家庭了。手机用的还是华为、三星、vivo的多，苹果有钱人才能用得起。这边购物几乎不支持支付宝、微信。这方面有点差，一个亚洲旅游城市，中国游客这么多，但是支付方式却还停留在纸币，这是之前没有想到的。这次行程这次大家玩的很开兴。在这个陌生的地方，很多事物可以很容易的引起大家的注意力，不一样的环境，不一样的体验，对我而言，我很喜欢有海有水的地方，这次旅程极大的满足了我。另外这边的吃的，尽管风格跟我们完全不一样，但是味道真的不错，除了他们在沙拉里老是放一种味道很怪的草，其余的我觉得都挺ok的。​</li>
  <li>枚举是JDK1.5推出的API，以前经常用静态常量用作类型区分，枚举则是对类型的一种强化，且有更好的语义性，恰当的使用它可以写出非常优雅的代码。使用枚举在没有枚举之前，定义不同类型，常常用静态变量进行定义，如下所示要定义颜色的类型：publicstaticfinalintTYPE_RED=100;publicstaticfinalintTYPE_BLACK=101;有了枚举之后，便可以像下面这样写enumColor{RED,BLACK}开始使用时两者区别并不大，如下所示，在其他类里有一个draw方法，需要传递颜色类型的参数进去，//使用静态变量voiddraw(intcolor){prepareDraw();if(color==TYPE_RED){paint("#f00")}elseif(color==TYPE_BLACK){paint("#000")}finishDraw();}//使用枚举voiddraw(Colorcolor){prepareDraw();if(color==RED){paint("#f00");}elseif(color==BLACK){paint("#000");}finishDraw();}初看，区别并不大，只是枚举看上去语义性更好，更容易阅读，这只是枚举的一点好处。枚举的本质实际上，枚举的背后是一个类，跟正常的对象一样，它支持构造方法、它可以实现接口、它可以继承抽象类，它就是普通的类，这里只是Java把这些都包装了起来，所有的枚举实例都继承自Enum这个抽象类，如下所示：publicabstractclassEnum&lt;EextendsEnum&lt;E&gt;&gt;implementsComparable&lt;E&gt;,Serializable{privatefinalStringname;privatefinalintordinal;}所以这里要明白一点，枚举拓展了类型，一般的普通常量就是一个常量，它没有方法，没有属性，是死的，但是枚举让类型活了，它让一个常量类型可以自己去控制一些行为，扩展了类型的边界，让它面向对象，具有了类的特性。比如现在就可以用枚举的特性去优化上面的代码。我们可以使用枚举的构造方法在构造枚举时就指定颜色值，如下所示：enumColor{RED("#f00"),BLACK("#000")publicStringmValue;publicColor(Stringvalue){this.mValue=value}}于此同时，原来的draw方法就可以变得更加简洁：voiddraw(Colorcolor){prepareDraw();paint(color.mValue);finishDraw();}另外，还可以更进一步，直接让枚举自己实现paint方法。enumColor{RED("#f00"),BLACK("#000")publicStringmValue;publicvoiddraw(){paint(mValue)}}然后在调用处，直接调用枚举实例的方法即可，更加简洁。这里已经可以看到枚举的便捷性了。它面向对象，以前很多使用静态常量的时候，好多ifelse语句都可以更加友好的处理掉了，枚举还有其他好玩的地方，总之用它的时候，就把它当做一个正常的类，可以各种操作。什么时候该用枚举一般情况下，如果只是要用常量进行类型定义时，完全没必要用枚举，有点大材小用，比如要定义简单的类型：enumType{Noraml,Big,Small}这种情况下用整形常量就够了，枚举只是让语义性变得更好。而如果定义的常量类型有一些模板化操作的逻辑，就可以考虑用枚举，将模板方法实现在枚举中，从而简化自己的类型定义。例如我之前开发过一个翻译软件-咕咚翻译，它支持不同的翻译引擎，每一个翻译引擎都自己的名称、请求路径以及对应的实体类，那么用枚举来定义翻译引擎的类型就最合适不过了，如下所示：publicenumETranslateFrom{BAI_DU("百度","http://api.fanyi.baidu.com/",ApiBaidu.class),YOU_DAO("有道","http://fanyi.youdao.com/",ApiYouDao.class),JIN_SHAN("金山","http://dict-co.iciba.com/",ApiJinShan.class),GOOGLE("谷歌","http://translate.google.cn/",ApiGoogle.class);publicintindex;publicStringname;publicStringurl;publicClassaqiClass;ETranslateFrom(Stringname,Stringurl,ClassaqiClass){this.name=name;this.url=url;this.aqiClass=aqiClass;}}具体源码地址非常优雅，有木有~另外在开发过程中，从思维上不要把枚举更静态常量挂钩，枚举有更广阔的使用场景，完全可以放开思路去用枚举。任何有模板性质的类，都可以考虑用枚举。枚举的替代写法如果整形静态常量看上去有点弱，那么JDK1.5之后提供的自定义注解，这里可以用它去优化。通过自定义注解限定类型的可选值，如下所示，借助IntDef来定义类型自定义注解Color.publicclassMain{@IntDef({RED,Black})@Retention(RetentionPolicy.SOURCE)public@interfaceColor{}publicstaticfinalintRED=0;publicstaticfinalintGREEN=1;publicstaticfinalintYELLOW=2;}那么后续在传参数时就可以用Color注解去限制参数的传入值。voidpaint(@Colorintcolor){}更多注解相关的介绍，看参看技术小黑屋的这篇文章。枚举混淆注意事项在开启混淆的情况下，如果不做任何keep，ProGuard会把枚举类的方法名进行混淆，而应用运行期间，枚举类有两个方法会被反射调用，所以在Proguard规则中需要对其进行保护，如下所示：-keepclassmembersenum*{publicstatic**[]values();publicstatic**valueOf(java.lang.String);}Android中是否应该使用枚举这曾是一个谈论很多的话题，对此我写了一篇文章分享自己的观点，具体查看Android开发中是否应该使用枚举？|咕咚总结本文阐述了个人对枚举设计的理解，它是一个很好的设计，在特定的场景下，尤其是那种针对类型有模板化操作的的情况下，使用枚举可以让代码更优雅，另外也记录了枚举的替代写法以及混淆代码时枚举的注意事项。参考链接Android中的Enum到底占多少内存？该如何用？|YetAnotherSummerRain</li>
  <li>本文由咕咚发布在个人博客，转载请注明出处。本文永久地址：https://gudong.site/2019/11/04/use-enum-or-not.html在Android官方文档推出性能优化的时候，从一开始有这样一段说明：Enumsoftenrequiremorethantwiceasmuchmemoryasstaticconstants.YoushouldstrictlyavoidusingenumsonAndroid.意思是说在Android平台上avoid使用枚举，因为枚举类比一般的静态常量多占用两倍的空间（如果你还不了解枚举，参看文章枚举介绍以及枚举的本质。）由于枚举最终的实现原理还是类，在编译完成后，最终为每一种类型生成一个静态对象，而在内存申请方面，对象需要的内存空间远大于普通的静态常量，而且分析枚举对象的成员变量可知，每一个对象中默认都会有一个字符数组空间的申请，计算下来，枚举需要的空间远大于普通的静态变量。具体分析可见这篇文章。所以，照此来看，在Android这样对内存寸土必争的平台上，如果只是使用枚举来标记类型，那使用静态常量确实更优，但是现在翻看官方文档发现，这个建议已经被删除了。为什么官方会删除？难道是之前的建议有错误吗，或者描述的不够精确？个人认为，枚举占用空间比普通类型的静态常量大，这是事实，没问题，但是据此就建议不在Android中使用时不妥的，具体看JakeWharton在reddit上的一个评论。Thefactthatenumsarefullclassesoftengetsoverlooked.Theycanimplementinterfaces.Theycanhavemethodsintheenumclassand/orineachconstant.Andinthecaseswhereyouaren’tdoingthat,ProGuardturnsthembackintointsanyway.Theadvicewaswrongforapplicationdevelopersthen.It’sremainswrongnow.最重要的一句是ProGuardturnsthembackintointsanyway.在开启ProGuard优化的情况下，枚举会被转为int类型，所以内存占用问题是可以忽略的。具体可参看ProGuard的优化列表页面OptimizationsPage，其中就列举了enum被优化的项，如下所示：class/unboxing/enumSimplifiesenumtypestointegerconstants,wheneverpossible.既然ProGuard会把枚举优化为整形，那是不是在Android中，就可以继续无所顾忌的使用枚举了呢？😊并不是！！！ProGuard对枚举的优化有一定的限制条件，如果枚举类存在如下的情况，将不会有优化为整形，如下所示：枚举实现了自定义接口。并且被调用。代码中使用了不同签名来存储枚举。使用instanceof指令判断。在枚举加锁操作。对枚举强转。在代码中调用静态方法valueOf方法。定义可以外部访问的方法。参考自：ProGuard初探·dim’sblog，另外，上面的这七种情况，我并没有找到官方的说明，如果有哪位读者知道，请在评论区里留下链接，谢谢啦~也就是说，要保证枚举能被正常优化为整形，就要确保枚举足够简单，如下所示，这些情况下的枚举都是可以被优化的enumColor{Red,Black,Green}或者这样的enumDate{Sunday("星期日"),Monday("星期一"),Tuesday("星期二"),Wednesday("星期三"),Thursday("星期四"),Friday("星期五"),Saturday("星期六");publicStringvalue;privateDate(Stringvalue){this.value=value;}}但是再次查看那七条规则，会发现这几个规则几乎把枚举面向对象的特性都限制了，在这样的限制下，枚举好用的地方都将消失，失去了枚举的灵活性。到这里就有点矛盾了，枚举很好用，ProGuard也会对它进行优化，但是优化条件限制了我们更好的使用枚举，那我们应该怎么面对这种情况，我的几点建议：对于简单的使用场景，比如Color、Week这种，枚举有更好的语义性，可以优先使用枚举。一些时候使用枚举可能无法避免上面七种情况的，权衡易用性和性能以及使用场景，可以考虑继续使用枚举，因为枚举在有些时候确实让代码更简洁，更容易维护，牺牲点内存也无妨。至于Android为什么会把那条优化建议删掉，我认为官方也是考虑到了枚举会被优化为整形这一点，所以才去掉的。然后实际工作中具体怎么使用，官方就不在说”avoid“了，而是让开发者自行决定是不是使用枚举。以上就是关于[Android开发中是否应该使用枚举？]这个问题我的一些思考。参考链接Android中的Enum到底占多少内存？该如何用？|YetAnotherSummerRain关于Java中枚举Enum的深入剖析-技术小黑屋should-i-strictly-avoid-using-enums-on-android“YoushouldstrictlyavoidusingenumsonAndroid”:androiddevProGuard初探·dim’sblog</li>
  <li>Warning：本文有轻微剧透这是一部以校园凌霸为主题电影，跟《我不是药神》有一个共同点，他们都围绕一个社会现象，相比仿制药，校园凌霸大家可能更熟悉，毕竟大家都是从学校走过来的，对校园欺凌多少有一些了解，甚至一些人可能以前就经历过，所以观影时的代入感更强。电影关于高考备战、考试时的纪实镜头，可以很容易的让人想到曾经鏖战的岁月。每天披星戴月，面对各种功课的习题、试卷，应接不暇，无止境的划草稿，做辅助线，写化学方程式，上课、下课、吃饭、晚自习，每天满负荷的运转。直到一声巨响，不堪受辱的高三学生胡小蝶，从高楼坠下，自杀身亡，整个故事才徐徐铺开。电影的故事性很强。其中好多不连续的片段进行穿插，让人一开始会有点摸不着头脑，但是整体思路清晰，里面交待的故事都很简洁，很多角色的台词很克制，感觉是导演的刻意为之，让观众自己去体会那些留白。尤其是描绘两个青春期男女主角的感情时，这种蜻蜓沾水式的对白显得特别冷峻、反派，很符合那个年龄时的心理特征。电影值得称赞的地方还有很多，但是也有不少地方有待商榷。比如剧情有一些地方显得很刻意，故意为之的痕迹有点明显，另外也有一些bug很难解释，比如陈念失手杀死魏莱后，还可以在几天后的高考中稳定发挥，考出632的高分，按照一般人的设定，即使是失手杀死的别人，心理也一定会留下不小的影响，另外电影中的手机以及手机软件跟2011年也不匹配，等等。即使如此，《少年的你》还是一部非常值得观看的电影。电影从校园凌霸主题切入，实际上折射出了很多社会问题。随着这些年城市、农村的巨大变迁，人们的工作方式发生了很大的变化。当孩子的父母因为异地打工不能陪伴孩子，或者父母因为忙于工作，而对孩子置之不理，缺乏关爱，还有离婚的家庭等等复杂的情况，正是这些不稳定的家庭，才构成了凌霸、被凌霸的事情不停的发生。没有那个孩子天生是坏孩子，他们的内心可能更孤独，更缺乏关爱。开始看到魏莱觉得可气，后来觉得可怜。她有漂亮的外貌、优异的成绩，还有别人看上去阔绰的家庭，但是她的成长中父母对她的关心、教育是明显不够的。她的父母可能给她报了最好的辅导班、给了她最好的物质帮助，但是对她的关心却很少，剧中她妈妈的言行也暴露她是一个势利眼的母亲。但抛开电影，如今的现实生活中，实际上，富裕家庭对孩子的教育大概率还是成功的多，很多富裕的家庭都有更加成熟的教育观念，剧中只是讽刺了一部分有钱人，他们有钱却没有对子女进行更好的精神世界教育，实际上，生活中，相比穷人家的孩子，富人家庭生活长大的孩子还是更容易获得成功。现实就是这么残酷，作为起点没有别人高的穷孩子，一定要加倍努力才是。另外，整个故事，高考都是一个不可忽视的点。对一个普通家庭的孩子来说，高考太重要了，它是大家为数不多的、比较公平的可以改变命运的机会。陈念要去北京，她要走出去，这是她自始至终的力量源泉所在。实际上，这不止是她一个人力量源泉，我们都是如此，关于高考有一个共识：高考是当今社会最公平有效的上升方式在我们国家现在的阶段，贫困家庭的孩子想要改变自己的命运，想要脱离自己父母所处的阶层，那么参加高考，上大学，是为数不多的选择，甚至可以说是唯一的选择。（实际上，我们是不是也应该反思一下，我们的社会是不是有什么问题，上升通道是不是太少了？）家长清楚这一点，孩子们也明白，所以在面对高考时，家长们会迸发出前所未有的团结和耐心，学生们也会竭尽全力的拼搏。因为这样的机会太少了，人生数十载，改变命运的机会并不多，当大家都明白这样的机会就在眼前时，这会产生怎样的激励？只要是有正常思维的家庭，孩子有一定的学习天分，都会抓住高考这根稻草，拼死一搏。这也是剧中陈念一开始面对欺凌时，一在忍让、不发声的原因。因为她的高考不能失败，她不能因为别人的欺负就跟她们一直纠缠下去。她心里一直想着要去北京上大学，还要带着自己的老妈，让自己的老妈在校门外开个小店，改变自己人生轨迹的同时，帮助自己老妈过上更好的生活。陈念是一个高中生，即使有欺凌，有不堪，但是她还有高考的机会，只要有高考的机会，她的生命就更加有希望。相比而言，看到刘小北，就觉得特别的无助。他是一个内心正义、善恶分明的小混混，即使如此，他也只是个小混混，没有爸妈的孩子，派出所的常客，他几乎没有希望可以摆脱自己的境地，在那个小城里，他几乎可以看得到自己的余生如何渡过。尤其是陈念要进入高考考场时，她要进入的是即将改变自己命运的考场，这时刘小北只能站在家长的人群中，此刻他显得格外显眼，他跟陈念在同样的年龄，自己却只能站在考场之外，这种心理落差，很难去体会。刘小北在没有遇到陈念前，就是一个普通的小混混，只是他比较正直，有原则，但他没有梦想，没有希望，直到遇到了陈念，他发现了自己的价值，他可以保护陈念，他喜欢陈念，他的日子阳光了起来，他有了不一样的希望。他自己没法改变自己的命运，但是现在他可以保驾护航陈念，让她有更好的未来…只有你赢了，我才不算输。隐约有种斑羚飞渡的精神，但同龄的他们，刘小北只有这样才能发挥自己的价值，十足无奈，他原本可以自己去考场上赢，如今却只能以这种间接的方式去赢，这背后还是一个失败的家庭造成的。跟《我不是药神》一样，电影看后，每个人都可以从不同的角度去体会、发现和反思，这就是一部好电影。另外电影中有几个故事非常让人动容。影响最深的是他们第二次接吻，以往的接吻可能会让观众觉得肉麻，但是那次接吻却十足震撼。还有她俩狱中的对视，没有任何语言，那是眼神与心灵的交流…总之，一部非常值得一看的电影。</li>
  <li>昨天看文章时发现自己对linux操作系统不够了解，还记得17年时听过老师的一些课，对linux的历史有一点了解，不过当时并没有记录笔记，现在已经忘的差不多了。这次从网上找资料，又重新看了一遍，同时做了一些笔记。这次看的是鸟哥的文章，他把unixlinux的起源历史讲的相当细致，读起来非常有意思，而且本来他们的历史也是一个非常复杂曲折的过程，认真读一读也是收货颇多。Unix算是操作系统的鼻祖，尽管现在移动平台中的Android、iOS操作系统，电脑中的MACOS以及windows操作系统都很流行，但是他们其实都是后来才出现的，况且苹果的macos实际也是Unix的一个分支而来。Unix起源Unix诞生在上世纪60年代，但它的诞生并不是有意为之，而是从贝尔实验室、麻省理工学院、通用电器合作的一个失败的项目（Multics）演变而来。当时他们做的项目由于资金问题以及延期等原因失败了，后来项目中的另一个人在做自己的个人项目时，想到了之前的旧项目，觉得可以拿过来改一改，有可用的地方，所以自己大幅度更改了旧项目，让其简化，并起名Unics，不过一开始他用的是汇编语言，所以它的可移植性并不好。后来实验室的同事发现这个东西太好用了，但是移植性差，后来便把它用更高级的C语言重写了一遍，同时把名字改为Unix，这才是Unix的开始，这一年是1973年。这时Unix正式登上历史舞台，不过当时版权、软件许可证等等条件都不完善，Unix在变得流行的同时，也出现了很多问题，Unix一开始比较open，源代码大家可以相对轻松的看到，后来贝尔实验室的母公司AT&amp;T发布了一条禁令，禁止大学用Unix源码进行教学。这条禁令让一个大学教授Tanenbaum很费神，因为他的工作就是教学生Unix。但是方法总比问题多。他自己曲线救国，想到了自己造一个类似Unix的操作系统，毕竟他对Unix已经十分熟悉，为了防止版权问题，他在写操作系统时完全不看Unix源码，后来自己耗时两年，在1984年开始写，到1986年写完了这个类Unix的操作系统，并起名Minix，意思就是迷你Unix系统。另外这个系统完全兼容Unix，也就是说在Unix上运行的软件，也可以在Minix上运行。不过Tanenbaum开发Minix初衷是为了方便自己教学，所以完成Minix后，他并不去推广，而且它并不免费，你想看必须通过购买光磁带才行，不过当时很便宜，与此同时磁带中还附带了源码，非常良心啊，但是这样传播还是很慢，这是1986年。慢慢的大家发现这个Minix也很好用啊，有很多人在论坛里给Tanenbaum提建议，觉得Minix还可以变得更好，但是教授太忙，自己也无心去继续完善。终于历史即将迎来转机…不得不提的自由软件RichardStallman是一个自由软件的追求者，同时是一个即刻，他信仰自由软件，相比商业软件，自由软件可以更加快速的传播，可以团结更多优秀工程师的力量，但是Unix在是一个商业软件，所以他希望创建一个真真自由而开放源代码的专有Unix系统替代品。但是创建一个操作系统谈何容易，他开始以GUN的名义开发Unix平台上的工具程序和软件，Unix源码不开源，但是我开发的这些软件套件开源。当时也有一个内核项目在进行，但开发内核很难，而没有内核，自由软件和开源就很难进行。但是他的工作还是非常有意义的，他开发了GUN套件以及一些Unix平台上的编译程序，主要有：EmacsGNUC(GCC)GNUCLibrary(glibc)Bashshell后来很多软件开发者都在这些基础上用这些工具进行程序开发，进一步壮大自由软件团体，不过相比最初的构想，建立一个自由的Unix操作系统，这些还远远不够，因为没有内核，所以那些软件依旧只能运行在有专利的Unix平台上，一直到Linux的出现…Linux要来了1988年芬兰人LinusTorvalds进入了自己外祖父的大学-赫尔辛基大学，就读计算机科学，因为专业关系，他在大学时接触到了Unix，但是当时机器资源紧张，学校的机器不够他玩，他就想自己搞一个Unix，但是这东西那是那么容易就搞，一个操作系统相当的复杂。不过很快，他就知道了Minix的消息，所以跟很多人一样也，他购买了Minix磁带，然后把Minix安装在了自己贷款购买的Intel386电脑上。终于，现在可以在自己的电脑上愉快的玩耍了，而且磁带中是有源码的，所以他就可以更改、优化它，毕竟是大牛，很快他就让Minix支持了多任务。后来他在BBS上也留言，说Minix可以变得更好更强大，但是Tanenbaum依旧不愿意去做这件事，后来LinusTorvalds就想，何不自己搞一个内核玩，而且现在还有Minix可借鉴，站在巨人的肩膀上，一切做起来就简单多了，所以他就开始了核心程序的开发。好在那时的很多软件条件都已经具备，很重要的就是GNU的自由软件，他用GNU的自由软件(上一节提到的)将核心程序与Intel386d紧紧的结合在一起，最终写出他所需要的核心程序，然后发布在了校内BBS上。同时提供了下载，有趣的是由于FTP上下载目录的名称为：Linux，所以大家都开始叫它Linux。后来为了兼容Unix，LinusTorvalds决定修改Linux，以便让所有Unix上能运行的软件都可以在Linux上运行，而且那时已经有成熟的POSIX规范，所以他按照这个规范，实现了这个规范，慢慢的Linux变得越来越好，越来越好…要点通过C语言重构Unix、Unix具有了很好的可移植性，让其可以移植到许多硬件体系结构中。KenThompson的Unix哲学成为模块化软件设计和计算的强大模型。Unix哲学推荐使用小型的、专用的程序组合起来完成复杂的整体任务。Linux的很大吸引力在于操作系统在许多硬件体系结构（包括现代PC）上的可用性以及类似使用Unix系统管理员和用户熟悉的工具的能力在Unix发行版中缺少一个影响软件和硬件供应商的通用内核。对于Linux，供应商可以为特定的硬件设备创建设备驱动程序，并期望在合理的范围内它可以在大多数发行版上运行。Linux已经显示出其超越Unix的显著优势在于其在大量硬件平台和设备上的可用性。链接鸟哥的Linux私房菜--Linux是什么？从Linux的历史谈起Linuxvs.Unix：有什么不同？-知乎关于作者咕咚，Android工程师，个人博客gudong.site，公众号：咕喱咕咚</li>
  <li>斯坦李一生都在做一件事-漫画。这也是他一生中最喜欢的事，与此同时，相比编剧，他更喜欢表演，所以从2007开始的漫威大宇宙计划开始后，他在每部影片中都有客串。无疑，他是成功的，做自己喜欢的事，同时观察他的整个生涯，他经历了很多变迁，中间有很多挫折、变故，但是他都在不停的适应变化，适应时代，却从来没有离开过漫威。所以我觉得人一生如果能把自己都奉献给一个事业是一件多么幸运和幸福的事。当然，可遇不可求，不是每个人都可以找到自己喜欢并可以为之奋斗一生的事业，遇上是一种幸运，也可以说是命运，大多数人，并没有如此幸运，或者自己本身实力不足，天赋欠佳，也就是普通人。对我们更多的意义就是努力去找到自己喜欢的事，哪怕不能为之奋斗一辈子，奋斗几年、十年，但是也好过虚度光阴。另外就是保持快乐能力。别人不能让你快乐时，自己也可以通过其他方式让自己快乐。“真信徒，不回头！”FaceFront,TrueBelievers!读深度：漫威简史（1939-2019）有感</li>
  <li>本文是自己看鸟哥的Linux私房菜--Linux是什么？从Linux的历史谈起的摘录，对原文做了部分摘录，并加以自己的注释。感谢鸟哥的文章。Unix起源60年代，为了强化大型主机的功能，让主机的资源更好的被利用，在1965年前后，由贝尔实验室(Bell)、麻省理工学院(MIT)及奇异公司(GE,或称为通用电器)共同发起了Multics的计划，Multics计划的目的是想要让大型主机可以达成提供300个以上的终端机联机使用的目标。不过，到了1969年前后，计划进度落后，资金也短缺，所以该计划虽然继续在研究，但贝尔实验室还是退出了该计划的研究工作。一个大项目失败了。失败其实是常态，成功不易。在认为Multics计划不可能成功之后，贝尔研究室就退出该计划。不过，原本参与Multics计划的人员中，已经从该计划当中获得一些点子，KenThompson就是其中一位！即使失败，但是参与的过程中，参与的人一定有收获。Thompson因为自己的需要，希望开发一个小的操作系统以满足自己的需求。在开发时，有一部DEC(DigitalEquipmentCorporation)公司推出的PDP-7刚好没人使用，于是他就准备针对这部主机进行操作系统核心程序的撰写。本来Thompson应该是没时间的(有家有小孩的宿命？)，巧的是，在1969年八月份左右，刚好Thompson的妻儿去了美西探亲，于是他有了额外的一个月的时间好好的待在家将一些构想实现出来！巧了，Unix应该给Thompson媳妇发一份感谢信。经过四个星期的奋斗，他终于以汇编语言(Assembler)写出了一组核心程序，同时包括一些核心工具程序，以及一个小小的文件系统。那个系统就是Unix的原型！当时Thompson将Multics庞大的复杂系统简化了不少，于是同实验室的朋友都戏称这个系统为：Unics。一开始的Unix雏形使用汇编语言写的，厉害厉害，不过那时可选择的语言也并不多。由于Thompson写的那个操作系统实在太好用了，所以在贝尔实验室内部广为流传，并且数度经过改版。但是因为Unics本来是以汇编语言写成的，而汇编语言跟硬件平台有关，不同的平台指令，加上当时的计算机机器架构都不太相同，所以每次要安装到不同的机器都得要重新编写汇编语言，真不方便！是的，非常麻烦，汇编语言没有可移植性，还是要高阶的语言写操作系统才合适。后来Thompson与Ritchie合作想将Unics改以高阶程序语言来撰写。当时现成的高阶程序语言有B语言。但是由B语言所编译出来的核心效能不是很好。后来DennisRitchie将B语言重新改写成C语言，再以C语言重新改写与编译Unics的核心，最后正名与发行出Unix的正式版本！正式发行的Unix是C语言实现的。这很重要，这样他的可移植性大大增加。由于贝尔实验室是隶属于美国电信大厂AT&amp;T公司的，只是AT&amp;T当时忙于其他商业活动，对于Unix并不支持也不排斥。此外，Unix在这个时期的发展者都是贝尔实验室的工程师，这些工程师对于程序当然相当有研究，所以，Unix在此时当然是不容易被一般人所接受的！那时应该还没有产品经理一职吧，Unix的产品经理就是那些工程师，牛逼…另外，原来贝尔实验室是电信公司AT&amp;T下面的，贝尔实验室真是出了不少出名的东西，计算机界的活化石。虽然贝尔属于AT&amp;T，但是AT&amp;T此时对于Unix是采取较开放的态度，此外，Unix是以高阶的C语言写成的，理论上是具有可移植性的！亦即只要取得Unix的源代码，并且针对大型主机的特性加以修订原有的源代码(SourceCode)，就可能将Unix移植到另一部不同的主机上头了。所以在1973年以后，Unix便得以与学术界合作开发！最重要的接触就是与加州柏克莱(Berkeley)大学的合作了。柏克莱大学的BillJoy在取得了Unix的核心原代码后，着手修改成适合自己机器的版本，并且同时增加了很多工具软件与编译程序，最终将它命名为BerkeleySoftwareDistribution(BSD)。这个BSD是Unix很重要的一个分支，BillJoy也是Unix业者『Sun(升阳)』这家公司的创办者！Sun公司即是以BSD发展的核心进行自己的商业Unix版本的发展的。MacOX也是源自Unix的BSD分支，只是BSD允许闭源，所以MacOS闭源的。Unix越来越火，与此同时，商业纠纷也越来越多。因为AT&amp;T由于商业的考虑，以及在当时现实环境下的思考，于是想将Unix的版权收回去。因此，AT&amp;T在1979年发行的第七版Unix中，特别提到了『不可对学生提供原始码』的严格限制！同时，也造成Unix业界之间的紧张气氛，并且也引爆了很多的商业纠纷～不是很明白为什么要对学生禁止。1979年的版权声明中，影响最大的当然就是学校教Unix核心原始码相关学问的教授了！如果没有核心原始码，那么如何教导学生认识Unix呢？这问题对于AndrewTanenbaum教授来说，实在是很伤脑筋的！不过，学校的课程还是得继续啊！那怎么办？既然1979年的Unix第七版可以在Intel的x86架构上面进行移植，那么是否意味着可以将Unix改写并移植到x86上面了呢？在这个想法上，Tanenbaum教授于是乎自己动手写了Minix这个UnixLike的核心程序！在撰写的过程中，为了避免版权纠纷，Tanenbaum完全不看Unix核心原始码！并且强调他的Minix必须能够与Unix兼容才行！Tanenbaum在1984年开始撰写核心程序，到了1986年终于完成。没有出路自己就创造道路，况且能用代码解决的问题都不算大问题。Minix花了两年完成，非常棒啊。这个Minix版本比较有趣的地方是，他并不是完全免费的，无法在网络上提供下载！**必须要透过磁盘/磁带购买才行！**虽然真的很便宜～不过，毕竟因为没有在网络上流传，所以Minix的传递速度并没有很快速！此外，购买时，随磁盘还会附上Minix的原始代码！这意味着使用者可以学习Minix的核心程序设计概念喔！(这个特色对于Linux的启始开发阶段，可是有很大的关系喔！)此外，Minix操作系统的开发者仅有Tanenbaum教授，因为学者很忙啊！加上Tanenbaum始终认为Minix主要用在教育用途上面，所以对于Minix是点到为止！其实是可以理解的。教授的时间有限，能开发出来已经不错，那先发扬光大的事交给学生做更好。GNU计划与FSF基金会的成立RichardMathewStallman(史托曼)在1984年发起的GNU计划，对于现今的自由软件风潮，真有不可磨灭的地位！目前我们所使用得很多自由软件，几乎均直接或间接受益于GNU这个计划呢！那么史托曼是何许人也？为何他会发起这个GNU计划呢？Stallman可以称为自由软件鼻祖。他崇尚自由软件。RichardMathewStallman(生于1953年，网络上自称的ID为RMS)从小就很聪明！他在1971年的时候，进入黑客圈中相当出名的人工智能实验室(AILab.)当时的黑客圈对于软件的着眼点几乎都是在『分享』，所以并没有专利方面的困扰！这个特色对于史托曼的影响很大！不过，后来由于管理阶层的问题，导致实验室的优秀黑客离开该实验室，并且进入其他商业公司继续发展优秀的软件。但史托曼并不服输，仍然持续在原来的实验室开发新的程序与软件。后来，他发现到，自己一个人并无法完成所有的工作，于是想要成立一个开放的团体来共同努力！一个人的力量是渺小的，要干大事一定需要一个团队。1983年以后，因为实验室硬件的更换，使得史托曼无法继续以原有的硬件与操作系统继续自由程序的撰写～而且他进一步发现到，过去他所使用的Lisp操作系统，是麻省理工学院的专利软件，是无法共享的，这对于想要成立一个开放团体的史托曼是个阻碍。于是他便放弃了Lisp这个系统。后来，他接触到Unix这个系统，并且发现，Unix在理论与实际上，都可以在不同的机器间进行移植。虽然Unix依旧是专利软件，但至少Unix架构上还是比较开放的！于是他开始转而使用Unix系统。因为Lisp与Unix是不同的系统，所以，他原本已经撰写完毕的软件是无法在Unix上面运行的！为此，他就开始将软件移植到Unix上面。并且，为了让软件可以在不同的平台上运作，因此，史托曼将他发展的软件均撰写成可以移植的型态！也就是他都会将程序的原始代码公布出来！能感觉到Stallman是一个非常open的人。1984年，史托曼开始GNU计划，这个计划的目的是：建立一个自由、开放的Unix操作系统(FreeUnix)。但是建立一个操作系统谈何容易啊！而且在当时的GNU是仅有自己一个人单打独斗的史托曼～这实在太麻烦，但又不想放弃这个计划，那可怎么办啊？聪明的史托曼干脆反其道而行～『既然操作系统太复杂，我就先写可以在Unix上面运行的小程序，这总可以了吧？』在这个想法上，史托曼开始参考Unix上面现有的软件，并依据这些软件的作用开发出功能相同的软件，且开发期间史托曼绝不看其他软件的源代码，以避免吃上官司。后来一堆人知道免费的GNU软件，并且实际使用后发现与原有的专利软件也差不了太多，于是便转而使用GNU软件，于是GNU计划逐渐打开知名度。联合大家的力量，让Unix变得open虽然GNU计划渐渐打开知名度，但是能见度还是不够。这时史托曼又想：不论是什么软件，都得要进行编译成为二进制文件(binaryprogram)后才能够执行，如果能够写出一个不错的编译程序，那不就是大家都需要的软件了吗？因此他便开始撰写C语言的编译程序，那就是现在相当有名的GNUCCompiler(gcc)！这个点相当的重要！这是因为C语言编译程序版本众多，但都是专利软件，如果他写的C编译程序够棒，效能够佳，那么将会大大的让GNU计划出现在众人眼前！原来GCC就是这样来的，它是一个编译软件。到了1985年，为了避免GNU所开发的自由软件被其他人所利用而成为专利软件，所以他与律师草拟了有名的通用公共许可证(GeneralPublicLicense,GPL)，并且称呼他为copyleft(相对于专利软件的copyright！)。而为了避免自己的开发出来的Opensource自由软件被拿去做成专利软件，于是Stallman同时将GNU与FSF发展出来的软件，都挂上GPL的版权宣告～这个FSF的核心观念是『版权制度是促进社会进步的手段，版权本身不是自然权力。这是一个厉害人，他非常清楚自己要做什么，他所有做的事都在围绕着自己的目标。GPL应该是限制最宽泛的软件许可证。自由软件活动1984年创立GNU计划与FSF基金会的Stallman先生认为，写程序最大的快乐就是让自己发展的良好的软件让大家来使用了！而既然程序是想要分享给大家使用的，不过，每个人所使用的计算机软硬件并不相同，既然如此的话，那么该程序的源代码(Sourcecode)就应该要同时释出，这样才能方便大家修改而适用于每个人的计算机中呢！这个将源代码连同软件程序释出的举动，就称为自由软件(FreeSoftware)运动！此外，史托曼同时认为，如果你将你程序的Sourcecode分享出来时，若该程序是很优秀的，那么将会有很多人使用，而每个人对于该程序都可以查阅sourcecode，无形之中，就会有一票人帮你除错啰！你的这支程序将会越来越壮大！越来越优秀呢！是的，就是这种分享精神，分享让我快乐，让我觉得自己的价值被体现。Linux出世LinusTorvalds(托瓦兹，1969年出生)的外祖父是赫尔辛基大学的统计学家，他的外祖父为了让自己的小孙子能够学点东西，所以从小就将托瓦兹带到身边来管理一些微计算机。在这个时期，托瓦兹接触了汇编语言(AssemblyLanguage)，那是一种直接与芯片对谈的程序语言，也就是所谓的低级语言。必须要很了解硬件的架构，否则很难以汇编语言撰写程序的。一个人的家庭环境对自己日后的影响真大，所以家庭很重要，孩子的好奇心也很重要。在1988年间，托瓦兹顺利的进入了赫尔辛基大学，并选读了计算机科学系。在就学期间，因为学业的需要与自己的兴趣，托瓦兹接触到了Unix这个操作系统。当时整个赫尔辛基只有一部最新的Unix系统，同时仅提供16个终端机(terminal)。还记得我们上一节刚刚提过的，早期的计算机仅有主机具有运算功能，terminal仅负责提供Input/Output而已。在这种情况下，实在很难满足托瓦兹的需求，因为…..光是等待使用Unix的时间，就很耗时～为此，他不禁想到：『我何不自己搞一部Unix来玩？』不过，就如同Stallman当初的GNU计划一样，要写核心程序，谈何容易～爱玩的Torvalds，也是一个很能折腾的人啊…不过，幸运之神并未背离托瓦兹，因为不久之后，他就知道有一个类似Unix的系统，并且与Unix完全兼容，还可以在Intel386机器上面跑的操作系统，那就是我们上一节提过的，Tanenbaum教授为了教育需要而撰写的Minix系统！他在购买了最新的Intel386的个人计算机后，就立即安装了Minix这个操作系统。这时Torvalds跟其他Minix爱好者一样，都是拿到他折腾，在Linus的折腾下，当时的minix已经可以支持多任务了。探索完了386的硬件之后，终于拿到Minix并且安装在托瓦兹的386计算机上之后，托瓦兹跟BBS上面一堆工程师一样，他发现Minix虽然真的很棒，但是Tanenbaum教授就是不愿意进行功能的加强，导致一堆工程师在操作系统功能上面的欲求不满！这个时候年轻的托瓦兹就想：『既然如此，那我何不自己来改写一个我想要的操作系统？』于是他就开始了核心程序的撰写了。历史会偶尔停下自己的脚步，但是终归还是要向前走…撰写程序需要什么呢？首先需要的是能够进行工作的环境，再来则是可以将源代码编译成为可执行文件的编译程序。好在有GNU计划提供的bash工作环境软件以及gcc编译程序等自由软件，让托瓦兹得以顺利的撰写核心程序。这时候，Linux的历史条件都已经成熟很多了，就差Torvalds来完成最后一步…他参考Minix的设计理念与书上的程序代码，然后仔细研究出386个人计算机的效能优化，然后使用GNU的自由软件将核心程序代码与386紧紧的结合在一起，最终写出他所需要的核心程序。而这个小玩意竟然真的可以在386上面顺利的跑起来～还可以读取Minix的文件系统。真是太好了！不过还不够，他希望这个程序可以获得大家的一些修改建议，于是他便将这个核心放置在网络上提供大家下载，同时在BBS上面贴了一则消息：他说，他完成了一个小小的操作系统，这个核心是用在386机器上的，同时，他真的仅是好玩，并不是想要做一个跟GNU一样大的计划！另外，他希望能够得到更多人的建议与回馈来发展这个操作系统！这个概念跟Minix刚好背道而驰呢！这则新闻引起很多人的注意，他们也去托瓦兹提供的网站上下载了这个核心来安装。开放是Linux成功的前提。同时，为了让自己的Linux能够兼容于Unix系统，于是托瓦兹开始将一些能够在Unix上面运作的软件拿来在Linux上面跑。不过，他发现到有很多的软件无法在Linux这个核心上运作。这个时候他有两种作法，一种是修改软件，让该软件可以在Linux上跑，另一种则是修改Linux，让Linux符合软件能够运作的规范！由于Linux希望能够兼容于Unix，于是托瓦兹选择了第二个作法『修改Linux』！为了让所有的软件都可以在Linux上执行，于是托瓦兹开始参考标准的POSIX规范。作为一个有抱负的工程师，面对这个问题，他肯定会选择后者这种方式，因为这样能更彻底的解决问题，对Linux长远发展更有价值。况且，这时已经有规范了，所以实现规范一种非常专业的做法。Tips:POSIX是可携式操作系统接口(PortableOperatingSystemInterface)的缩写，重点在规范核心与应用程序之间的接口，这是由美国电器与电子工程师学会(IEEE)所发布的一项标准喔！这个正确的决定让Linux在起步的时候体质就比别人优良～因为POSIX标准主要是针对Unix与一些软件运行时候的标准规范，只要依据这些标准规范来设计的核心与软件，理论上，就可以搭配在一起执行了。而Linux的发展就是依据这个POSIX的标准规范，Unix上面的软件也是遵循这个规范来设计的，如此一来，让Linux很容易就与Unix兼容共享互有的软件了！同时，因为Linux直接放置在网络下，提供大家下载，所以在流通的速度上相当的快！导致Linux的使用率大增！这些都是造成Linux大受欢迎的几个重要因素呢！所以大多数情况下，Linux跟Unix的兼容性应该是非常好的。读完应该知道Linux跟Unix完全是两码事，但是间接借鉴了Unix的设计Linux兼容Unix，很多软件在两个平台均可运行另外文章挺长的，后面的没有继续读…参考链接鸟哥的Linux私房菜--Linux是什么？从Linux的历史谈起鸟哥这个介绍相当详细啊</li>
  <li>前几天莫雷发表了一条和香港有关的twitter，随后发觉不妥，随即删除，接着引发了更大的舆论风暴。后续莫雷没有任何明确的致歉，然后国内与其合作的厂商纷纷宣布取消与火箭队的合作。大家都在看nba总裁如何处理这件事的时候，昨天早晨萧华发布了支持莫雷的言论，这场舆论战争彻底被点燃。现在央视已经宣布不在播出NBA比赛，腾讯也停止播放nba所有的季前赛。nba凉凉在即…这个事件展现出了很多东西。美国舆论自由，可以随便发表个人意见，即使如此，自由也有边界，言论也有雷区，针对肤色、性别的言论他们也会慎重。之前快船老板就因在私下发表了黑人歧视言论，最后被处罚辞退。而面对中国，一个公众人物却不管不顾中国的领土问题，在社交平台上公开宣扬自己站队香港，领土问题不是美国的言论雷区，但是对中国是绝对的雷区。一个美国人，在中国有自己的商业版图的情况下，发表任何言论不应该考虑中国的言论雷区吗？后续莫雷以及NBA总裁对之前的行为并没有进行致歉，依然不觉得言论自由有任何问题，这是一种典型的对中国的不尊重，同样有言论雷区，不顾中国的雷区，那你就要付出代价。通过各种信息可了解到，美国对中国的歧视存在于个个行业，但是在这里赚钱还不尊重这里的主权，就一定要硬刚回去。</li>
  <li>安全打球，为祖国健康工作五十年八月十六号，一个周五的上午，跟一个球友约了中午去玩球，结果在一对一防守他的时候，不小心被一肘子肘到了鼻梁骨。接着去了附近医院做CT，显示鼻梁骨两侧骨折，鼻中隔偏曲，比较严重，医生说需要手术，后来去了积水潭医院，两位医生看了也是同样的结论。人生就是这样，什么都有第一次。这是自己第一次骨折，第一次手术，第一次全身麻醉。手术那天被推到手术室后，先是插针，身上贴一些线头，最后给自己戴了一个面罩，让我大口呼吸，当时傻傻的，还不知道这就是麻醉，呼吸了十口左右便什么都不知道了，直到在恢复室醒来，全程没有任何知觉…醒来的时候倒是跟电视剧中演的很像，眼睛先是模糊，看到了天花板，脑子朦朦胧胧的，接着渐渐有了意识，然后想动手指，但手指那边的肌肉还不受大脑控制，手指动不了，直到过了一会身体才可以动，然后感觉到嘴里一嘴的粘液，接着自己便要了纱布开始清理…就这样手术便结束了。手术的过程没有任何知觉、痛感，简直非常友好的体验，但是术后就不是了…手术时为了矫正复位鼻骨，医生在鼻腔鼻孔里都塞满了凡士林纱布，术后鼻子鼓鼓的，看上去特别像小丑的鼻子，由于鼻子被堵住了，呼吸只能靠口腔。平时鼻子不通时，我们也有口腔呼吸的经历，但是如果长时间用口腔呼吸，喉咙就会很干很难受。同时麻药过后，鼻骨哪里开始隐隐作痛，同时嘴里还会不停的出血，只能从嘴里吐。手术后的48小时之内很煎熬，而且因为鼻腔内的填充物挤压着泪腺，自己会一直不自主的流泪，还怕光…非常煎熬…然后一联想受伤的过程，就觉得很不值，打球一时爽，但因为疏忽、不经意，让自己受伤，遭受如此的经历，就觉得非常不值得…尤其是在每天清洗鼻子、插针输液的时候…术后第三天要取出鼻子中纱布了，分两次取，一开始很期待，就想赶快取了，让鼻子尽早通气，但没想到取纱布是最难受的。一开始不知道，每个鼻子塞进去的纱布得有50厘米长，取得时候用一个钳子伸进去，然后不断旋转拉取，纱布要从鼻腔里取出，那种感觉怎么形容呢，有一种痛叫钻心，这时的痛更适合用钻脑来形容，体验过一次便绝不想体验第二次。也因为这样的经历，让我对这次受伤有了更加深入的反思。保护自己，平时不论做什么事，玩什么，都要专心，同时保持安全意识。做什么事都要有保护自己，保护他人的意识，不要做危险的动作，让自己处于危险之中，保护自己很重要。当然单靠安全意识是不能完全避免受伤的，但是建立安全意识总没错…　•　打球踢球前先热身　•　疲劳时休息或者补充能量　•　不跟打球野蛮的人一起打球　•　等等因为一旦受伤，对自己生活工作势必带来很大的影响。想起这次住院的经历，我觉得还是挺有意义的。通过住院手术治疗的经历，让我明白了安全运动的重要性。这次也只是鼻骨折，算是轻伤，并不特别严重，只是遭受一些感官上的痛，但这次经历让我意识到平时安全意识的重要，这是远比受伤要重要的东西。人生也许就是这样，很多道理只有自己经历了才会更加深刻，才是自己的东西。世间大道理很多，很多一听就懂，但是大部分人、大部分道理真的只有自己经历过才会更加深刻，才是自己的道理，这也是看电影看书所不能比拟的。读万卷书，行万里路，实践出真知，说的都是同一个道理。不过有时又觉得其实挺矛盾的。父母、前人他们的人生经历其实已经明白了很多道理，他们实际上不想让后代再去经历一次，他们希望后代可能跳过那些人生的坑，然后在教育的过程中三令五申，但儿子、后代们却就是难以听进去，非要自己经历过、掉过坑才会觉得，原来真的是这样，不听老人言，吃亏在眼前…年轻时更多的还是应该去多经历、多尝试，可以去犯一些不会伤经动骨的错，多经历些磨难、挫折，让自己对自己对世界才会有更深刻的认识…</li>
  <li>什么是货币基金货币基金的全称，是货币市场基金，是指投资于货币市场上短期有价证券的一种投资基金。其常见的投资对象主要有现金，期限在1年内的银行存款、债券回购、中央银行票据、同业存单，和其他具有良好流动性的货币市场工具等。这种基金只投风险很低、流通性很强的品种，所以对于普通投资者来说，货币基金就是我们的现金的“安全垫”和“避风港”。目前市场上大多数货币基金的申购赎回都是零费率，管理费也低。货币基金的万份收益和七日年化万份收益即每一万份货币的收益，比如上图的2019年2月12日，每万份收益为0.9168，也就说，如果你当日持有10000份货币基金，那么则可以产生0.9168元的收益。万份收益是每天的数据，每天都会变化，因为货币基金有收益释放的现象，这样有时会特别高，有时特别低。如下图所示为了平滑收益曲线，与同类产品更好的对比，就引出了七日年化收益率的指标七日年化收益率七日年化收益率也就是最近七天的收益换算成一年的收益率，具体公式为七日年化收益率=最近连续七天货币基金的每万份单位基金日收益之和*365/7)/10000*100%如何计算收益红利转投资，解释一下就是，单位净值永恒不变为1元，真实的收益超过一元的部分会按时自动再转化为基金份额，所以一元一份额不会变，但是投资者手里的份额会越来越多，赎回时投资者拥有多少基金份额，即拥有多少资产。如下就是一个货币基金的收益明细可以看到，分红都是基金上涨带来的份额。什么因素会使基金价格上涨最主要的就是市场资金面紧张、或者基金遭遇大额赎回等等。像2017年5月初货币基金收益走高的原因，就是市场上缺钱，导致利率上升，货币基金投资的这些货币市场工具自然收益上扬。另外，由于市场资金面的紧张有比较明显的季节性特征。比如，每年下半年尤其是第四季度，银行会做存款考核，市场资金面往往相对紧张，货币基金收益率就会有比较大的提升。货币基金有哪些风险关键词钱荒、大额赎回，在2013年的钱荒中，由于市场上的同业拆借利率已经到了10%，而货币基金的七日年化收益只有3%-4%，于是很多机构赎回货币基金，将钱投入到同业拆借市场。同时货币基金被迫卖出手中持有的债券。这些债券有的到期期限还很长，现在为了救急卖掉往往意味着在卖出的价格上比较吃亏。此时一些基金公司就会借口系统升级，来暂停赎回。另外，货币基金所投资的债券本身也有风险。就在2016年底，债券市场出现了类似于股灾的大幅波动，一直持有较多债券的货币基金收益就出现了大幅下滑。除此之外，还有人工操作性风险。总体来说，除非出现极端情况，否则一般基金公司是不允许他们的货币基金出现亏损的现象的，这就是砸招牌了。总结货币基金是一个非常不错的入门投资选择，相比于其他投资产品，如股票或者其他类型的基金(如股票型基金、指数型基金)的风险都要小，同时收益还稳定，还比银行的定期利率也要高不少，相比银行操作也要简单，不需要跑去银行排队购买，现在的货币基金大都可以在手机APP上操作完成，这样每天还可以实时的看到基金收益。与此同时，也要堤防的货币基金的风险因素，上面也说到了，如果自己察觉到市场上有不稳定因素，应该及时拿出来。说明文中大部分内容援引自知乎的一篇文章货币基金零风险吗？-知乎，特此说明</li>
  <li>这本书已经看完一段时间了，应该是今年一月末开始看的，用了一周左右的时间便看完了。开始时自己是在豆瓣的年度推荐列表里看到的这本书，其中最吸引我的有两点，这是一本餐饮书籍（我喜欢厨师）作者是老外（很好奇老外会怎么写川菜）因为上面两个因素，我开始读。这是一本小说，但也算科普读物。书中通过第一人称的口吻讲述了作者从94年到成都后的各种见闻，她把自己的一系列经历、见闻都记录了下来。同时以餐饮为轴线，里面还描绘了各种好吃的东西，所以非常有可读性，在她的诱惑下，读了没几章，我便下单买了两瓶四川的豆瓣酱，豆瓣酱真是个好东西啊。但是书中其实探讨的内容挺丰富的，提到了中外文化差异等等厨师之外的很多东西，总之是一本非常好的读物。这本书的作者作者是一个英国妹子，她在94年来中国成都留学，是记者、编辑相关的专业，因为很早也对烹饪感兴趣，来到成都后，很快便对当地的美食所俘获。因为她当时有奖学金，经济也比较宽裕，所以她经常回去成都的老街头去尝试各种吃的，甚至一些老板都记住了她。后来她还去一个烹饪学校进行了为期三个月的专业川菜训练，学习自己做川菜，在学习期间加深了她对中国烹饪的理解。她写过三本美食相关的书籍，这是第三本，在2018年由上海译文出版社发表，翻译文章的是一个川妹子。非常棒的翻译一开始阅读时就觉得，这翻译的太棒了，感觉就是一个中国人写的书，读起来没有任何障碍早晨和半下午菜市场都是忙碌喧嚷的。但午饭后有段时间，大家都在休息，特别是天热的时候。那个时候，不仅是那个卖花的，菜市场的所有人，似乎都在睡觉。农妇们双臂盘绕，趴在她们的南瓜和茄子上，头埋在胳膊里，打个瞌睡。卖西红柿和豆子的坐在地上，双膝耸起，睡成一摊。卖鱼的靠着墙，轻轻扯仆鼾。菜市场之外，整个城市似乎也深陷困意之中。三轮车师傅懒洋洋地躺在没有载客的车里，双脚搭在车把上。办公室的人们躺在仿皮沙发上，四仰八叉的，像猫。摘自：《鱼翅与花椒》—〔英〕扶霞·邓洛普（FuchsiaDunlop）在豆瓣阅读书店查看：https://read.douban.com/ebook/54350652/本作品由上海译文出版社授权豆瓣阅读全球范围内电子版制作与发行。©版权所有，侵权必究。再比如这段周钰点了几个菜，我们等着上菜，听后面那个小厨房淹没在愤怒火爆的“嗞啦”和“嘶嘶”声当中。餐厅里弥漫着各种最最美妙的香味。至今我仍然记得那顿美餐的每一个细节。凉拌鸡，加了酱油、白糖、红油和花椒面；豆瓣鱼，加了豆瓣酱、葱姜蒜；切成花刀的猪腰，刚好一口一个，刀工相当考究，和芹菜泡椒一起大油爆炒而成。还有所谓“鱼香”茄子，我吃过的最好吃的菜之一：亮闪闪的茄子拿深红色的辣味酱料一炒，虽然没有用到鱼，但那引人垂涎的酸甜味儿还真是有点鱼香。这可是我闻所未闻、见所未见、吃所未吃的中国菜，大开眼界啊大开眼界。摘自：《鱼翅与花椒》—〔英〕扶霞·邓洛普（FuchsiaDunlop）在豆瓣阅读书店查看：https://read.douban.com/ebook/54350652/本作品由上海译文出版社授权豆瓣阅读全球范围内电子版制作与发行。©版权所有，侵权必究。后来知道译者是一个川妹子，也是一个吃货，吃货翻译美食文章，所以受罪的一定是读者了。川菜川菜包含太多内容。一直以来，对川菜我只知道辣，其他没什么了解，其实川菜远不是如此。川菜有辣的元素，四川人也爱吃辣，因为四川是典型的盆地区域，气候比较潮湿，而辣味貌似有益于去除身体内的湿气。但是并不是所有的菜都很辣，另外即使辣，一般也都在常人能接受的范围内，要说吃辣，其实重庆、湖南更胜一筹，川菜绝不是因辣出名的。川菜的精华、密码并不是食材、火候，而是调味。相比中国东部地区的菜系不同，川菜并不依赖于丰盛新鲜的食材，而擅长把普通的食物做的更有味。真正让川菜独一无二的，就是调味的艺术。我们常说的“麻辣”味，其实只是川味之中的一种。一场精心安排的川菜宴席，绝不仅是麻辣味就可以概括的，它像是一场缠绵悱恻的戏剧：先用适量的红油唤醒你的味蕾，再用麻酥酥的花椒调动你的唇舌，接下来，辣甜味对你的味觉进行安抚，干辣椒在放电，酸甜味让你如痴如醉，最后再来一口滋补浓汤说道调味，不得不提四川的花椒。四川的花椒很出名，在清朝时，四川的一个地方曾是贡椒产地。另外豆瓣酱也是全国做的最好的，郫县豆瓣酱，相信家喻户晓，在看到第一章的时候，我就没忍住买了两瓶，非常棒。…</li>
  <li>猛龙队4:2勇士队，获得了队史第一个总冠军，去年刚从马刺交易而来的莱昂纳德获得了FMVP。猛龙队从季后赛开打以来，很少有人能预想到他们可以走这么远，可以打到总决赛，就连球队的球馆其实早早已经把六月份安排给了一些演唱会，他们球队完全没想球队在六月还在打季后赛。即使进入了总决赛，在总决赛之初，不少人都觉得卫冕冠军勇士可以很轻松的搞定猛龙，毕竟猛龙从没打过总决赛，而卫冕冠军即使已经夭折了球队一号得分手—杜兰特，但他们依旧以六连胜的姿态进入了总决赛，他们是强大的卫冕冠军。直到第一场总决赛打完，发现比赛势头并不是赛前预想的那样，猛龙在第一场顽强的战胜了勇士，算了爆了一个冷门，整场比赛勇士露出了少有的狼狈，而猛龙则像一个智能AI，在季后赛中不断进化自己，展现出了强大的学习能力。随着比赛渐入佳境，后面勇士也展示出了自己卫冕冠军的坚韧，实力，但天时地利人和，都在猛龙这边，勇士面对命运无力回天，新王莱昂纳德成功登基。莱昂纳德今年转会到猛龙后，在常规赛，他一直表现的中规中矩，很少有被球迷记住的瞬间，加上他一向不善言辞，沉默的性格，所以在联盟中存在感并不像哈登，威少这般收获诸多的曝光。直到季后赛里，他才开始自己的表演。我清楚的记得第一场打魔术，他们输了，赛后我仿佛又看到了前几年每年给詹姆斯陪练的那支猛龙队，但我错了，因为他们有莱昂纳德。随着比赛的深入，季后赛对比赛防守要求的提高，对球队韧性的考验，莱昂纳德开始逐渐闪耀起来。典型的一场是东决第三场，他们已经2:0落后于雄鹿队，这一场决不能输，输了就是把自己推向了万丈深渊，因为3:0翻牌的球队少之又少，这场比赛打的特别焦灼，打了两个加时赛，最后一个加时赛，完全被莱昂纳德攻防两端的表现所统治，厉害极了，即使莱昂纳德看上去已经一瘸一拐。莱昂纳德打球一点不华丽，但却很扎实，很稳，不打英雄球，他要打正确的篮球，在球队遇到困难时，他会顶住压力把球队扛起来，他真的可以扛起来，这就是意志的力量，他在季后赛的存在和表现让我相信意志是技术之外如此有魅力的一个东西。说到这里，必须对比下关注很久的哈登，我挺喜欢火箭的比赛，直到今年看了跟勇士的第五第六场比赛，我觉得以后哈登的比赛我可能不会再看了。哈登也许累了，也许他就是一个凡人，在至关重要的比赛里他总是很容易迷失自己，归根结底他没有莱昂纳德那种必胜的意志，没有那种倾其所有的勇气，我讨厌他。尽管这种对比可能并不公平，但是当你对他们的比赛倾注了希望，但是两边给你的却是截然不同的表现，你就很难不去对比。勇士最近四年三冠，了不起的勇士王朝，今年倒塌了，他们以一种悲壮不失尊严的方式倒下，我不是他们的球迷，但从心底里尊敬这只球队，虽说竞技体育没有“虽败犹荣”，但他们值得掌声，他们倒下的方式也十足让人动容，他们是战士，他们拼光了最后一颗子弹，说到这里就不得不说伤病。伤病今年猛龙夺冠，一方面他们有超星莱昂纳德，他们人员更年轻，执行力好，另一方面不得不说的就是勇士这边的伤病。勇士打火箭伤了杜兰特，他是球队的一号得分手，季后赛场均31分，他正在开启自己最佳的季后赛表演，但他突然倒下了，这对勇士来说绝对是当头一棒。但伤病本来就是竞技体育的一部分，没法去回避，每年的季后赛总会看到有人不断受伤，不断倒下，只是这一次倒下的是联盟第一大杀器—死神杜兰特。但即使如此，他们依旧可以凭借锋线防守优势，以及水花兄弟的外线优势轻松击败开拓者，甚至不少人开始调侃，没有杜兰特后勇士变得更好了，杜兰特才是限制库里的那个男人，直到总决赛打完第一场，杜兰特的攻坚能力，球场上的牵制作用才再一次被验证，第一场勇气输了，几乎从头输到尾。但毕竟是卫冕冠军，他们在杜兰特没加盟前就已经拿过冠军了，后面几场，他们凭借克莱，库里，追梦以及角色球员的发挥他们稳住了阵脚，但就在这时，杜兰特在总决赛第五场复出了，这时勇士已经处于1:3的绝对劣势，不知道背后是什么原因促使杜兰特复出，归根结底是杜兰特自己的事，他决定要上场。上场后他依旧是那个死神，连进三个三分，到就在这时，他一个变相，这次彻底伤了，跟腱断裂，哎呀……之前小腿拉伤时我觉得还好，也并没有特别的震撼，毕竟伤病在联盟太正常了，发生在杜兰特身上也无妨，他太累了，小伤休息一下未免不是好事，勇士依旧是冠军球队，但总决赛这么一下，加上前前后后关于杜兰特复出的讨论争议，不论你是勇士球迷还是猛龙球迷，看到一个联盟头号得分手跟腱断裂，都会替他觉得不值，这是会彻底改变他职业生涯的伤病，太遗憾了…如果说上帝为你关上一扇门，必会打开另一扇门，那总决赛第六场，就是再说，上帝觉得一扇门还不够，他要关上另一扇门。克兰汤普森也伤了，一次上篮下落时失去重心，左腿韧带撕裂，哎呀，太伤了，第六场勇士打的足够好，克莱发挥的足够出色，克六疯名不虚传，在第三节受伤之前已经砍落28分，他的投篮之好，猛龙在防守库里跟汤普森之间顾此失彼，四人防守两人，勇士内线出现了大量机会，他们把握的不错，不出意外，总决赛是奔着抢七去了，但就在那一刹那，勇士提前结束了总决赛，没有克莱，猛龙就会只掐库里一个强点，猛龙的box-one就在那等着呢，库里的无奈从他甩球的那一下可以清楚的看到。最终的第四节，范乔丹再次上线，那一个个三分瓦解了勇士所剩不多的希望，猛龙拿下了第六场，在勇士主场摘下了队史第一个总冠军，多伦多乃至整个加拿大迎来了他们的新王，大家疯狂的庆祝。关于伤病，有时会觉得这就像一场轮回。勇士四年三冠，他们一直在季后赛里保持了较为健康的阵容，即使有球员伤病，也是小伤，在伤病方面他们足够幸运，也可以说他们人员调配不错，伤病控制的很好，反观这几年勇士的对手，却总是会在季后赛出现较大、不能上场的伤病，比如2015骑士凯文乐福的报销，欧文总决赛第一场的伤退(总决赛再没复出)，2017年莱昂纳德（今年的FMVP）被踮脚，赛季报销，2018年火箭保罗受伤。所以这样看来，勇士一直都站在幸运的一方，但今年反过来了，三十年河东三十年河西，这里用不了那么久，今年伤病来到了勇士这边，而对面猛龙人员齐整，像极了前几年的勇士。所以面对伤病大家可以更坦然些，总冠军跟职业生涯，当然还是后者更重要，这里再次为杜兰特觉得可惜，每个人还是要对自己负责，别人的言论再怎么不堪，他们也不会为你负责，所以强大的内心太重要了，同时为莱昂纳德点赞。季后赛感悟猛龙的成功绝不是偶然，他们在赛季开始前进行了大量的人员调整，送走了球队老大德罗赞，从马刺换回了仅有一年使用权且一个赛季只打了九场比赛的莱昂纳德，这是一场豪赌，事实证明这是今年夺冠的最关键因素，接着在赛季中期交易来了小加，这个拥有丰富季后赛的男人，等等…观看猛龙的阵容，各个位置都有相对深厚的实力和季后赛经验。另外猛龙今年遇到的机会特别好，恰逢杜兰特受伤，这给了他们足够的希望，他们可以去疯狂夹击水花兄弟，放其他人，他们有不错的内线高度和防守优势，所以他们是对阵勇士的最佳球队之一。反观火箭，同样是杜兰特受伤，却眼睁睁的看着这样的机会流逝，还让库里打出了疯狂的比赛，实在不可同日而语。所以猛龙在把握机会方面真的很出众，最后我觉得猛龙真的很幸运，这可以从莱昂纳德抢七绝杀七六人，以及总决赛用对方核心遭遇伤病都可以看出，他们拥有难得的运气，加之他们对比勇士队，还有主场优势，团队氛围融洽，天时地利人和都全了，只待一个结局——猛龙总冠军。</li>
  <li>update：稍后阅读已发布到酷安市场：https://www.coolapk.com/apk/name.gudong.read需求背景当下手机内各种资讯信息爆炸，我们可以通过不同的APP去阅读，比如阅读微信公众号的推送，掘金社区的文章或者简书的文章，有时我们会在同一时间看到好几篇高质量的博文，但是当下却并没有充裕的时间去消化。为了更好的阅读吸收，这时候如果有一个工具可以把这些文章暂时收集起来，然后在自己闲暇时间再去阅读，是不是效果更好呢？稍后阅读就是自己为了解决这个问题开发的一个APP。当你在手机端阅读文章，想要把文章加入稍后阅读列表时，只需要找到系统分享，然后找到稍后阅读app的图标点击即可添加，如下所示，把一篇知乎文章加入稍后阅读：1、找到文章分享入口2、找到稍后阅读进行添加3、文章已经出现在了稍后阅读APP主页几点说明信息目前功能简陋，后续逐步优化目前还不支持PC网页插件收藏，后期支持目前还不支持云同步，后期支持意见反馈欢迎给稍后阅读提意见，你可以通过下面方式找到我。mail:gudong.site#gmail.com微博：大侠咕咚主页：咕咚</li>
  <li>地址：《斯坦福极简经济学》#《斯坦福极简经济学》的批注与划线在豆瓣阅读书店查看：https://read.douban.com/ebook/8747171/本作品由博集天卷授权豆瓣阅读全球范围内电子版制作与发行。©版权所有，侵权必究。章节：01人们卖弄的经济学原理只有50%是正确的我们为什么还要研究经济学？经济议题是我们生活中很多重要事情的核心，不只包括工作与收入，也包括健康、教育、退休生活及国家未来在全球经济中的地位。人们卖弄的经济学原理只有50%是正确的，但如果你不懂任何经济学常识或知识，就无法反驳，只能点头或耸肩。诚如英国女经济学家琼·罗宾逊（JoanRobinson）曾说的，研究经济学的理由就是“为了避免被经济学家欺骗”。社会应该生产什么？·应该如何生产？·谁来消费所生产的东西？搞懂经济学的概念，有助于去除对经济学的一些误解。经济学入门课程与政治立场是不相干的经济学是一个思考问题的架构。我要说的不是应否向企业增税，而是关于企业课税的任何敏感话题，都应该聚焦于实际上哪些人最后要来支付这笔税款很多经济取舍都有一个特色：它能帮助某些人，却同时伤害了其他人经济学家关心的是统计受到伤害或帮助的所有人，而不只是新闻报道里的几张脸孔。自利（self-interest）是组成社会的有效方式借由追求自身的利益，他频繁地促进了社会利益，比他认真设想促进社会利益还有效。借由追求自身的利益，他频繁地促进了社会利益，比他认真设想促进社会利益还有效。所以不同的眼光看待同样的问题，会是不一样的结论。从大众价值看自私是一种被人唾弃的品质，但是从经济学看，这是一只看不见的手，他在促进社会利益。“看不见的手”（invisiblehand）的概念，就是你在追求自己的利益时，可能也会给别人带来好处。“看不见的手”（invisiblehand）的概念，就是你在追求自己的利益时，可能也会给别人带来好处。双赢的局面。事实上，生活中很多事也是如此，要乐观看待得与失。自利是一股强大的力量，当它被适当引导时，就可为社会带来各种好处。课税就是征税的意思如果有某个东西你想要少一点，就用租税抑制它；想要多一点，就用补贴鼓励它。当你做一个选择时，你没有选择的东西就是经济学家所谓的“机会成本”。价格是由市场决定的，而非生产者。房东、石油公司、银行都是贪婪的，而且试图尽其所能赚取最多的钱，他们无时无刻不贪婪。他们提高房租、燃料价格与利率，不是因为想这么做（他们一直都这么做），而是因为市场的供需情况在某种程度上改变了，才促使他们做了这个决定。章节：02做自己最适合做的事，就有更好的生产力我们现今的世界，即使是看起来简单的消费品，也经常通过一个涉及全球的复杂过程来生产分工为生产商品的厂商与国家经济创造了显著的经济利益。它是如何办到的？分工使工人能聚焦于他们最适合做的事，又使企业能充分利用当地资源。从不同地区取得合适的工人和合适的资源，就有更好的生产力。分工使企业得以利用规模经济（economicsofscale）“规模经济”是个专有名词，用来说明大厂相对于小厂可以用较低的平均成本来生产。规模经济的概念，有助于这个世界合理化地运作。规模经济的概念，有助于这个世界合理化地运作。专业的人做专业的事，同时双方利益最大化。这也告诉我们，作为技术人，把自己的技术做到最好，对自己对公司都是利益最大化的方向。分工不只在一家厂商内部发生，也在一个社会甚至国与国之间发生。市场经济就是协调这种精密分工的社会机制。很矛盾的是，也许一个国家越富有，人们在独自、无助时的生存能力就越差。很矛盾的是，也许一个国家越富有，人们在独自、无助时的生存能力就越差。高度发达的社会必定有高度发达的分工，于此同时，人们都变得像一个螺丝钉，大家只会自己擅长的领域，其他领域的能力却大大下降。分工能增加企业、国家以及全球经济的产量。在市场经济里，商品的价值就是它的价格市场经济里的劳动价值，则表现在支付的工资或薪水上，这又提供了动机，使人们愿意提供对别人有价值的商品或服务每个社会都必须回答经济学的这三个基本问题：生产什么？如何生产？谁来消费？章节：03市场均衡点并不表示人们对结果感到满意分工导致商品与服务的交换，社会必须以某种方式协调所有的生产与消费。全球所有高收入社会，比如美国、加拿大、日本和西欧国家，主要是通过市场安排来调节它们的经济，且或多或少受到政府的影响厂商是产品的供给者，而家庭是产品的需求者。家庭是资本的供应者，而厂商是需求者钻石有很高的交换价值，如果你有一颗钻石要交易，那么你可以换到很多钱；但钻石没有很高的使用价值，既不能吃，也不能修剪经济学家谈到价格时，指的就是交换价值。一个商品的交换价值与其稀有性有关——商品值多少钱，和多少人想要拥有它有关。注重每样东西的价格，却不在乎其内在的使用价值因为经济学家关注交换价值，不关心使用价值。价格是视世界上的供需互动，即人们愿意且能够取得的状况而定的。“替代效应”（substitutioneffect），当商品价格越来越高时，人们可能会拿其他商品取而代之。“收入效应”（incomeeffect）。当商品价格上涨时，你的收入的购买力降低，因此你不能像过去一样每样东西都买，你会买较少的东西或是同样的东西少买一点“需求量”是指在某一特定价格下，人们想得到该商品的特定数量。“需求”则是价格与需求量之间的关系，指的是在任何可能的价格或每种价格下，人们想要该商品的数量是多少。需求量是一个点，而需求是一条曲线。供给是指商品的供给量与价格之间的关系。当商品价格上涨时，供给量也容易上升，这是因为当价格上涨时，厂商会变得更愿意供给商品。因此，需求曲线向下倾斜，而供给曲线向上倾斜。首先，当价格上涨时，厂商就会想生产更多商品，以赚取更多利润；再来，若价格上涨幅度够大，就会有新厂商决定生产并加入这个市场。供给量是指在某个特定价格下所生产的特定数量，供给是指在每种价格下生产多少数量。供给量是一个点，而供给是一条曲线。当供给量上升且需求量下降时，在某个点上，比萨的需求量会等于供给量，这个点就称为“均衡点”。当供给量上升且需求量下降时，在某个点上，比萨的需求量会等于供给量，这个点就称为“均衡点”。这个均衡点很有意思，也非常重要，也是市场最理想的一个点，供给量等于需求量，市场处于最佳状态，没有浪费，供需上方平衡。但事实上，大多时候都在这个均衡点两侧移动，市场不断的调节他们。均值回归？？个有效率的市场也没有多余的产品或未被满足的需求。是的，否则就是浪费均衡点这个位置有其特定的经济意义：价格与数量是有效率的，没有造成浪费。就如同一部有效率的机器，没有多余的动作或额外的零件，一个有效率的市场也没有多余的产品或未被满足的需求。商品与案例或许不同，但基本模式是一样的：考虑需求，考虑供给；从均衡点出发，思考需求或供给位移时会发生什么，思考新的均衡点会出现什么样的新价格与数量。供给与需求是一个架构，用来讨论市场如何决定价格和数量，以及这些市场价格与数量为什么会改变。了解了这一点，你就有经济学的基础了。商品与案例或许不同，但基本模式是一样的：考虑需求，考虑供给；从均衡点出发，思考需求或供给位移时会发生什么，思考新的均衡点会出现什么样的新价格与数量。供给与需求是一个架构，用来讨论市场如何决定价格和数量，以及这些市场价格与数量为什么会改变。了解了这一点，你就有经济学的基础了。需求是从消费者角度出发的一个曲线，供给是从生产者角度出发的一个曲线。二者都通过价格来影响购买量和供应量，价格高消费者的购买量就降低，而生产者则扩大生产以便获利，价格降消费者则扩大购买量，于此同时生产者赚的钱少了，此时就要降低供应量。在现实世界里，均衡点意味着只有这个需求量与供给量是平衡的，但并不表示人们对这个结果感到满意。买家总是会说：“我觉得我买贵了。”而卖家总会说：“居然卖得这么便宜。”在现实世界里，均衡点意味着只有这个需求量与供给量是平衡的，但并不表示人们对这个结果感到满意。买家总是会说：“我觉得我买贵了。”而卖家总会说：“居然卖得这么便宜。”市场很奇妙啊，之前的预测错了，均衡点并不是那么理想。但只要买家以最低的可能价格寻找他们偏好的东西，把他们的欲望、财务状况以及可能的替代品纳入考虑范围，然后只要厂商调整生产以响应价格的变化，供需模型就会很合理地运作。它是一个有用的工具、一种有力且准确的方式，以帮助我们描述和理解价格为什么处在那个水平，以及价格可能上升或下降的理由它是一个有用的工具、一种有力且准确的方式，以帮助我们描述和理解价格为什么处在那个水平，以及价格可能上升或下降的理由供给与需求让我们理解价格上升下降的道理供需模型可以用来描述世界各地、历史上各个不同时代以及从铅笔到比萨的各式各样商品的市场。章节：04在任何情况下都必须有所取舍供给与需求是不可避免的力量，但不是供给与需求的所有结果都是人们想要的。市场不是万能的。企业会说自己想要一个“公平”的价格，其实想要的是更高的价格。人们说房租、电力或汽油的价格“不公平”，是认为价格应该更低。企业会说自己想要一个“公平”的价格，其实想要的是更高的价格。人们说房租、电力或汽油的价格“不公平”，是认为价格应该更低。屁股决定脑袋，归根结底是利益。如果你设定的价格上限低于原本的均衡价，那么想购买的消费者的反应就会很热烈，但该商品的供给者则不然。需求量上升，供给量下降，结果就是供不应求。如果你设定的价格上限低于原本的均衡价，那么想购买的消费者的反应就会很热烈，但该商品的供给者则不然。需求量上升，供给量下降，结果就是供不应求。是的，这样的价格上限设定必定造成供不应求。政府可以抑制价格，但是在一个自由社会中，无法迫使卖家进行大量生产，而且各种规避价格上限的方式也不易管理。价格管制改变了每个人所面对的价格，某些需要帮助的人会接受这个价格，但更多不需要帮助的人也受到影响。若不采取价格下限方式，政府还可以通过食物券、学校午餐计划等方式补助消费者食物。像这样刺激需求，能帮助农民卖掉更多产品。明白为什么一些学校的午餐是国家补助了，其实泛而话之，所有政府补贴其实都是一种调整供给侧的一种策略。关于供给面，对于农地小于某个规模的农民，政府可以提供补助，有针对性地协助这些穷困的人。这两种方式可以避免农产品囤积在国内，或是把过剩产品倾销到其他发展中国家。这里也说明了看问题的深度，这种问题不能看到第一层，往往一个决策后面的动机都不简单，需要我们多角度分析经济学家自认为在任何情况下都必须有所取舍，而政客常喜欢隐瞒政策的真实成本。价格下限与上限看起来像是零成本的政策，因为政府不需要增加支出或减税。事实上，价格管制会掩盖成本。经济学家自认为在任何情况下都必须有所取舍，而政客常喜欢隐瞒政策的真实成本。价格下限与上限看起来像是零成本的政策，因为政府不需要增加支出或减税。事实上，价格管制会掩盖成本。就是懒惰还有无能但不管政治理念如何，他们的共同点都是：绝对尊重任何政策的各种取舍。但不管政治理念如何，他们的共同点都是：绝对尊重任何政策的各种取舍。哦哦，明白了，就是说不论设置价格上限还是下限，必定面对取舍，除非有一种价格管制可以把供需设置在均衡点附近，当然这是不现实的，所以大家只能接受这种取舍。章节：05增加的生产成本可以转嫁给消费者吗？供给弹性的定义是供给量变动的百分比除以价格变动的百分比对瘾君子来说，香烟的需求也是无弹性的。橙汁的需求是有弹性的。橙汁的需求是有弹性的。价格变化时，需求的变化程度大于价格的变化，说明这个物品的需求是有弹性的，比如橙汁，当价格提升10%，需求可能会减少10-20%，因为橙汁价格上涨，用户还有很多其他的可选项。反之，如毒品，用户没得选，没有替代品，价格变化后，并不能带来明显的需求变化，也就说明这种产品的需求无弹性。需求单一弹性的商品，弹性等于1。当商品需求量变动的百分比刚好等于价格变动的百分比时，我们说它是单一弹性（unitaryelasticity）。需求单一弹性的商品，弹性等于1。当商品需求量变动的百分比刚好等于价格变动的百分比时，我们说它是单一弹性（unitaryelasticity）。就是说与价格强关联的商品是无弹性的，而那些弱关联的产品则需求有弹性供给无弹性的商品，弹性小于1。供给有弹性的商品，弹性大于1。在这种情况下，供给量变动的百分比会大于价格变动的百分比，所以价格上涨10%可能会使供给量增加20%。10%这样的商品没有弹性，比如毒品或者高端稀缺商品，因为用户群体固定，而且他们对价格的变化不敏感。供给单一弹性的商品，弹性等于1。在这种情况下，供给量变动的百分比会等于价格变动的百分比，所以价格上涨10%会使供给量增加10%。借由百分比，就可以不必考虑汇率变动或英制与公制度量衡单位的复杂换算借由百分比，就可以不必考虑汇率变动或英制与公制度量衡单位的复杂换算用百分比计算弹性比较严谨在实务上可以广泛应用于价格设定，以及市场如何应对需求与供给的位移。关键是，任何乐团或厂商在设定价格时，都不应该只想着抬高价格，而应考虑其产品的需求弹性，可以用稍高或稍低的价格来试验，看看客户反应如何。关键是，任何乐团或厂商在设定价格时，都不应该只想着抬高价格，而应考虑其产品的需求弹性，可以用稍高或稍低的价格来试验，看看客户反应如何。需求弹性可以这么玩。。。当需求无弹性时，增加的生产成本往往可以转嫁给消费者；当需求有弹性时，增加的成本就会由生产者承担。这些咖啡的需求是有弹性的，当咖啡价格上涨时，成本只能小幅转嫁给消费者。，这些咖啡的需求是有弹性的，当咖啡价格上涨时，成本只能小幅转嫁给消费者。是的章节：06你的薪水最终由你的产出决定在每个人才市场，工资的均衡点是由该市场的劳动力供给量相对于劳动力需求量而决定的就如同厂商生产的很多商品与服务有各自的市场一样，劳动力市场也有很多不同的市场，比如护士市场、消防员市场、计算机程序设计员市场等。就如同厂商生产的很多商品与服务有各自的市场一样，劳动力市场也有很多不同的市场，比如护士市场、消防员市场、计算机程序设计员市场等。都是需求与供给的关系在商品市场，企业是供给者，家庭和个人是需求者；在劳动力市场，家庭和个人是供给者，企业是需求者在商品市场，企业是供给者，家庭和个人是需求者；在劳动力市场，家庭和个人是供给者，企业是需求者这也是一个循环工资改变了劳动力需求量而非整条需求曲线。产出（也就是不同的商品与服务）的需求变动，会改变劳动力需求。产出（也就是不同的商品与服务）的需求变动，会改变劳动力需求。需求变动，也就是用的人多了，需求多了，劳动力需求就变大，工资也就高了。厂商雇用工人的意愿，最终取决于生产力，即劳工生产多少东西。厂商雇用工人的意愿，最终取决于生产力，即劳工生产多少东西。效率很重要如果工人的生产力与工资有落差，厂商就不会雇用他们。如果工人的生产力高于工资甚多，那么在市场经济里，其他厂商就会用较高的工资挖墙脚。如果工人的生产力与工资有落差，厂商就不会雇用他们。如果工人的生产力高于工资甚多，那么在市场经济里，其他厂商就会用较高的工资挖墙脚。是这么回事。人口结构变化也会改变劳动力供给，例如在一个人口老化的社会，离开劳动的人会多于加入的人，即劳动供给力下降。社会趋势也会影响劳动力供给，例如预期什么人应该去工作。在每个人才市场，工资的均衡点是由该市场的劳动力供给量相对于劳动力需求量而决定的，较高的最低工资对就业的效果并没有显著影响。对于大多数有工作的低技能工人来说，提高最低工资可能会为其提供不错的利益，但对找不到工作的人来说，会使其蒙受巨大的经济损失。如果政府想提高低技能工人的工资，可以投资于技能训练计划如果政府想提高低技能工人的工资，可以投资于技能训练计划让工人自己提升自己的技能，而不是通过提供最低工资政府也可以补贴雇用低技能工人的厂商，使厂商能给付较高的工资；或者通过提供减税优惠给收入低于基本门槛的人，直接补贴低技术工人的工资，这项政策可增加工人收入，而不会带给雇主任何财务负担。政府也可以补贴雇用低技能工人的厂商，使厂商能给付较高的工资；或者通过提供减税优惠给收入低于基本门槛的人，直接补贴低技术工人的工资，这项政策可增加工人收入，而不会带给雇主任何财务负担。总之，除了提供最低工资这种最简单的方式，还有很多良性的方式，只是操作起来可能麻烦。工会提供两个基本功能。第一，找机会通过劳动契约的协商提高会员工资，并以罢工威胁为后盾。工会的第二个功能是培养一个更好的、更具生产力的劳动力，这可以通过一些显而易见的手段来达成，例如学徒制，以及一些更细腻的方式，例如给工人一种社群的感觉，并关心他们的工作状况。举例来说，相较于美国，很多欧洲国家的工会化程度非常高。由于受到歧视，在某些劳动力市场里，对于特定族群的需求是较低的。当雇主提供这些“慷慨的”福利时，员工仍然是支付这些福利的人，代价就是实际薪资变低。你的薪资与福利不是因为你的老板慷慨或喜不喜欢你而决定的，也不是由某个公平的标准来决定的。追根究底，劳动力是一个市场，你的薪资及福利，是根据你的产出定出的价格。你的薪资与福利不是因为你的老板慷慨或喜不喜欢你而决定的，也不是由某个公平的标准来决定的。追根究底，劳动力是一个市场，你的薪资及福利，是根据你的产出定出的价格。实际上就是个人对公司的产出价值。章节：07折现值是个很重要的观念在中世纪，罗马天主教认为索取贷款利息是一种“放高利贷罪”。目前，一些伊斯兰教国家仍然禁止收取利息资本的供给，来自那些储蓄资金的人在实务上，人们储蓄的资金量似乎没有随着报酬率的上升而大幅增加。相反，人们储蓄的金额似乎更取决于习惯、文化形态以及雇主因素。金融资本需求是来自现在需要资金并且愿意支付利息的人。利率低时，资本需求量较高。某个均衡报酬率下，你会得到储蓄与投资金额的均衡点资金有很多不同的市场，就像劳动与商品有很多不同的市场，主要差异在于被投资的对象，是大厂、小厂、个人还是政府？资金接受者的财务史是一个相关因素——它有良好的还款记录吗？这笔金融投资只是最终要收回的一笔贷款，或是想买该企业的股份？这些因素都很重要，会决定每个金融市场的供给、需求与报酬率。相较于未来还款所付出的代价，你该如何计算这笔贷款目前的价值对我来说，慢慢还房贷比立刻付清更容易，但这两者的折现值是相同的。企业还可以用两种方式筹钱——向银行借钱或是发行债券。债券有面额、利率与期限三项要素。债券只是厂商借钱的一种方式，但不是向银行借，而是向买家借，这些人可能是个人或组织，例如退休基金或投资公司。债券所付的利率是根据风险而变动的。高获利的企业，像沃尔玛，可以用相当低的利率发行债券，因为人们知道它很可能会还钱。同样，政府至少是稳定的机构，也可以用较低的报酬率来发行债券。相反，较不稳定的企业可能会发行高利率、高风险的债券，或称“垃圾债券”（junkbond）债券所付的利率是根据风险而变动的。高获利的企业，像沃尔玛，可以用相当低的利率发行债券，因为人们知道它很可能会还钱。同样，政府至少是稳定的机构，也可以用较低的报酬率来发行债券。相反，较不稳定的企业可能会发行高利率、高风险的债券，或称“垃圾债券”（junkbond）国内的债券概念很少。企业筹资的最后一种方式是通过有价证券，较常听到的是公司股票。股票不像债券有预先决定的利率，也根本无法保证股票持有人会获得固定利息或任何报酬。买卖股票可能比债券的报酬率更高或更低，甚至会出现负数。股票不像债券有预先决定的利率，也根本无法保证股票持有人会获得固定利息或任何报酬。买卖股票可能比债券的报酬率更高或更低，甚至会出现负数。这也是股票的风险，高风险高收益。为了大幅扩张，公司可能会发行更多股票，例如并购另一家厂商，但不能无限制发行股票，因为股票是公司的部分所有权，发行越多股票，表示这家公司的所有权被分割得越细。如果一家公司有100股股票，在来年发行另100股，那么原始股东的所有权比重就会被稀释，这家公司就很可能被视为差劲的投资标的。如果一家公司有100股股票，在来年发行另100股，那么原始股东的所有权比重就会被稀释，这家公司就很可能被视为差劲的投资标的。股权稀释章节：08人一生积累财富的关键是什么？从供需观点来看，退休储蓄的决策牵涉到资本市场的供给面。人们储蓄与投资，提供资金给资本市场，就是希望在没有太多风险的情况下累积财富。人一生累积财富的关键，在于复利（compoundinterest）的力量。多样化是有效的，因为某些无法预期的差劲投资，会被其他出人意料的良好投资所抵消。因此，就像俗话说的，不要把鸡蛋放在同一个篮子里。对单个投资人来说，也许最容易的多样化做法就是投资共同基金，把一组股票或一组债券结合在单项投资里。“流动性”，是把投资转换为现金的意思。“流动性”，是把投资转换为现金的意思。基金的流动性就比股票差，它的交易都是T+2而股票可以T+1，当然目前虚拟货币的流动性更好，T+0一般而言，在其他条件（例如报酬与风险）不变的情况下，你会偏好流动性好的投资。而有些投资所得是要课税的，在你卖掉该投资时才付税金，投资股票与房子的资本利得也是。税收减免固然造福了投资人，但是，在凡事有得必有失的世界里，税收减免越多，意味着别的东西越少。税收减免固然造福了投资人，但是，在凡事有得必有失的世界里，税收减免越多，意味着别的东西越少。想到了阴阳学，万事互补，抱阴负阳。伯顿·马尔基尔（BurtonMalkiel）所说，以睡眠安稳量表来反映风险程度：如果把钱投入这项金融投资，你晚上睡得安稳吗？多样化的公司债投资组合，或投资于这类债券的共同基金在大部分情况下，债券的报酬率是一个固定利率，这表示如果通货膨胀与市场利率上升，你就会被锁在这个较低的固定利率上，因而吃了亏。多样化的蓝筹股投资组合高成长股票投资组合贵金属所有的投资忠告最终都基于一个事实：你需要存些钱，越早开始越好。无论你是二十几岁、三十几岁、四十几岁还是五十几岁，总是有上百万个理由让你无法存钱，但如果你不稳定储蓄，到了60岁或65岁才想求得锦囊妙计，让你在退休后享有高水平的收入，那根本是缘木求鱼。章节：09垄断的本质是对勤劳者课税政府在经济上所扮演的角色之一是制定法规架构，鼓励追求获利的正面结果，并抑制上述黑暗的经济力量。“企业”的含义企业所有权可分三类：独资（proprietorship）是由单个人所有；合伙（partnership）是由一群人所有；公司（corporation）则是有法律实体的组织，独立于其持有者，可能由一人或一群股东所有完全竞争产业的主要特征是价格接受（pricetaking），也就是说，完全竞争的企业必须接受市场给定的价格。因此，完全竞争市场中的企业，大都只能赚取同样低的利润。要如何才能达到垄断状态？通常是用一些障碍，阻止其他厂商进入市场。事实上，赞成专利的经济论点是：允许专利在一段期间内的独占地位，可以促进创新。这种有限制期的垄断，其权衡取舍的是公共的利益。和完全竞争市场不同的是，独占企业在市场有设定价格的能力，可让价格高于生产成本，因此可赚取较高利润。没有竞争者，厂商就可以放松；而在一个完全竞争的市场中，你一刻也不能放松企业领导人通常不太赞成竞争。企业领导人通常不太赞成竞争。大家都是来赚钱的，肯定都不怎么乐意去消耗.竞争让商人过得非常辛苦。相反，消费者应该赞成竞争，因为竞争可以提供更低成本的创新产品，市场竞争是对消费者最有利的方式。章节：10是大池塘里的小鱼，还是小池塘里的大鱼经济学家看似终生歌颂竞争市场，但几个世纪以来，他们已充分意识到，企业通常试图避免竞争即使只是为了欢笑作乐，同业也很少聚在一起；倘一旦有了对话，往往不是密谋对大众有所不利，就是共谋涨价手段美国基本上是一个自由市场，允许企业自己做选择，但如果企业的选择会限制竞争，且会转嫁成本给消费者，消费者就会要求政府介入。在美国，企业合并案中，若有任何一方年营业额超过1亿美元，当事人在合并案成立前就必须通报政府美国政府不仅有权力阻止或限制企业合并，还可以分拆垄断者的大公司，20世纪早期的标准石油（StandardOil）即是有名的瓦解案例章节：11最佳的管制法或许就是解除管制市场竞争不可能正常运作，反而会导致所有厂商蒙受巨大损失而无以为继。市场竞争在公用事业中不易运作历史上，公用事业定价最常见的方法是成本加成管制法（cost-plusregulation）：精算过公司的生产成本后，允许一个较低的获利水平（通常以一般企业在竞争市场可赚到的报酬为依据），且锁定价格以便能获取该水平的利润。成本加成管制法的替代方案，是价格上限管制法（price-capregulation）。在这个制度下，管制者（也就是政府）设定一个价格，让被管制的厂商在未来几年可以依此收费。管制者似乎经常会发展出一种斯德哥尔摩症候群（StockholmSyndrome）——同情受管制的厂商，以致其判断力受到蒙蔽，无法保护消费者。在某些情况下，最佳的管制法就是解除管制，美国20世纪70年代解除管制的大型试验，让消费者的选择如雨后春笋般多了起来，到了90年代末期，每年因降价让消费者省下的钱高达500亿美元。，美国20世纪70年代解除管制的大型试验，让消费者的选择如雨后春笋般多了起来，到了90年代末期，每年因降价让消费者省下的钱高达500亿美元。解除管制后，市场活了。解除管制也是一种权衡取舍随着技术的快速演变，鼓励多样化技术会比政府选定一项技术然后加以管制来得更好。市场竞争的力量可以鼓励创新与提高效率，并惠及消费者。但是，在某些泾渭分明的情况下，当市场竞争无法良好运作时，政府可以扮演有用的角色，作为经济竞争的仲裁者。当市场力量的结果似乎不受欢迎时，真正的挑战是发掘根本问题，并据此设计对策当市场力量的结果似乎不受欢迎时，真正的挑战是发掘根本问题，并据此设计对策发掘根本问题很重要如果政府单单施以管制手段，市场通常会运作得很差；当管制手段也能尊重激励因素与市场力量时，它反而可能运作得很好。章节：12主张绝对的零污染是不可行的相较于高收入、市场导向的国家，低收入、市场机制差的国家通常环境问题更严重。例如中国与苏联，便遭遇了严重的污染问题。同时，最近几十年，即使是在经济增长的情况下，美国的空气和水的平均质量也有所改善。与污染有关的公共政策会让那些制造污染的人正视问题，把污染成本纳入考虑范围。与污染有关的公共政策会让那些制造污染的人正视问题，把污染成本纳入考虑范围。这不是一种更好的治理垃圾的方式吗对生产者每单位的污染课征污染税或污染费。这种费用对减少污染创造了明显的激励作用对生产者每单位的污染课征污染税或污染费。这种费用对减少污染创造了明显的激励作用有弹性的方法另一个市场导向的环保政策，是“可交易的许可”（marketablepermit）制度。可交易的许可给污染者排放某个污染额度的法律权利，且通常获许可的污染量会随着时间递减。如果污染者排放的污染量未超过许可额度，那么剩下的额度就可以卖给别人，也就是“可交易”这个词的意思。很聪明的做法过去的20～30年，环保政策已经从单纯的命令与控制转变成市场导向机制。一般而言，经济学家偏好这些机制。想出减少碳排放的方法不难，真正的困难是：用市场导向、弹性的方法来执行，用最低的经济成本来限制碳排放。从我务实的经济学家角度来看，必须声明零污染不是一个实际或有用的政策目标，零污染意味着关闭大部分产业和停止大多数经济活动。我们所有的政策选择，无论是命令与控制还是市场导向的环保政策，都需要允许存在一些污染。主张绝对的零污染是不可行的，也不够理性。合理的政策目标是平衡生产效益与污染成本，换言之，让生产的社会成本与社会效益彼此平衡。从我务实的经济学家角度来看，必须声明零污染不是一个实际或有用的政策目标，零污染意味着关闭大部分产业和停止大多数经济活动。我们所有的政策选择，无论是命令与控制还是市场导向的环保政策，都需要允许存在一些污染。主张绝对的零污染是不可行的，也不够理性。合理的政策目标是平衡生产效益与污染成本，换言之，让生产的社会成本与社会效益彼此平衡。嗯嗯，很有智慧章节：13自由市场并不保证会给发明者奖励推动创新的关键因素，是创新者从研发投资中得到大部分经济利益的能力，经济学家称之为“专属性”（appropriability）。即使有专利、商标、著作权和商业机密等法律保护，创新成功的公司也只能拿到它所创造价值的30%～40%，其他价值则会落入消费者或其他厂商口袋。企业投入研发的优势之一，是它较能聚焦于短期内会有实质效益的应用技术政府资助的研究经常会直接开放给公共领域，任何想要的人都可利用其研究成果。企业资助的研究通常受限于专利与商业机密法，因此在很多案例中，政府资助的研究通过市场经济能更快地散播与应用。专利：保护创新，也阻碍创新补贴创新的最终目的其实是使消费者受益，而非使厂商更容易长期赚到庞大利润。专利是用来预防竞争的，但对其他想进入市场的竞争者而言，这些专利可能会变成巨大的（有时是永远的）障碍，并且阻碍额外的创新。经济创新的最终目的不是要讨好创新者，而是要鼓励稳定持续的创新，以提高社会的生活水平。经济创新的最终目的不是要讨好创新者，而是要鼓励稳定持续的创新，以提高社会的生活水平。是的章节：14缴税是用强迫的方式克服搭便车问题公共物品：顺着每个人自利的本性，将无法创造公共物品，所以政府必须征税来建设。公共物品：顺着每个人自利的本性，将无法创造公共物品，所以政府必须征税来建设。哈哈，说的好有道理，如果顺由人性，那么谁都不会主动拿出自己的钱去做对公共社会有利的事。我们每天都会用到一些公共物品，但很难设想要从市场竞争机制下的私人企业那里购买，典型的例子有国防、基础研发、道路、警察和消防局。这些项目都归类在经济学家所说的“公共物品”（publicgoods）中。公共物品有两个重要特性：它们是非竞争性（nonrivalrous）与非排他性（nonexcludable）。我们称为公共物品的很多东西，也并非完全是非竞争性或非排他性的，但它们已经接近这两个特性，使得私人市场很难提供托马斯·杰斐逊（ThomasJefferson）所言：“我将思想传授他人，他人之所得，亦无损于我之所有；犹如一人引我的烛火点烛，光亮与他同在，我却不因此身处黑暗。”托马斯·杰斐逊（ThomasJefferson）所言：“我将思想传授他人，他人之所得，亦无损于我之所有；犹如一人引我的烛火点烛，光亮与他同在，我却不因此身处黑暗。”一种无私奉献的精神，当然这里的前提是自己也没有受到影响。当某些人从公共物品中受益，却没有付出相对合理的成本时，经济学家把这个问题称作“搭便车”（free-rider）政府课税即是要求公民为公共物品付费，无论每位公民是否真的想要该种类与数量的公共物品。政府提供公共物品，其实是政府收税来支付这些商品，至于是由公务人员还是民间提供，则仍有待商榷。缴税是用强迫的方式克服搭便车问题：如果你不为公共物品纳税，你就要坐牢，这些利益与成本是隐性社会契约的一部分。如果社会成员不用某种方式合力提供公共物品（经由政治或社会机制），则大家都会蒙受损失。章节：15社会福利计划是在援助与激励之间拔河美国政府是以收入低于贫穷线的人口比重来计算贫穷率。如果一个富裕的社会不帮助穷人，似乎是残忍、不道德的，但如果社会帮助穷人，就会在某种程度上减少了穷人自力更生的动力。如果一个富裕的社会不帮助穷人，似乎是残忍、不道德的，但如果社会帮助穷人，就会在某种程度上减少了穷人自力更生的动力。所以穷人有穷人的原因，对于我们自身，要自强自立。国运用的另一项政策是薪资收入租税抵减，当低收入家庭赚钱时，给其额外的收入，以抵消政府撤回的其他福利。从20世纪80年代晚期到90年代中期，各州通过一连串的福利改革，要求得到福利的人回去工作（或参加职业培训计划），通常是在申请到福利的两年内。贫困家庭临时补助、薪资收入租税抵减、医疗补助保险与食物券，并非美国政府对穷人的全部协助。大多数计划都在援助与激励之间拔河，最终的目标应该不只是分配金钱，让人们有高于贫穷线的收入，而是帮助人们发展他们需要的技能，让他们在不断变动与成长的社会里谋生。大多数计划都在援助与激励之间拔河，最终的目标应该不只是分配金钱，让人们有高于贫穷线的收入，而是帮助人们发展他们需要的技能，让他们在不断变动与成长的社会里谋生。国家希望贫穷的人越来越少，也提供各种激励机制去帮着这些人，自助者天助，对于普通人一定要自立，也要去观察国家的政策，借力国家，让自己变得更好。章节：16什么样的收入不均程度算合理？贫穷率下降时，很有可能社会贫富不均的程度便会加剧。例如，经济强劲增长，会帮助穷人变得稍微有点钱，但会让富人变得更有钱。同样，当股市大跌、经济衰退时，很可能穷人会稍微变穷一点，但富人可能会输个精光；在这种情况下，贫穷率提高了，但收入不均程度反而下降了。贫穷让人们没有能力负担基本的生活必需消费，收入不均更多的是影响人们对公平性的感受。在一个公平的社会，报酬和不平等不应该受到出生、家庭背景甚或运气的摆布，而应该与人们的努力和技能有合理的因果关系。科技并不是收入不均恶化的唯一原因科技并不是收入不均恶化的唯一原因收入不均是技术发展的一个结果之一。根据研究估计，收入不均的扩大，约有两成是由全球化对工资造成的压力导致的。什么公共政策可以减少收入不均？一个显而易见的办法，是对高收入的人课征重税。根据美国国会预算办公室的数据，1980年，收入排行前20%的人的纳税额，占联邦政府总税收的56.3%，其中不仅包括所得税，也包括社保、医疗保险、消费税，以及他们最后通过公司所得税间接支付的钱。到了1990年，这个比重上升至57.9%，1995年占到61.9%，2000年占到66.7%，2007年占到68.9%。如果只看收入排行前5%的家庭，他们在2007年所缴的税，占联邦政府总税收的44.3%。总之，那些收入较高的人得到了更多的收入，但他们缴纳税金的比重也增加了。用于减少收入不均的政府预算，不一定要直接付现金给贫穷家庭。可采取扩大公立学校或学校午餐计划预算的形式。虽然收入不均逐年恶化使我烦恼，但我比较担忧的是穷人每天面对的生活条件，而不是富人的高收入。章节：17品牌可以让消费者对质量比较放心然而，现实世界充满了信息不完全的情况，这可能会对市场运作方式造成问题。由于信息不完全，风险和不确定因素就会来搅局。公司的担保、保证和服务合约将有助于承担消费者的风险；商标和品牌则可以让消费者对商品质量比较放心。教师、护士、会计师、律师、物理治疗师和不动产经纪人持有的资质证明也是如此。在金融市场，信用评级、放款担保人和抵押品等机制也有一样的效果。政府介入与制定信息披露的规则，在大多数情况下，这类机制能让市场顺利运作，例如，政府规定食品包装上要标示成分，以使消费者在选购时能有更充分的信息做参考；或要求企业披露某些财务信息并接受外部查账。政府介入与制定信息披露的规则，在大多数情况下，这类机制能让市场顺利运作，例如，政府规定食品包装上要标示成分，以使消费者在选购时能有更充分的信息做参考；或要求企业披露某些财务信息并接受外部查账。嗯嗯，原来如此，商品上的信息披露是一种强制行为，为了让消费者对产品更加了解。保险市场包括个人保险（例如健康保险、汽车保险、财产保险、人寿保险）和社会保险（例如社保退休金、失业保险、职业灾害补偿、灾难救济）。第一个主要问题叫作道德风险（moralhazard），意思是拥有保险会使人不太会采取预防措施来避免或阻止坏事发生。第一个主要问题叫作道德风险（moralhazard），意思是拥有保险会使人不太会采取预防措施来避免或阻止坏事发生。这个确实符合一般人的思维保险市场的另一个重大议题是逆选择（adverseselection）：特别可能遭遇坏事的人更可能购买保险，而风险很低的人不太可能会购买。医疗支出占国内生产总值（GDP）的比重，美国是15.7%，加拿大、法国和德国介于10%～11%，日本和英国大约是8%。总之，美国医疗领域的人均支出是经济实力相当的其他国家的两倍。章节：18谁能监督代理人？企业领袖有能力以低廉的价格提供高质量的商品与服务，并为员工提供好工作，政治家则能在符合公众最大利益的原则下制定有远见的法案，但我们也知道有些企业领导人会搞垮公司以自肥，有些政治人物对保住官位和收回扣的兴趣，远大于为民谋福利。在代理人问题中，委托人这一方想激励对方，也就是让代理人以某种方式尽力工作。在政治领域，公民是委托人，而政治人物是代理人，政治人物在理论上应依公民利益而行动。以公司而言，股东是委托人，而经营者是代理人，经营者按理应该为股东利益而做事。雇主和员工的关系，也有代理人问题。在大部分公司中，股东选出一个董事会来直接负责雇用和监督高级主管董事会是股东选出来监督公司管理层的？积极的董事会可以监督公司，但能做的有限。哦哦，原来如此。给投资人操作建议的股票分析师、放款给企业的银行、财经媒体记者，这群人存在的目的都是为了评估公司的健康状况，也有力量来监督高级主管对民主国家的很多公民来说，无论政治信息本身透露了什么，理性的行为是绝不考虑对该信息多花费成本。不管该免费信息对理性的公民透露政党之间的差距有多明显，或自己还不确定要支持哪一党，他都明白自己的一票几乎没有机会影响选举结果。事实就是如此，所以大家也懒得陪演戏。如果大多数人都不表露心声，有谁会呢？答案是特殊利益团体。它们人数虽少，但组织健全，可能会对立法议员施压，牺牲别人的利益而制定对其有利的公共政策。为了这些特殊利益团体，政治人物可以挟选票的力量制定法律，以使单一特定区域受益，地方建设经费即是一例，此时民主制度面临好处集中在有限地区，而成本由全国人民负担的问题。如果大多数人都不表露心声，有谁会呢？答案是特殊利益团体。它们人数虽少，但组织健全，可能会对立法议员施压，牺牲别人的利益而制定对其有利的公共政策。为了这些特殊利益团体，政治人物可以挟选票的力量制定法律，以使单一特定区域受益，地方建设经费即是一例，此时民主制度面临好处集中在有限地区，而成本由全国人民负担的问题。也说明了28原则政府国防预算的通过，也是军事基地和武器承包商所在地区的立法议员们极力推动的结果政府国防预算的通过，也是军事基地和武器承包商所在地区的立法议员们极力推动的结果屁股决定脑袋呗。府是由一群代理人组成的，选民和公民试图引导和控制方向，但不一定会有成效。即使是最有企图心的政府措施，也可能使政局恶化，而不是变好。章节：微观经济学原理总结思考经济政策时，你的挑战在于保持务实。要诚实面对市场发生的问题，答案要明确。对政府的作为要实事求是，坦然面对权衡取舍和风险。当你采取这种方法时——无论最后得出什么样的政策结论——你的思考方式就像经济学家了。看待问题要看到取舍，一个政策为什么设立，设立的意义，对那些人有利，对那些人制衡，同时是否会影响三方的人，都是要分析的。章节：19人均GDP是一个有用的比较工具宏观经济学的观点是总合的、由上而下，它把整个经济视为一个大型有机体，内容包括经济增长、失业、通胀、贸易差额等。微观经济学关注商品、劳动力及资本的个别市场，以及垄断、竞争、污染、科技、贫穷、收入不均、保险和治理等议题，宏观经济政策的四个目标是：经济增长、充分就业、物价稳定和国际收支平衡。财政政策是政府税收和支出的政策，包括政府预算和预算赤字。货币政策是指中央银行的政策，它会影响利率、信用以及社会上借款与放款的数量。2009年美国的GDP是14.2万亿美元。从生产面来看，13.4%是耐用品，例如冰箱和汽车；另外13.4%是非耐用品，例如食物和衣服；66.2%是服务；7.7%是公共基础设施建设（这些数字加起来超过100%，是因为大约1.1%的产品是存货，尚未卖出，所以未被计入产出）。2009年美国的GDP是14.2万亿美元。从生产面来看，13.4%是耐用品，例如冰箱和汽车；另外13.4%是非耐用品，例如食物和衣服；66.2%是服务；7.7%是公共基础设施建设（这些数字加起来超过100%，是因为大约1.1%的产品是存货，尚未卖出，所以未被计入产出）。服务以后也会是中国的大头人们说我们生活在一个服务业的社会，指的就是这些最近几年，美国进口已经大大超过出口，这表示有贸易逆差GDP=消费+投资+政府支出+出口-进口。是谁在计算美国巨大的国内生产总值呢？答案是美国商务部管辖下的经济分析局（BEA），它会从各种调查和信息来源中收集资料，有些按月，有些按季，有些则按年。此外，有很多东西会影响人们的生活水平与幸福感，但无法像商品般被量化。GDP不准确，很多东西无法量化。章节：20为什么人们重视经济增长？经济增长会随着时间产生复利效果。年增长率的若干差距，会在一代或两代人后造成生活水平的巨大差异。经济增长会随着时间产生复利效果。年增长率的若干差距，会在一代或两代人后造成生活水平的巨大差异。经济每年增长3%，要算上复利的力量，随着时间的推移，后面的增长数量其实很大。国民收入低的这些国家，并不是因为全球化才变穷，而是因为和全世界其他地区几乎完全脱节。经济长期增长的根本原因是生产力的提升，也就是说，每一工时的产出增加，或是每位员工的产出增加。章节：21经济衰退，薪资很少会大幅下降失业会带来社会问题，从家庭的沉重压力到健康变差，甚至引起社会犯罪。失业还会增加民众对政府支出（福利及社会服务）的需求。经济学家把失业分成两类：自然失业和周期性失业。自然失业来自动态衰退以及员工就业与产业的变动。失业的第二个类别是周期性失业，“周期”是指经济从谷底到峰顶的经济周期。绝大多数企业为了保住原本的业务，不会选择削减工资，而是以减少雇用或降低劳动力需求来应对。政府有两个主要工具可鼓励支出，我们会在后面的章节详细讨论。一个工具是财政政策，利用减税来鼓励家庭和企业花钱，或是增加政府的直接支出。另一个工具是货币政策，中央银行可以降低利率，鼓励贷款买车或买房，以促使相关厂商雇用更多人。欧洲国家的最低工资很高，工会更强大，更强烈地抵制裁员。。因此，长期而言，工资增加的基础在于提升员工的平均生产力，亦即更好的教育投资、更好的实物资本设备投资，以及发明并采用新技术。一个国家若能把这三个因素结合在一起，就能达成使劳工工作好且薪资佳的理想目标。章节：22通胀率走高会使市场运作不顺畅通货膨胀，是指任一商品与服务的价格全面上升的现象。为了衡量整体价格水平的提高，有必要收集很多不同商品价格变动的数据，并找到某种方式来计算平均价格水平的变动。基本的方法是定义“一篮子”商品，其中每个商品的数量代表一个家庭在某段时间内的典型消费。然后，你可以计算购买整篮商品（不是任一个别商品）的总成本随着时间而变化的情况。，目前为止，在美国用固定利率借钱的最大债务人就是美国政府，因此通胀能使政府所有负债的实际价值降低虽然较高的通胀率可能有很多不同的原因，但都和整个社会太多的钱追逐太少的商品有关。虽然较高的通胀率可能有很多不同的原因，但都和整个社会太多的钱追逐太少的商品有关。钱太多了，年通胀率3%～5%对经济其实没有多大影响。有些经济学家认为全球很多中等收入国家发展得很好，经济快速增长，事实上其年通胀率高达10%、20%甚至30%。一旦年通胀率达到40%，章节：23贸易顺差的真正意思是借钱给国外出口大于进口，该国就有贸易顺差（tradesurplus）。进口大于出口，该国则是贸易逆差（tradedeficit）。在贸易余额中，顺差代表金钱流入该国，而逆差代表金钱流出该国。贸易顺差真正的意思是，结算下来，一国是借钱给国外，且有对外投资的流出。国民储蓄与投资恒等式告诉我们，美国宏观经济有两大资金来源，且必须等于另外两大资金需求。根据这个观点，贸易逆差是一个额外的资金来源，这笔钱流入美国后，由企业或美国政府借走。无论国家还是个人，借款后的挑战都是如何运用这笔借来的资金，使其产生充分的效益或回报以偿还贷款。章节：27权衡性财政政策，知易行难总需求=C+I+G+X-M，也就是消费+投资+政府支出+出口-进口。在这个方程式中，有三个因素特别容易受到财政政策的影响，其中最明显的是政府支出，消费和投资也会受到租税政策的显著影响。减税可以刺激消费与投资，增税则会减弱它们。因此，财政政策有能力使总需求移动。使社会的总需求增加或购买力提高的政策，称作“扩张性”（expansionary）宏观经济政策，或称作“宽松”（loose）的财政政策。扩张性政策包括减税与增加支出，两者都会使更多的钱流入社会。反之，用来降低总需求的政策，称作“收缩性”（contractionary）政策或“紧缩”（tight）的财政政策。增税或减少支出的政策属于收缩性财政政策，会降低社会的购买力。这种财政政策的基本目的是平衡经济衰退和扩张。通过提供实际利益的方式来刺激经济是更明智的，只要你的目标是提高总需求，至于要怎么做，从宏观经济的观点而言，是次要的。这些出人意料的高税收并非新法规的结果，而是自发性稳定机制使然，它有助于预防经济扩张太快而引发通胀。一般而言，GDP减少2%，会导致财政政策的自动补偿机制将GDP拉回1%。为什么许多经济学家都怀疑权衡性财政政策？首先，它有时机的问题。自发性稳定机制内建于支出计划与税制中，因此它在经济衰退或复苏出现时可以实时反应。相反，权衡性财政政策要到问题发生时才制定，到那时可能已经来不及了。权衡性财政政策的第二个困难是，它会引起不受欢迎的副作用。很多经济政策制定者都要求政府制定反经济周期的财政政策，亦即在经济差时花钱，在经济好时节俭。但政治上很难这么做，为什么？想象经济飞快增长的情况，税金像洪水般涌入，经济学家说：“不要花掉这些钱！要累积非常大的盈余，削减支出并提高税收。”这是一个很好的反经济周期政策，但它在政治上不容易获得认同。在经济好时节制政府支出，经济差时扩大支出，这种敏锐的洞察力不是一般政治人物能有的智慧。降息有助于刺激总需求，升息则会抑制总需求。有些经济学家认为，中央银行与自发性财政稳定机制已足以解决大部分的短期问题，而权衡性财政政策应该留给特殊或长期情况使用。有些经济学家认为，中央银行与自发性财政稳定机制已足以解决大部分的短期问题，而权衡性财政政策应该留给特殊或长期情况使用。权衡性政策操作起来不灵活，没有调整利率等迅速因此，当经济学家对如何实施宏观经济政策意见不一致时，其实大部分原因是党派立场不同。章节：28美国累积负债的长期前景很糟糕李嘉图等价定理认为，当人们注意到政府预算赤字偏高时，便预期在未来某个时间点会增税，因此必须增加储蓄。以此理论模型推导，个人储蓄增加可能是为了提供资金作为政府借款，但这件事有什么证据？即使是坏掉的钟，一天也有两次时间是准确的每个理论都会偶尔正确，但不表示以后都有效，李嘉图等价定理并不能合理解释美国经济状况。如果政府借越来越多的钱来管理它的赤字，就会减少民间企业可取得的用于投资的资金。如果政府借越来越多的钱来管理它的赤字，就会减少民间企业可取得的用于投资的资金。按照《贷款通则》对借款人的条件有严格的限定，排除了地方政府直接向商业银行借款的可能。为解决地方基本建设项目资金，由地方政府指定借款主体，以地方政府未来预算资金作为还款来源，用地方政府信用作为担保的借款可称之为地方政府借款。地方政府指定的借款主体向银行借款已成为地方政府筹措资金的主要手段。如同挤出效应理论所示，预算赤字与私人投资会彼此抵消。章节：29金钱对我们没有任何用处，除非把它花掉货币：交易媒介（mediumofexchange）、价值储存（storeofvalue）、计账单位（unitofaccount）。通货（硬币与钞票）只是货币总供给的一部分。通货只是M1的一半、M2的1/10左右。因此，当你要谈现代社会的货币时，不应只想到钞票与硬币，应该想的是银行账户。2009年，美国银行业的总营收超过8000亿美元，其中大约3/4（6000亿美元）来自借款人付给银行的利息，剩下的1/4来自手续费。手续费一直是银行逐年增长的收入，尤其是用复杂的偿还条件安排放款的大型银行政策制定得好，将有助于总需求在未来的增长速度与总供给和潜在GDP保持一致。这样，宏观经济就可以保持平衡状态，章节：30中央银行既有权力，也有责任美联储主席（美国中央银行行长）是世界上最有权力的经济要角。中央银行有三个传统工具，可在银行与货币的架构内运作：法定准备金（reserverequirement）、贴现率（discountrate）、公开市场操作（openmarketoperation）。章节：31你可以牵马到河边，但不能强迫它喝水在经济不景气时，用较宽松的货币政策来降低利率，刺激总需求朝潜在GDP水平迈进，并降低周期性失业率。因此，经济衰退时的标准做法是中央银行出面降息，即推出扩张性、宽松的货币政策。章节：32不用扩大贸易就很富裕的国家根本找不到这种相似产品的贸易，对两个国家的经济有什么好处呢？第一个好处是使较小的国家善用规模经济。规模经济。然而，国际贸易只是有助于经济增长的众多因素之一，可能不是最重要的因素。教育程度低、投资少、运输与通信基础设施缺乏、贪污腐化、法律不健全的国家，即使扩大国际贸易，也无法挽救一国经济。此外，全球化的好处是实实在在的，但这些好处是产业重新整合，并把当地经济导向全球经济的结果。章节：33全球化的整体方向将提高全世界的生活水平虽然大多数经济学家都支持自由贸易的力量，但他们也承认自由贸易有可能造成经济混乱或崩溃。进口配额（importquota）是对进口采取数量限制，关税（tariff）是提高进口成本的一种税。受保护的产业面临的国外生产者的竞争变少，因此可能获得较高价格，赚取较高利润。保护主义，用经济学术语来说，是政府对国内产业提供间接补贴的一种方式，由国内消费者用较高的价格埋单。毫无疑问，保护主义是一种补贴手段，有助于留住某些产业的就业机会。经济理论也认为国际贸易与国家的整体就业水平无关。自然失业则与劳动力市场因素有关，这两种失业都与贸易无关。工资最终取决于生产力如果自由贸易提升了生产力，平均工资就会逐渐增加。大部分订单转移的原因不在于某些产品销售的扩大或缩减，而在于国内竞争、公司的管理阶层与工人的素质，以及和国际贸易无关的其他因素。@川普，过来听听经济学家怎么说全球收入差距扩大，不是因为全球化伤害了贫穷国家，而是因为它们没有参与全球化。经济全球化的趋势势必仍将持续，驱动因素有三个：通信技术与交通的发展使全球的经济联结更容易；国际协议降低了贸易的法律障碍；中国、印度、巴西等出口导向经济体的崛起。每个重大的经济变化都会带来挑战与破坏，全球化也不例外，但全球化的整体方向将提高全世界的生活水平。经济全球化的趋势势必仍将持续，驱动因素有三个：通信技术与交通的发展使全球的经济联结更容易；国际协议降低了贸易的法律障碍；中国、印度、巴西等出口导向经济体的崛起。每个重大的经济变化都会带来挑战与破坏，全球化也不例外，但全球化的整体方向将提高全世界的生活水平。全球化是大势所趋，整体上利远大于弊。这也是开放的力量，开放使得大家的眼光更广阔，同时发挥各自的优势，取长补短。章节：34汇率剧烈波动会对经济造成很大干扰当美元走强，可以买到的外币变多时，供给美元的人将从中获益，而需要美元的人将蒙受损失。当美元走弱，可以买到的外币变少时（或是当外币可以买到的美元变多时），供给美元的人将蒙受损失，而需要美元的人将从中获益。把商品出口到美国的外国企业，喜欢强势美元，因为它们赚的是美元，希望用美元换更多的本国货币。美元走强往往会伤害出口商，帮助进口商，并会减少贸易顺差，增加贸易逆差。强势货币往往会抑制出口、促进进口，并导致贸易逆差。国际货币基金组织（IMF）与国际复兴开发银行（又称世界银行）。起初，当人们考虑在其他国家投资时，他们思考的是：我预期该国的汇率将走强还是走弱？这个行为建立了一个自我实现（self-fulfilling）的期望循环。如果人们认为某个国家的货币将走强，他们就会投资于那个国家。当他们投资时，对该国货币的大量需求就会使它走强。政府若想管理汇率，通常会追求稳定或缓慢变动的汇率，以创造有利于贸易与长期投资的商业环境。经济学家有时会建议某个国家的货币贬值，以便使出口商变得更有竞争力，并且在出口导向的产业中创造更多的工作机会。如果一个国家运用货币政策来影响汇率，那它就不能同时用货币政策来对抗通胀或失业。于全球化的发展，美国经济与世界各国已更紧密地联系在一起，汇率议题对美国来说必将日益重要。章节：35美元大幅贬值对美国并没有显著的负面影响遭遇金融危机的国家都有某些共同点：GDP会大幅萎缩。由于某些非常宽松的放款惯例，这些国家的银行放款有很高的比例未按时偿还。如果公司还款给银行之前，泰铢贬值了50%，会发生什么事？4000万泰铢不再值100万美元，而只值50万美元，结果银行没有足够的钱来偿还借款。现在想象一下，若这状况在泰国各地发生，那我们基本上可以说泰国所有大银行都将同时破产。或许政府管制的最佳做法是少担心资金撤离，并且一开始就关注让什么样的钱进来，这种方式至少对20世纪80年代的智利是有效的。美国早已经历过美元大幅贬值的情况，其经济并没有受到显著的负面影响。章节：36未来的经济不再是零和游戏中国专注于制造业，有相当自由的市场经济，以及不同于西方式的民主政治体系。印度则聚焦于技术与服务业，在民主的政治体系中自我修正，变得更加以市场为导向。章节：宏观经济学原理总结宏观经济政策的四个目标是：经济增长、充分就业、物价稳定、国际收支平衡。讨论宏观经济政策的架构称作总供给与总需求模型。财政政策和货币政策是宏观经济政策的两组主要工具。前者是政府税收和支出的政策，包括政府预算和预算赤字；后者是指中央银行的政策，它会影响利率、借款与放款。出口大于进口，该国就有贸易顺差；进口大于出口，该国则有贸易逆差。顺差与逆差探讨的是金钱的流向，以及向哪边的流动比较大。凯恩斯法则（需求创造其自身的供给）注重短期几年内的经济周期，萨伊定律（供给创造其自身的需求）倾向于更注重长期。使社会的总需求增加或购买力提高的政策，称作扩张性或宽松的财政政策，包括减税与增加支出；反之则为收缩性或紧缩的财政政策，包括增税或减少支出。</li>
  <li>有哪些适合长期定投的基金?长期基金定投介绍，购买中证500与沪深300指数基金，每年均衡。投资被动型指数基金正在造成下一次金融泡沫？-GeekPlux了解指数投资的一些内在要点，结合之前的次贷危机。投资你是怎么变自律的？-高冷冷的回答-知乎每天第一个习惯很重要。让超我管理本我，将自己建设成为一个军队。自律如何改变讨好型人格？-风墟的回答-知乎拒绝是对自己的尊重你有什么道理后悔没有早点知道？-风墟的回答-知乎Lessismore90后李叫兽给我们3条启示轻松给自己一个答案，是最大的懒惰，不要糊弄自己，让所有的思考，决定尽可能的清晰深挖问题本质成长Slogonlessismorehttp://www.sohu.com/a/245629404_559589</li>
  <li>全文重点罗列Java是Sun公司开发的一门语言，同时Java也是一个开放平台。Sun公司为JVM发布了JVM规范，任何公司都可以按照此规范开发JVM语言，如现在的Kotlin、Scala等。JVM语言必须要通过JCP(JavaCommunityProcess)对其拥有的TCK(TechnologyCompatibilityKit)测试。Harmony是Apache2005年开发的一个开源的，免费的Java实现，只是没有完全通过Sun公司的TCK测试，按照Apache协议发布。OpenJDK是Sun公司在2009发布的完全自由，开放源码的Java平台标准版（JavaSE）免费开源实现，按照GPL协议发布。Android一开始使用的Java实现是基于Apache协议发布的Harmony，后来由于Harmony本身的限制以及Oracle公司的起诉，从AndroidN开始,Google开始用OpenJDK来替换Harmony。PS：其实知道这些就够了。。。如题，Sun公司的Java跟Android使用的Java库有什么关系？做Android开发不少时间了，但是相信有很多人有同样的疑问，尽管这个疑问对做Android开发本身并没有多大关系，但我还是想去了解个究竟，总觉得这里面一定有一些有意思的东西。最开始有这个疑问是源自Oracle与Google2011年左右诉讼，当时Oracle状告Google在未经授权就使用了Java的API，当时对知识产权、开源代码等缺少认识，只是觉得奇怪，Java是一门开放的技术，任何公司都可以拿来使用，为什么到Google这里怎么就变卦了呢，接下来就记录一下自己的研究笔记，以问答形式展开，问题间可能没什么关联。Sun公司与Oracle公司的关系SunMicrosystems是IT及互联网技术服务公司（已被Oracle(甲骨文)收购）SunMicrosystems创建于1982年。主要产品是工作站及服务器。1986年在美国成功上市。1992年Sun推出了市场上第一台多处理器台式机SPARCstation10system，并于1993年进入财富500强。2009年Sun公司被Oracle收购。什么是Java？wikiSun公司的詹姆斯·高斯林等人在1990年年初开发了Java语言的雏形（好吧，那年我刚出生，没想到自己跟Java同龄了），最初命名为Oak，主要适用于家用电器等小型系统的开发。后来随着互联网的快速发展，于是改造Oak，在1995年5月以Java的名称正式发布，所以更多时候，大家都在讲Java是1995-96才有的语言，也没问题。Java从最初设计就有一个非常优秀的思想，即跨平台，它不受平台限制，任何平台都可以运行Java程序，比如我们常见的Windows、Linux等等系统都可以运行，Java的跨平台具体是通过JVM做到的。JVM是什么东西？首先，Java语言不论在任何平台，想要运行，首先都需要先编译为字节码，这里的字节码是平台无关的，是完全独立的一个东西，不受平台特性限制。而最终在电脑上运行时，为了在各个平台上可以执行字节码，Sun公司在开发Java的过程中同时也开发了虚拟机这个东西，它专门用来执行字节码，它负责把字节码转换为机器可以认识的机器码，然后运行。于此同时，Sun不仅仅是为各个平台开发了虚拟机。作为程序员，我们大都有这样的经验，当我们要为多个平台开发一个作用一致的东西时，为了后续更好的扩展维护，我们肯定会想先定义一个接口规范出来，这样所有平台的实现都通过这个规范去控制约束，后续的升级维护就会变得更简单。作为开发Java的老一辈们当然也知道这个道理，所以他们也做了同样的事，Sun定义了Java虚拟机的规范。这样相当于发布了Java规范，即你只要按照这个规范，就可以开发自己的JVM语言了，前提是你的语言编译出的字节码要符合JVM规范，否则虚拟机就没法执行。现在这样的语言已经有不少了，比如我们知道的Kotlin，Groovy、Scala等。JVM语言是不是只要符合规范即可？原则上任何团体或者公司都可以开发JVM语言，因为这个规范是公开的，但是这里要知道的是，当你按照规范开发了语言，首先要做的一件事便是要通过Sun的TCK(TechnologyCompatibilityKit)测试。这个也很好理解，这是官方的测试，通过这个测试才能成为官方认可的JVM语言。具体TCK的详细介绍可查看Wiki。Sun公司如何通过Java赚钱Sun通过销售JavaEnterpriseSystem等专用产品的许可证从Java中获得收入。Apache开发的Harmony是一个什么项目该项目是Apache开发的一个开源的，免费的Java实现，不过2011年时已经被Apache关闭了该项目。Harmony项目实现了J2SE5.0的99％完整性和JavaSE6的97％。Harmony的目标：一个兼容的、独立的JavaSE5JDK的实现，并根据ApacheLicensev2发布。一个由社区开发的模块化的运行时（包括Java虚拟机和类库）体系结构。Harmony与TCK的纷争如果需要成为一个带有Javalogo标志的，可以声称自己兼容Sun公司实现的JDK，需要通过JCP（JavaCommunityProcess）对其拥有的TCK（TechnologyCompatibilityKit）的测试。ApacheHarmony项目一直在努力争取获得JCP的授权。但是，由于Sun公司的态度，JCP并没有给Harmony授予TCK许可，而且SUN发布OpenJDK之后，还规定只有衍生自OpenJDK的采用GPL协议的开源实现才能运行OpenJDK的TCK[2]，但Apache的Harmony是Apache协议的，与OpenJDK的GPLv2协议不兼容，Apache董事会和Harmony项目工作人员坚决反对这种带有条件的授权，认为这种是在开源社区里不可接受的。因此，两者谈判破裂。直到现在，Harmony一直没有获得TCK的授权。有批评称，Sun无视它签署的JCP法律协定，这摧毁了全部的信任。摘自ApacheHarmony-维基百科，自由的百科全书GPL协议与Apache的区别下面是常见开源协议之间的关系区别可以看到用GPL协议发布的项目，当别人修改代码后必须采用相同的协议并且也要开源。Apache协议则特别自由，当你修改该协议下发布的项目后，可以选择闭源，只需要在每一个文件头都加上版权说明。Harmony与Android的关系从上面的开源协议对比可以看出，Apache协议是一个特别自由的协议，而Android一开始正是因为Harmony项目采用了Apache协议，所以才更有动力使用Harmony作为自己的Java类库。所以Android中的Java实现并不是官方的实现，而是Harmony对Java的实现。由于Harmony并没有通过TCK认证，这也就为日后Oracle起诉谷歌侵权埋下了伏笔。到后来Android鉴于此，从Android7.0开始，用Sun的OpenJDK替换了Harmony。OpenJDK是什么OpenJDK（OpenJavaDevelopmentKit）原是Sun公司为Java平台构建的Java开发环境（JDK）的开源版本，完全自由，开放源码。Sun公司在2006年的JavaOne大会上称将对Java开放源代码，于2009年4月15日正式发布OpenJDK。甲骨文在2010年收购Sun之后接管了这个专案。OpenJDK是Java平台标准版（JavaSE）的免费开源实现，该实现是根据GNU通用公共许可证（GNUGPL）发布。OpenJDK最初只基于Java平台的JDK7版本。ApacheHarmony与OpenJDK、原生Java以及Android之间的区别对比。AndroidJavaApacheHarmonyOpenJDKAndroidRuntimeJavaRuntimeEnvironment(JRE)同左同左CoreLibrariesJavaCoreLibrariesHarmonyCoreLibrariesOpenJDKCoreLibrariesDalvikVMJavaVMDRLVMHotSpotVM由图可看到Java与Android有不同的运行时，但是OpenJDK跟Harmony都有相同的运行时，这就保证了这两者编写出的Java代码均能正常跑在Java平台上。而Android有自己的运行时。大家都定义了自己的VM，Android定义的最彻底。Java的VM基于堆栈结构，而Android的VM基于寄存器结构，后者效率更高，更适合移动端。总结一开始只是想了解Harmony，但是真的展开了，其实有很多东西需要去了解，包括语言本身、语言特性、开源协议，项目历史，一些关键事件等等。而花时间了解后，却发现不知道的东西更多了，疑问也更多了，比如Android具体选用Harmony是如何思考的，Harmony与OpenJDK的实现过程中有什么异同等等，也是无奈，这里只能把自己看到的想到的记录下来。无论如何，去了解一些东西背后的东西或者宏观背景，能给自己更多的视角去看待眼前的东西，也会让自己变得更理性，同时举一反三，任何事情都应该如此。参考链接ApacheHarmony-维基百科，自由的百科全书</li>
  <li>任何语言要运行都需要自己的运行时，Java程序的运行时叫JavaRuntime，Android程序的运行时叫AndroidRuntime，而具体Runtime是个什么东西呢，就是说一个程序要在一个硬件或者平台上跑，就必须要有一个中间层用来把程序语言转换为机器能听懂的机器语言。JavaRuntime的左右就是如此，如我们编写好了Java的HelloWorld程序，publicclassHelloWorld{publicstaticvoidmain(String[]args){System.out.println("helloworld");}}代码我们认识，作用就是输出一个“helloworld”，但是要在一个冷冰冰的机器上，让机器能读懂并运行这段代码，就需要一个Java语言的运行时环境，只有这个环境才能读懂它，并能让代码更机器进行打交道。到这里我们已经明白，如果一个电脑要能运行Java程序就必须安装有JavaRuntime。对于其他语言也是如此，要在平台上运行就必须要有对应平台上的Runtime组件，这也是开发一个新语言必须要做的事。说道Runtime，在Java发展的过程中，Java一下子火了有一个很重要原因，就是在90年代，微软的IE浏览器为了打败网景浏览器，曾经就在IE中默认安装Java运行时，再加上IE浏览器内置在Windows操作系统中，使得IE装机量特别大，同样这对Java也是一个非常大的促进作用。由于IE内置JavaRuntime，使得在IE浏览器中开发Java程序变得更加简单。如出名的JavaApplet（Java小程序）开发。后来因为Sun跟微软之间诉讼等事情，这个合作也没多久，现在IE已经默认禁用了JavaApplet。说道JavaRuntime（简称JRE），曾经在一开始开发Java程序时，经常把JRE跟JDK搞混。JRE是一个独立的东西，就是Java程序的运行环境，其中包含一个JAVA虚拟机（JVM）以及一些标准的函数类库。而JDK是Sun公司专门给开发人员准备的Java开发工具集。它其中就包含了JRE，所以配置好JDK，自然就可以在电脑上运行Java程序了。除此之外，JDK还包含了源码、API文档、编译工具等等。</li>
  <li>写作/阅读Markdown编辑器Typora文本编辑器VSCode日记软件-一本日记稍后阅读：InstapaperRss阅读器：Inoreader工具公众号Md文件转换wechat-formatTodo管理：柳叶-有条有理每一天自己使用VUE+Leancloud开发的网页TODO应用硬件手机一加6T耳机Beats入门连接世界蓝灯</li>
  <li>题图：PhotobyBanterSnapsonUnsplash工作日的每一天都围绕一些看到、想到的事去写一篇感悟、思考短文，然后周末整理出来发表。通过这种方式做一些较深入的思考和记录，同时与朋友更好的交流分享。回顾这周工作时间大部分都在做投票发布器，自己只负责Android客户端一侧的发布，但是整个链路很长，问题也就较多，加上参与人数多，变数就多，已经延期两版了。认识了新球友和新同桌。工作中的项目切换成本太高了，所以做完一件事显得更重要，否则再回去做开销太大了。这周每日习惯执行的不好，尤其是早起，当然最主要的原因还是不能早睡。去简书参加了日更的挑战记录，跟我的日计划正好契合，所以参与了。每天不追求写的多，而在于写的深入、有思考，通畅。基于wechat-format做了自定义，定制了自己公众号文章的样式，也就是现在这篇的样式，地址maoruibin/wechat-format:微信公众号排版编辑器，转换Markdown到微信特制的HTML本期目录03/25我要买个车吗？03/26音乐是个神奇的东西03/27听过很多大道理…03/28996.ICU这个项目为什么会火起来03/29聚餐03/25我要买个车吗？周末用媳妇的身份申请了天津的小客车摇号，从此我也加入了摇号大军。都知道北京号难摇，其实天津也不简单，我看了下二月份普通车是 80 万人在摇，中的概率是千分之五，如果是节能车貌似概率大点。没管那么多，我申请了普通车，先摇一次看看，不一定就中了呢。如果中了，我会买车吗？之前我一直不愿意买车。都知道投资中有一个道理，即 要购买资产，而不是负债。显然，对自己而言，车是典型的负债，购车需要花钱，而养车更需要花钱，不仅花钱，还花精力，停车位，事故等等都是要话费精力去处理的。所以买车是典型的负债。不过最近送孩子上学的途中，确实又觉得如果有车的话，接送孩子会方便不少。今年他上幼儿园时，我买了一辆电动车，用来接送他上学，这几周每天早晨都是我送他去学校，路上还有点冷，他坐在我背后，尽管给他穿的挺厚实，但是如果有车，确实就好多了，而且他还特别喜欢车。另外就是，车能提升生活的幸福感，在一些场合下，一个好的车也会让自己有面子，当然这都是虚的东西。最终的购买行为还是要结合自身的实际需要，个人暂时而言，车并不是刚需，还没有到非卖不可的时候，所以现在只会关注，不会购买。另外最近竟然被同事成功安利电动车，哎哎，以后买车我应该会买电动车了。你看这辆车如何？03/26音乐是个神奇的东西我喜欢听歌，也喜欢唱歌。对歌曲最开始的记忆是在三年级。那时候每周都有一节音乐课，跟其他课程不同，音乐课是三个年级一起上的，也就是一到三年级的同学在一个教室里进行上课，然后那时是统一在三年级的教室里上课，一二年级的同学都要搬凳子到三年级教室。所以可以想象的出，教室里会特别拥挤。上课的是柴老师，一般就是教我们一句一句的唱歌，那时候我们学会了《长江之歌》《少先队之歌》当然还有《国歌》等等。然后每学期末，音乐考试的方式也很特别，依旧是大家聚在一个教室里，然后按个唱歌，三个班加起来也得三十人左右，所以一般考试也就需要两周才能进行完。那时考试时唱的歌是自己选的，不论是不是音乐课上教的，都可以唱，然后唱完后，老师根据自己感受给打一个分就算老师结束。我记得有一次考试，我特意准备了下。那时刚是香港回顾没多久，那时有一首歌特别火，《七子之歌》，我在电视上听了好多遍便学会了，也很喜欢唱，所以终于要考试了，我准备把《七子之歌》作为考试的曲目。我记得当时轮到我唱歌时，我站起来，跟大家说了自己要唱的歌名后便开始唱，那时第一次感受到了舞台的感觉。那次我感觉唱的很好，我很投入。这也便是自己对唱歌最开始的记忆了，很美好。后来发现，除了教室里，山里、田野里唱歌更自在。可以大声的唱，也不用管是不是跑调，或者词是不是准确，后来到高中后，在一次音乐课上，我唱了一次后，竟然让大家觉得我唱的挺不错的，我挺意外。说到这，实际上在音乐天赋方面，我是明显不如我老爹他们父辈那一代的，具体就是在乐器方面不如老爹他们，唱歌方面不如姑妈们。在村里，老爹，四叔他们拉二胡，吹笛子等都算是高手了，简直就是村里的明间艺术家，二老爹他们的妹妹们，也就是我的姑妈们，他们很喜欢跳舞，歌唱的也特别好，声音好听，节奏感，音准都是业余中的佼佼者。实际上，小时候我很少听到他们唱歌，直到现在在一个 K 歌软件里听了姑妈们的声音，才发现他们都是那么棒。但是挺遗憾的是，那时他们的音乐天赋都无法兑现，不过音乐，舞蹈，乐器依旧给他们带来了很多快乐。突然发现有点偏题了，写着写着写到父辈们了，父辈的音乐故事有很多，要单独写一篇都不一定写完。关于音乐，真是一种特别好的调节生活的方式。不同的阶段听不同的歌，往往一段旋律就是一段回忆。03/27听过很多大道理…随着移动互联网的发展，大家获取信息的方式变得异常便捷，触手可及。比如微信公众号，订阅后信息就会源源不断的传送过来，比如头条，通过机器学习自动推荐个性化信息给用户，我们通过手机就可以可以学习到心理，体育，财经等各个领域的东西，而且更厉害的是，我们可以订阅专家、大牛的一手信息。这在以前是不可想象的。比如春秋时代，你想听孔子的学说，只能去找到他，做他的门徒，这不仅要跨越地理上的障碍，还要有相当的决心（不论如何，怎么都得说服爸妈吧）。试想，如果老人家活在当代，开个微博账号就可以了，每天发微博治学。相比哪个时代，如今信息流通异常简单，不可同日而语，内容也异常丰富。但是在这样的环境下，我认为最重要的已经不是如何获取信息的问题了，而是信息处理能力，也就是把信息转化为自己的东西，做信息的主人，而不是被信息的海洋淹没。03/28996.ICU这个项目为什么会火起来### 关于996.ICU一个国人在github上发起的一个项目，用来介绍国内的  996 工作机制，并让大家一起翻译成多国语言，项目网址 https://996.icu/#/zh_CN### 怎么叫火起来了github 是一个国外的网站，主要用来做项目协作，比如多个人一起在网上开发一个项目，github 就提供了很好的平台可以让大家身处不同的地方，却能有条不紊的通过这个网络平台开展项目。github 上面主要还是工程师居多，大家大都用来共享项目或者给其他项目贡献代码。相比其他社交平台，github 的传播性并不好，主要就是通过给项目点  star ，有点类似微信微博的点赞，然后在 github 站内传播，而用过的人都知道这个传播性并不高，所以一般个人的项目能有 1000 个star 已经不错了，如果有好几千过万 star 则已经是出名项目了，然后这个 996.ICU 却已经6万 star ，更重要的是他仅仅用了两三天的功夫，目前它在整个 github 项目里排名已经是第21的位置了。在一个传播属性不怎么强的平台上短时间聚集了如此多的关注量，这不叫火那什么叫火。如何火起来的这跟这个项目本身有直接的关系。#### 1、996加班机制积怨已久在国内加班是个很常见的事，见惯不惯，而且更重要的是大家对于这种不符合劳动法的雇佣法则都一致的容忍，大家不发声不代表内心不抵触，很多时候。处于雇佣关系弱势的一方，大多数人都选择忍气吞声，也有迫于生活压力。还有一些人用脚投票，跳槽离职。2、国内受限制的言论平台相比国内其他平台，github 本身的传播性不强，但是它是十分自由的平台，不会受到其他管制，对信息的质量而言，这是国内平台无法比拟的。03/29聚餐今天团队同事升职，大家一起庆祝吃饭，8个人一桌，却发现90后只有自己一个。事实上去年还有好几个，一年功夫，竟是如此模样。这也侧面反映了90后在职场更活跃，跳槽更频繁，而自己为什么是独有的一个呢，原因很简单，我是为数不多结婚生子的九零后，多么痛的领悟。</li>
  <li>so,DrawableBuilderiscomming…该Builder类主要提供语义化的API进行快捷的Shape创建操作。通过语义化的API创建shapedrawable。代码地址https://gist.github.com/maoruibin/4293314f0b7c277c2a635efa858a3e6e如下，几行代码就生成了一个线条背景drawable。Drawabledrawable=newDrawableBuilder().line().build();tvName.setBackground(drawable);效果：而之前，我们大都是像如下方式来构造线条shape。&lt;shapexmlns:android="http://schemas.android.com/apk/res/android"android:shape="rectangle"&gt;&lt;strokeandroid:width="1dp"android:color="#34495e"/&gt;&lt;/shape&gt;用xmldrawable设置背景tvName=(TextView)findViewById(R.id.tvName);tvName.setBackgroundResource(R.drawable.bk_line_drawable);样式可以看到，两种方式效果一致，但是使用体验却更好。在写好布局文件后，都需要去res目录下再创建drawable文件，然后再切换回Activity或者布局文件进行背景设置，这就免不了我们跳来跳去的切换目录，很麻烦。相比而言，语义化API就显得非常友好易用，如下所示：Drawabledrawable=newDrawableBuilder().line().build();tvName.setBackground(drawable);样式：跟xml样式一致，并且代码更少，更易于使用。以下是圆角等其他线条的展示。指定度数的圆角线条newDrawableBuilder().line().corner(4).build();样式：椭圆形圆角newDrawableBuilder().line().roundCorner().build();样式：充满颜色的圆角newDrawableBuilder().line().roundCorner().fill("#d35400").build();样式：虚线线条newDrawableBuilder().line().dash().build();样式其他API除了以上语义化API，还提供了相应自定义参数的API，如下所示：API说明lineWidth(intwidth)设置线条宽度，参数为具体数值，无需转换lineColor(intlineColor)设置线条颜色corner(floatcornerRadius)设置圆角度数dashWidth(floatdashWidth)设置虚线每个单元长度dashGap(floatdashGap)设置虚线边框每个单元之间的间距fill(@ColorIntintbkColor)设置填充颜色</li>
  <li>题图：拍于沙河水库，2019-03-23工作日的每一天都围绕一些看到、想到的事去写一篇感悟、思考短文，然后周末整理出来发表。通过这种方式做一些较深入的思考和记录，同时与朋友更好的交流分享。如何订阅博客语雀GithubWeekly公众号：咕咚同学本期目录03/17nothing03/18大道至简03/19优秀的认知系统03/20增重03/21篮球（开心最重要）03/17nothing忙碌的一天，坚持。03/18大道至简大方无隅，大器晚成，大音希声，大象无形，道隐无名。夫唯道，善贷且成。《道德经》-老子很多事看上去很难，但认真分析后，往往并没有想象的难。比如说健身这件事，很多人要准备健身时，先看附近有没有健身房，然后开始买设备等等，还没开始健身，却花了不少精力在健身之外。其实真的要健身了很简单，两步走。确定简单有效的健身方式日复一日的坚持比如要练胸肌，那么每天做200俯卧撑，要减肥，少吃东西，每天500俯卧登山跑等等。接下来，坚定的执行，两三个月后再看效果。以上的关键在于，操作方式足够简单，另外就是持之以恒。03/20优秀的认知系统有许多优秀的习惯值得养成，其中有一个格外重要—快速准确的建立对某个点的认知。这个点可以是技术，可以是一个概念等等，实际上，所有你不了解但你感兴趣的东西都可以是这种点。为什么这样说？首先，每个人的成长过程中，其实已经逐步建立好了这个系统，只是这个系统因人而异，也有优良之分，但是观察其他人，一定会发现别人有更好的学习认知系统。同时这个认知系统，从某种角度甚至决定了两个人的高度，也是人与人差距的一个具体体现。比如学习Android开发这门技术来说，同样的技术，大家的学习方式各有不同，有人通过写博客方式学习，有人通过github学习，有人通过官方网站学，也有人看书学习等等，方式不一样，最终的结果也不一样。有人只学了两三年就是业界大佬，有人五六年却一直无声无息，这背后就体现着每个人学习、认知习惯的差异。例子不一定准确，但意思差不多就是这样。所以我们要做的的就是，先理清自己已有的认知学习系统，然后观察更优秀的，接着学习，练习，最后不断替换、升级自己的认知学习系统。03/21增重从小妈妈跟姐姐都胖，老爹比较瘦，我在中间，妈妈老说自己喝水都胖，而老爹喜欢吃肉，但却一直也胖不起来，也许跟他爱喝酒有关。我小时候体重还算可以，甚至有一段时间还偏胖，那段时间别人还叫我“毛胖子”。现在想想，发现已经是很久远的事了，到后来高中大学，自己身高到183cm，但体重却一直维持在160左右。所以我的身体并不厚实，看胳膊和腿就很明显的感觉出来，尤其是胳膊，平时看不到全身也还好，今天在录像里看到了自己胳膊，真的有点太单薄了，所以有必要增肥。我的目标体重在180，日后多吃多锻炼，根据自己胃的承受能力，多摄入高热量食物，具体还得做功课。至于锻炼，俯卧撑继续，但是还要做一些其他类的运动，另外睡眠也很重要啊，不过现在已经开始早睡了…03/22篮球（开心最重要）一起打球时，我喜欢跟爱传球，有投篮的同学一起搭档。之前经常开玩笑，我说给我一个会传球有投篮的后卫，在野球场我们就是无敌的，尽管是玩笑，但是这几年打下来，很多时候都在验证这个事实，只要是搭配了这样的后卫，我们的胜率往往会很高。为什么呢？（接下家要开始自夸了，哈哈~）我擅长抓篮板，对篮板球意识很好，另外篮下技巧稳定，各种角度的近距离上篮很稳定。其实有这两个就够了，尤其是在野球场，大家水平差不多，只要一方有明显的篮板优势，就好打多了。因为这样就可以有更多的进攻回合，那么大家投篮水平差不多的情况下，肯定篮板多的一方更容易赢球。此时，如果再加持一个有不错投篮的外线，那赢球就是水到渠成的事。上述还有一个关键点，就是大家都乐于分享球，我爱抓篮板，但不代表我只爱抓板，我还喜欢传球，转移球，当然也喜欢投篮，喜欢得分的感觉，只是外线不稳定。进攻时，只要队友有更好的机会被我发现了，哪怕那人投篮不准，一般都会传，而不是拿球就单干。我的篮球理念是开心，甚至赢球与否都不是最重要的，赢球只是一个结果，开心却是一个过程。所以跟很多人不一样，我不怎么喜欢打正规的5V5比赛，这样的比赛总是充满着丑陋的身体接触，小动作，尤其是大家水平都是业余水平的情况下，比赛场上大部分是个人进攻，单打，而高质量的挡拆、配合都比较少，打比赛时大家都紧绷着，都想的是赢，这个过程很难让人感到愉快。当然对于实力悬殊的比赛，我觉得打的就挺好玩了，大家都轻松，或者轻松赢球，或者轻松输球，开心就好，哈哈~</li>
  <li>工作日的每一天都围绕一些看到、想到的事去写一篇感悟、思考短文，然后周末整理出来发表。通过这种方式做一些较深入的思考和记录，同时与朋友更好的交流分享。如何订阅GithubWeekly:https://github.com/maoruibin/Weekly个人博客：https://gudong.site/weekly语雀：https://www.yuque.com/gudong-osksb/weekly公众号：咕咚同学本期目录03/11换一个角度03/12老妈做吃的越来越好03/13让人烦恼的噪音03/14有钱也不买学区房03/15改变很难03/11换一个角度今天看到一个不错的微信公众号排版工具——WeChat-Format，花三小时写这个工具，只为一分钟拯救公众号排版。这个工具主要解决微信公众号Markdown排版的问题，解决的方式很优雅，只要把MD格式的文本粘贴到网页编辑器，然后格式化后，全选、复制到公众号编辑器粘贴即可，即可获得一个不错的MD样式排版。具体可查看上面的文章链接进行体验。关于这个工具，简单聊聊个人想法。首先，微信的公众号编辑功能确实很让人头疼，尤其是习惯Markdown编辑的人们，对比，大家对微信编辑器也是各种黑，这就是一个糟糕的编辑器。但是这个哥们却看到了展现自己能力的机会，所以说，当大家都在吐槽，或者不看好一个东西的时候，如果换一种眼光，也许就会发现不一样的东西或者机会。就像股市，大跌未必是坏事，只要自己仓位控制的好，大跌或者谷底时反而是低价买去优质股票的好机会。很多事也是如此，看上去没有希望，一团杂乱，但如果转换思维，学会去利用这些资源，反而可以获得意想不到的收获。03/12老妈的饭越来越好吃从小吃老妈的饭长大，一般吃面条拌菜较多，拌菜一般都是用西葫芦或者土豆条炒的。炒这种用来盖浇的菜时，总会在炒制过程中加入一碗多的水，这样是为了让炒出菜有更多的汤汁，然后好拌面吃。另外就是面条汤饭，就是先用菜炒出底锅，炒出味道后加入凉水烧开，然后下短面条，这样一锅面条饭便好了。除了这两大类外，平时也吃米饭，我挺爱吃，但是貌似米饭吃了饿的快，不像面条，所以一个月也就才吃一次，除此之外还有一些小众不怎么经常吃的花样，比如稠饭，菜汤、窝窝饭（比较麻烦）、垫卷子、扁豆饭等等。更多内容请查看老妈的饭越来越好吃03/13让人烦恼的噪音在公司通勤的大巴上，旁边座位有一男一女一直在聊天，我可以很清楚的听到，周围的人也应该能听到。像这种比较安静公共场合，如大巴车，我总是很反感别人在旁边聊个没完没了。因为空间密闭，他们说的话自己完全都能听到，想不听到也难，我对他们的聊天内容也不感兴趣，甚至很反感。实际上对其他人来说，这就是噪音，我认为这样的行为已经可以划到不文明行为之列了。对于我自己，我一向很注意在这种场合说话的分贝。在我看来，这种打扰到其他人的聊天，是不文明的，所以一般车里要接到电话我也会悄声说或者尽快说完，避免长聊，如果跟同事在一起，对方如果比较能聊，我一般也都是附和一下，从不投机的聊。而他们，不管不顾别人的感受，对此，我一直很难想象他们怎么理解自己的行为的。如果他们觉得这样说话对别人没影响，那他们是无知的，如果他们觉得自己想聊就聊，想说就说，不用管别人，那他们是自私的，不文明的。我遇到过很多次这样的事，事实上我很少去制止，大多时候主要是觉得他影响我也就一会的功夫，没有必要去为了这个去找事，犯不着，所以也就忍了。对此，我觉得一个好的方法就是随身带个耳机，遇到这种情况了戴个耳机，今天旁边一个妹子就是这样做的，嗯嗯，突然有点明白这两年为什么降噪耳机越来越火了…03/14有钱也不买学区房自己一个朋友要在北京买学区房了，单价8万多，总价700多万，嗯嗯，天文数字。从自己的角度，自己是完全不会去考虑学区房的，对，因为没钱。那假如自己有呢，我在想，目前的想法是，即使有，我也不会为了孩子的教育花费如此巨额的代费用。但事实上，这样的的想法依旧是建立在自己没钱的基础上。人做决定的时候，是一定要考虑自身当时的情况的，这个情况包括方方面面。事实上，人在决定追求什么的时候，都会基于当前的条件，再往上一点点，然后定目标，所以有时候你理解不了别人，只是因为你们所在的高度不一致，看到的东西不一样，所以理解就不一样，最终反映在具体所做的事情上。03/15改变很难中午去打球了，从高中打球开始，自己一直习惯打篮下还有空切。18年时，我想尝试投篮，走外线，然后自己花了一个夏天练习投篮，投篮很有成效，空位命中率也比较稳定，但是实战却很难去找到投篮的机会。最近每次打球都告诉自己要多投篮，不打篮下，但是打了这么多年的篮球，篮球场的打法已经养成很久了，改变很难。大多时候还是在低位要球，然后勾手或者策应。我想要改变还是应该先尝试待在外线，不要往里去，多在外线策应挡拆，少花心思去挣篮板，当然，我是很擅长抢篮板的。总归需要离开自己之前球场的舒适区，这种感觉其实挺难受的，适应还需要时间。改变很难，但为了更长远更不一样的体验一切都值得。</li>
  <li>从小吃老妈的饭长大，一般吃面条拌菜较多，拌菜一般都是用西葫芦或者土豆条炒的。炒这种用来盖浇的菜时，总会在炒制过程中加入一碗多的水，这样是为了让炒出菜有更多的汤汁，然后好拌面吃。另外就是面条汤饭，就是先用菜炒出底锅，炒出味道后加入凉水烧开，然后下短面条，这样一锅面条饭便好了。除了这两大类外，平时也吃米饭，我挺爱吃，但是貌似米饭吃了饿的快，不像面条，所以一个月也就才吃一次，除此之外还有一些小众不怎么经常吃的花样，比如稠饭，菜汤、窝窝饭（比较麻烦）、垫卷子、扁豆饭等等。相比经常吃的干饭或者汤面，其实那些不常吃的品类我更爱吃，只是它们做起来比较麻烦。比如垫卷子需要杀鸡（小时候一般不怎么舍得吃的，一般有亲戚客人来时才吃），扁豆饭需要有晒干的扁豆，还需要提前摘沙子（扁豆原材料里可是有不少沙子杂质，如果不摘掉，吃饭时很容易被沙子嘎嘣到牙）等等。所以小时候吃的相对还是比较单调的，老妈大多时候做汤面或者干伴。记得夏天时，老爹在家里菜园子里种西葫芦，种的特别好，家里总有吃不完的西葫芦，老妈为了尽快吃掉那些葫芦，几乎顿顿吃西葫芦菜，那时真是吃到吃不下去，一度吃到吃不下去，姐姐更是如此。相比夏天时的西葫芦伴菜，我还是更爱吃老妈冬天做的土豆条伴菜。一般每到秋季，家里都会提前买好冬天吃的菜蔬，其中土豆便是大头，每年应该都会在地窖里囤好几袋子的土豆，以便过冬吃。当然土豆不仅可以炒菜，冬天可以烤着吃，炕着吃还可以煮着吃，吃法很多，不过家里最常的吃法还是炒菜。也许是自己爱吃土豆，老妈做的土豆炒菜吃了那么久，却从吃不腻，不像西葫芦，即使到后来工作也是如此，土豆条炒菜也依旧是经常吃的菜。后来在北京工作后，自己才开始学炒菜，自己一开始做的菜便是炒土豆条。后来会炒菜后，味道跟老妈做的味道竟然很相似。过年回家跟老妈说起这个事，老妈一脸欣慰的笑容。不论如何，那时的味道似乎是固定的，味道很淡很一般，但记忆却很深刻，那个味道就像是停在了哪里，一动不动，也许只有到了老家才能找到。到了今年，接老妈到了北京。老妈已经给自己做了好几个月的饭，发现老妈做的菜越来越好吃。这期间，老妈做了各种各样的饼，我以前从没吃过老妈做的饼，主要也是老家没有吃冰的习惯，今年双十一买了电饼铛后，老妈便开始展示自己做饼方面的潜力，我跟媳妇大饱口福。不仅仅是饼子，老妈做的菜也竟然越来越好吃了…</li>
  <li>题图：拍于沙河，2019-03-02工作日的每一天都围绕一些看到、想到的事去写一篇感悟、思考短文，然后周末整理出来发表。通过这种方式做一些较深入的思考和记录，同时与朋友更好的交流分享。如何订阅GithubWeekly:https://github.com/maoruibin/Weekly个人博客：https://gudong.site/weekly语雀：https://www.yuque.com/gudong-osksb/weekly公众号：咕咚同学本期目录03/04孩子上幼儿园了03/05控制世界的感觉03/06今天星期三03/07设计模式03/08投资03/04孩子上幼儿园了今天早晨带孩子去幼儿园上学。这是他幼儿园的第一天，早晨跟媳妇一起把他送到教室里，要回去时内心还是很忐忑的，毕竟他出生后的这三年里一直都是我们或者他爷爷奶奶们在陪伴，第一次把他交给这样一个陌生的环境，还是有点担心的。尽管在这之前我们在家里已经跟他做了很多思想准备。我跟他说，到学校里老师就是你的朋友，有什么事都要找老师，还告诉他要跟小朋友们一起做朋友，可以跟他们一起滑滑梯等等。到今天离开时，他正趴在桌子上吃饭，好像也不是排斥新环境，我们要离开时，他也没有表现处不舍，当然，还是有一些孩子在哭闹。看来之前的思想准备工作做的还可以。孩子上幼儿园我觉得最主要的就是让他体验集体生活。之前一直都是在家庭中生活，他对自己的定位也是基于家庭，他是一个宝宝，整天大家都围着他转。现在他需要更大的环境，去新的环境探索，寻找新的定位。他会接触到更多的孩子，有男孩女孩，还有老师，他会接触到新的环境，新的卫生间，他需要接受新的饮食，新的吃饭时间，新的睡觉时间等等，都是新的。他接触到了一个更大的世界，这些都会潜移默化的影响他的内心，影响他对这个世界的认识。我不知道上幼儿园具体会对他有哪些影响，但是一些行为习惯一定会有变化。毕竟在家里，他的参考物只有我们，而在学校里，有很多小伙伴，还有最重要的老师，而且老师更加明白如何去引导和教育孩子，加上这种群体生活，而且都是小朋友群体，这会使得他更加容易从同龄中去寻找认同感，他们还会交流学习，总之很期待他在幼儿园中的生活学习，自己给他带来的影响。03/05控制世界的感觉当发现自己可以控制自己时，如自己的作息时间，自己的习惯等等，突然觉得自己像是控制了这个世界，或者说有了一种可以控制世界的感觉。也许就是这样，当可以做到自控时，才是控制世界的开始。自己做的还不够，还有很多地方需要注意和控制，但还是给自己加油。另外今天褚时健去世了，91岁，简单看了老爷爷一生的履历，钦佩。我想我老了会是什么样子，到那时，看世界又会是怎样一种眼光。03/06今天星期三今天是星期三，儿子上幼儿园也已经是第三天了，前两天送下他时，他傻傻的，也没意识到什么，没有哭闹，今天就不一样了。早晨带他走到学校里，他先是去滑梯哪里看了看，因为太冷，也就没有上去玩，然后我准备直接带他去教室，还没有走进楼里，他就一副委屈的脸庞，看着我，快要哭了，我说我陪你去教室，爸爸不走。到教室里，老师把他的书包，衣服都收拾好，还没怎么的，他就开始哭，很伤心，嘴里一直说着，让我不要走，老师要抱他，他也不让，我看着很心疼，所以就继续陪他陪了一会。终于还是找到了机会，溜了出来，我出教室的瞬间，他还是撇到了我，更加伤心的哭了起来，但我还是出了教室，后来在教室外面继续观察了一会才离开。很显然，他习惯了家里的感觉，一下子很难接受学校环境，我也一度在想，这是不是对他太残酷了，是不是应该让他准备的更充分一些再上呢？但是转念又觉得，这些都是要一点点去经历的，只要他没有特别大的排斥行为，还是应该让他在幼儿园里，让他去习惯适应。家里就像一个温室，他的成长一定不是在温室中进行的。人生漫长，这只是个开始，还有很多类似这样的不适会伴随他，作为爸爸，他的朋友，更多时候应该帮他把握大方向，去鼓励他，去引导他，让他走在正确的路上。至于成长中的阵痛，是必然要面对的，每个孩子都是如此，大人应该理解并相信孩子能战胜那些困难…03/07设计模式对于任何大点、复杂点的模块，我们做的所有设计、重构，几乎都是围绕一个原则在展开——分而治之，因为这样可以更好的管理、组织代码。一般我们会根据系统不同的纬度去拆分，如功能纬度，UI纬度等等。拆分的过程需要保证原子性，每一个小模块都是非常纯粹的，不能掺杂其他不相关的东西。这一点也是拆分过程最难的地方，一旦不能坚持，便会设计的不伦不类。拆分的过程应该按照设计模式六大原则，这对拆分非常有用，自己受益匪浅。拆分完毕便是组合的过程。组合就需要一个中心化的地方统一管理调度模块。中心化有很多好处，所有最重要的逻辑都在一个地方，它就像一个控制中心，我们可以把所有的管理工作都放在这里，这对后续维护人员来讲变会非常友好，因为从这里出发，大部分的逻辑就可以顺藤摸瓜，一目了然。03/08投资自己应该是从18年初开始关注投资相关的东西，最开始是关注一个微博博主，后来受他印象很大，跟他也学习了不少东西，包括一些投资，还有人性等等，杂七杂八。之前很少会去对一个人保持这么多的关注，那段时间持续了很久，总之只要看他写的文字，总能看到不一样的东西，他也反复强调独立思考的重要性，等等…那时币市疯狂，在错误的时间，自己买了总额1000的eos也开始了自己的韭菜之旅，到后来又转战基金，一直到现在，自己在投资方面算是跌跌撞撞，陆续也交了不少学费，现在想来，自己算是典型保守型的投资。这也是受那个人的影响，他一直说，用闲钱投资。现在看来，我认为投资是一个需要长期关注、学习的事情，一定不是一蹴而就，现在学习渠道很丰富，很多大v小v都会在个个平台去讲解分享自己的东西，我们可以多看多听，但是也应该多思考，还有，自己做决定，不要盲从，因为大v也会错，只有自己思考过的经历过得才是自己的东西。</li>
  <li>个人博客的第一张背景图工作日的每一天都围绕一些看到、想到的事去写一篇感悟、思考短文，然后周末整理出来发表。通过这种方式做一些较深入的思考和记录，同时与朋友更好的交流分享。如何订阅GithubWeekly:https://github.com/maoruibin/Weekly个人博客：https://gudong.site/weekly语雀：https://www.yuque.com/gudong-osksb/weekly公众号：咕咚同学本期目录02/25核心习惯很重要02/26提升自己价值02/27大本大源处探讨02/28你这个人就是你自己的三观体现03/01最让人恐惧就是恐惧本身02/25核心习惯很重要核心习惯是上周在知乎一篇文章中看到的，具体概念是《习惯的力量》一书中提出的。一些习惯比起其他习惯在重塑商业和生活方式上更有影响力。这样的习惯就称为核心习惯。所以要做到自律，能坚持自己的核心习惯就是一个关键点。每天只要能坚持自己的核心习惯，其他的习惯也便可以更轻松的完成。核心习惯就像多米诺骨牌中的第一个牌，只要推到它，后面所有的牌便可以很容易的就被推到。目前，我把自己的核心习惯也定为了早起，早晨六点起床，然后去学习、做笔记，写东西。坚持了一周后，发现每天列出的其他事项也变得很容易就可以完成。仔细想想，为什么这个核心习惯如此奇妙？原因可能有以下几点。1、相比较其他习惯，早起对自己来说最有难度，所以每天只要完成最有难度的习惯，完成其他习惯时，从心理上已经没什么压力了，甚至，完成核心习惯后，自己对完成其他事项也变得更加有信心。2、这个习惯是一天开始时第一个习惯，所以只要完成它，自己便可以较早的进入自己的习惯系统，也可以说是自律系统。3、在完成了第一个习惯后，“超我”可以更早的进入管理状态，使得“本我”更好的被管理。这是我对自己核心习惯的理解。但是也有不足的地方。周末没有坚持下来，主要是周末杂事较多，白天奔波，没有休息好，晚上也没有按时10:30睡觉，所以早晨起床变得困难，这是需要改进的地方。具体方案的话，周末白天应该安排休息时间，另外提前规划周末事务，让事情可以预期和计划。02/26提升自己价值与其花时间教育这些人，不如花时间提升自己，让自己变得更优秀，这样就有更高的可能性去接触更聪明更成功更高层次的人。因为，一方面，你改变不了他们，另外，改变他们对你自己也没什么意义，改变自己，提升自己，让自己成长才有意义。时间是宝贵的，那些人根本不值得花时间，应该花时间去结交更有素质更聪明的人，做更有价值的事。摘自左耳朵耗子《谈谈我的三观》提升自我价值是一件任何时候都不会晚的事，越早去发现越好。不要或者尽量去避免去做一些对自己无价值的事情。如果按照这条原则，我们平时就可以放弃很多没意义的事情。02/27大本大源处探讨#知乎文章感悟#人在年轻的时候，最核心的能力是什么？-病毒营销陈轩的回答-知乎只将全幅功夫，向大本大源处探讨，探讨既得，自然足以解释一切，而枝叶扶疏，不宜妄论短长，占去日力。出自毛泽东知道自己要做什么后，面对如何做的困境时，上述话指出了一个方针，既“只将全幅功夫，向大本大源处探讨”。也就是日常听到的死磕，追根刨底，把自己的问题彻底吃透，研究明白，这样自己才可以对自己手中的事游刃有余。生活中事也是如此，想要做的好就一定要有死磕精神。02/28你这个人就是你自己的三观体现前天看左耳朵耗子的文章，《谈谈我的三观》，对于三观他这样说:三观是世界观、人生观和价值观，世界观代表你是怎么看这个世界的。是左还是右，是激进还是保守，是理想还是现实，是乐观还是悲观……人生观代表你要想成为什么样的人。是成为有钱人，还是成为人生的体验者，是成为老师，还是成为行业专家，是成为有思想的人，还是成为有创造力的人……价值观则是你觉得什么对你来说更重要。是名是利，是过程还是结果，是付出还是索取，是国家还是自己，是家庭还是职业……说到这里，其实一个人的一天怎么度过，就几乎是自己三观的体现，包括这一天里他说的话，做的事等等。三观这个东西很难被比较，也很难说好坏，但是一个人每天做事、说话的效果、影响力却可以看得出高低。我越来越觉得，一个好的三观可以大大减轻自己的生活负担，越早的形成对自己正确的三观对一个人影响力越大。因为三观在深刻的指导着一个人，指导他如何思考，如何做事。而关于如何去形成一个正确的三观，对于目前的自己，还是应该多看书，多思考，多去观察思考别人，然后在生活中不断实践。03/01最让人恐惧就是恐惧本身这两周都在做Androd微博详情页重构拆分，主要解决之前评论流跟微博详情强耦合的问题。随着这两年微博评论功能越来越多，详情页的代码已经越来越多，耦合也越来越重，拆分时已经达到了四千多行代码。另外，后来微博视频也要接入评论流，当时因为工期，以及代码耦合太重等问题，视频组直接复制了详情页的代码进行自定义改造，所以评论流在微博里其实有两套，而且互相没关系，如果详情页开发优化评论相关的代码，视频必须要同步，或者放任不管，导致两边逻辑不一致。总之问题很多，从维护的角度，确实需要进行一次重新设计。所以面年前组长就提出来让我们进行拆分，但是谁都知道，这不好搞。详情页的逻辑非常复杂，一开始，光想想就觉得头皮发麻，这是真的。所以后来也一直在delay,年后组长特意批时间搞，所以我这便硬着头皮搞了。虽然感觉很难，但是这个事情有意义，不论对自己业务组还是其他业务组，都是一个值得投入的事，同时也是自己彻底学习详情页逻辑的机会。接下来便开干，到今天已经基本结束。主要就是理清评论流很微博详情的逻辑，然后按照MVP模式，抽取ViewPresenter，设计父子类关系，最主要的就是抽取子类，需要不少时间，耐心。结束后，再回顾这个过程，跟之前开始前完全不一样，远没有之前想的那么复杂，尤其是当自己迈出第一步后，后来拆分的过程异常顺利，几乎没有遇到什么大问题，其中有一个loading的小问题，竟然花了自己半天的时间。但是整个过程很顺利。通过这个事更加说明，最让人恐惧的就是恐惧本身。我们遇到的很多问题，有时并没有那么难，更多时候我们是被事情的表象所欺骗，而事务呈现出的表象其实并不是真实的。毛泽东说“一切反动派都是纸老虎”，面对困难，就应该有这种精神，不要事先给自己我不行的暗示，相反积极面对问题，找出关键点，最重要的是先迈出第一步，即使不行，也要先去行动。摸着石头过河怎么也比原地不动，纸上谈兵更实际。</li>
  <li>按时间顺序，记录入职微博后，自己负责开发过的大功能。主要记录核心内容以及开发过程中的问题，思考。发布器进度2019/08-10发布图片、视频支持进度展示发布器支持最多18张图2019/08-10触摸事件搞的要死要活的。自动存草稿（2019/5）切到后台自动存储用户输入，大退后者杀死进行提示。是一个用户体验相关的功能。投票发布器（2019/3）微博发布器增加投票功能，开发时就是开发一个发布器附件，这里面包括投票View，数据，以及复杂的发布器互斥。输出提供语义化API用来创建ShapeDrawableEditTextView限制输入字符数，并倒计还能输入多少字符，兼容中英文字符微博详情页重构(2019/1-3)抽取转评赞模块。分为两期拆分，到微博后最大的一次代码改动。主要就分而治之，对正文页进行模块拆分，各自负责自己独立的业务，降低代码的耦合性，提升可维护性。主页Tab重构对微博tab底栏进行改造。以前的tab大都是硬编码，不能支持灵活配置，重构主要解决配置的问题，重构后可以根据不同策略展示不同的底栏。发布器UI改造模仿Facebook发布器，替换原来的九宫格菜单，重新设计为底部滑动菜单。编辑微博微博可再次编辑。主页小房子Lottie动画使用Lottie，在首页有新微博时，显示一个刷新动画，以及点击时刷新消失的动画。</li>
  <li>地址：《股票学习：从0开始学股票投资》作者：羊陪家by百度脑图股票投资可使财富增值年化收益率20%已经是很不错的成绩。公认股神巴菲特的年化收益，从1957年到现在，他的年化收益也就20%+沪深300指数（同上，可代表中国股市）从2004年以来，上涨约4.2倍，年化收益约12.27%，甚至比美国还要高！美国标准普尔500指数（不懂没关系，知道它能代表美国股市即可）从1957年到现在，年化大概可以9%，接近10%。也就是说，如果你对它进行长期投资，平均下来每年大概有10%左右的收益，远离动不动就宣传10%20%左右的理财产品，这就是骗人的。非理性炒股能够消灭财富长期来看，投机的都不会有太好的下场。什么会导致非理性炒股无知一进场就买买买没有耐心不会止损在股票跌了50%之后，你干脆视而不见，好像不卖出就一定会涨回来一样，然后看着自己的账户从10万变成了1万…贪婪看到别人赚了不少，自己就觉得自己也可以。然后拿钱扎进股市，在牛市中，一开始可以赚到不少，但是相比一些专业的投资者，入场的散户投资者缺乏严重的股票、投资常识，不知道止盈止损，所以这是根本差异，当你买的时候，真真有投资经验的人已经开始分批出仓了，所以我们做了一颗光荣的韭菜。股票市场是经济金融的重要组成股市是经济的晴雨表，股市与经济的发展有着千丝万缕的联系，股市是我们理解经济运行、金融市场不可缺少的必修课。了解股票市场，会完善自己在经济金融方面的知识框架，会让自己能够理解更多市场行为背后的因素。关注股票呢，也会倒逼着你去了解公司的运作、经济的运行。股权融资是企业发展不可或缺的重要手段作为企业家应该知道，股权融资是捞钱的大好机会，是最好的变现好机会。完善知识框架，丰富金融知识对于我们接触到的东西，不论生活中的工作中的，很多东西都要知其然还要知其所以然，否则半吊子就很容易被收割，有时收割你的不是别人，而是自己的无知。任何知识，不应该学皮毛，要学习就应该从头至尾逐步建立知识的框架体系，这样才可以更好的吸收掌握应用。股票的本质股票本质是什么？股份就是你对某家公司拥有的所有权。股票是一个凭证，证明你拥有某一家公司的股份，即股票是股份的凭证。股权：你因为拥有某家公司的所有权，而具备的权利（比如你可以参与决策投票，分红等等）。企业为什么要发行股票？股票市场的存在，就是为了撮合想发展但缺钱的企业与有钱但想投资的投资者。所以企业发行股票，就是为了融资。融资一般有两种方式，借钱的融资叫债务融资，由别人入股的融资叫股权融资。股票市场要确保企业是真实有效，值得投资的企业。否则的话，所有人都可以随便搞个公司来发行股票骗人，那这个市场也就失去意义了发行股票的条件1、持续经营三年以上（否则我怎么知道你是不是就搞个公司来骗钱）2、主营业务最近三年没有发生变化（主营业务一直在变说明经营者肯定没想好要干嘛，那怎么可能是个值得投资的公司呢）3、最近三年累计净利润超过3000万（值得投资的企业，至少是要能赚到钱的把）个人理解为什么要发行股票变现放大股东的收益上市前的收益只有每年的分红，按照股权比例进行分红。上市后，公司之前积累的形象、公司的企业文化等等虚拟的东西都有可能转化为PE这个东西，进而提高股价。个人为什么要投资股票？分红中获益买了股票后，就有相对份额的股权，那么年末分红时就有相对比例的分红收益。股票溢价在股票市场，股票的价格一直在上下浮动，当大家普遍看好时，大都会上涨，这样就会产生股票的溢价。一开始每股1元，但是后续很可能涨到2元3元，这种溢价比还是很高的。一级市场vs二级市场企业首次发行股票并卖给最初的投资者时形成的市场，就称为一级市场。而后面我们说，你拿到手的股票，是可以转手给其他投资者的对不对，那投资者与投资者转让股票的市场，就称为二级市场。用互联网的话说，一级市场是BtoC，二级市场CtoC。股票初始价格是如何确定的首发价格确定第一种是直接定价，即由上市公司和投行直接商量后确定。第二种是网下询价，即由上市公司和投行商量出一个价格区间后，向各大机构投资者（各公募基金、保险资管、社保等等）进行询价后最终敲定。中国有个特殊的现象，即所有首发股票的最高价格基本都遵循一个公式——发行价格=EPS（每股收益）*23EPSEPS（EarningsPerShare），即每股收益，又称每股盈利。顾名思义哈，所谓每股收益就是每一个股份所获得的收益情况，即用税后利润除以股本总数得出。PE也就是上面的23，它是一个倍数，可以把它理解为人们对某个公司未来发展的期望值。也被称为市盈率。市盈率是最常用来评估股价水平是否合理的指标之一。为什么是23？中国特色，保护投资者、股民。股票收益股票收益的主要来自两个方面：1、分红收益，2、股票溢价收益。一年有20%的分红收益已是很高的了，而股价一年之间的波动很可能就有正负50%-100%。所以，对全球股市而言，投资收益都主要来源于股票溢价。股价股价=每股收益*市盈率P=EPS*PE影响股价波动的因素是什么？股价=每股盈利*市盈率所以影响股价的因素可以简单粗暴的归纳为每股盈利和市盈率两个指标中。每股盈利每股盈利牵扯到公司的经营模式、盈利能力、管理能力等等，事实上反映的就是一个公司的基本面。市盈率市盈率的本质是估值，是人们愿意为购买这个公司所付出的乘数，已经涵盖了多种影响因素，个人认为可以归纳为三个，分别是预期因素，心理因素和技术因素。基本面经济学上说，价格由价值决定，而每股盈利所代表的基本面价值，就是决定和影响股票价格最重要的因素。当一个企业的经营状况改善，盈利能力提升，基本面状况趋好，就会推动其股价的上涨。反之，则股价下降。估值估值并不是一个单独的因素，它是由各种各样因素相互作用之后的一个结果。粗略可归纳为三个，分别是预期因素、心理因素和技术因素。###预期因素当人们对某个行业或企业有更高的预期时，就会给予更高的估值，就愿意接受更高的市盈率。因此，尽管基本面价值不变，估值的上升自然会推动股价上涨。比如某个企业发布了一个划时代的产品，或者国家发布了对该公司利好的政策等等，都会导致对该公司预期的提升。与之相反，如果公司出了一些丑闻，则会导致预期下降，比如疫苗公司造假。心理因素可以理解为人性对市场的印象，当股票开始大涨，很多人便会忍不住去拿钱扎进股市，明知股价已经是天价了，还继续买。这就是人性的贪婪。于此匹配，股市中也有人性的恐惧，当股票价格下降，人就会担心一降再降，从而及时股票价格已经到了公司的正常水平，甚至以下，但是人还是不敢买。股市中有一个均值回归的理论，我们应该那这个理论去指导自己的投资行为。技术因素主要是指某些特殊的交易方式或规则。就是一些技术或者规则限制，有时会导致市场出现波动。比如，基金公司发行新基金时，当募集完资金后，比方说100亿，那根据合同，基金经理必须在规定时间内买进股票。这个时候，假设股票的价格已经很高，基金经理再不情愿买，他都得含泪进场接盘的哈。如何看待股票价格比较某个商品贵不贵的时候，我们要考虑的是其价值与价格的关系。价值：由商品实实在在的作用所决定。价格：会偏离价值，影响价格的因素多种多样，市场变化，政策原因等等。如何评估股票是便宜还是贵的方法，就是运用市盈率。简单粗暴来讲，市盈率越高，咱们就说这个股票价格太高了，反之。于此同时，通过市盈率我们也知道了，一个企业的价格偏离了价值到底有多少。比如目前小米的股价为10.84，市盈率为16.68，出于一个较低的位置，现在每股收益0.64。衡量股票是贵或者便宜，并不能通过比较股价来判断，而是应该通过另外一些估值指标来判断，而市盈率就是估值指标中比较重要的一个，另外还有像市净率（PB）等。市盈率如何比较横向比较。即比较行业，看下这个公司的市盈率相对于行业的平均市盈率是高时低。纵向比较。查下下这个公司过往的市盈率，看下目前的市盈率是处在什么样的一个位置。投资流派介绍股票投资，基本上分为两大流派，一种是技术分析，一种是基本面分析，除此之外还有一种很主流但不成体系的流派，且称之为事件驱动型投资。技术分析，专门研究价格的变动规律和趋势，根据统计和图形进行判断和操作。基本面分析，主要研究企业的经营状况和内在价值，包括经营模式、盈利情况、财务状况、发展前景等等。至于事件驱动型投资，我的理解是根据国家政策、突发事件等因素，来判断利好利空，从而进行短期的投机操作。这种流派套路比较野，主要是在不成熟的资本市场受热捧。技术分析搞技术分析的人，研究的就是股票K线图上的各种图形和指标。基本面分析基本面主要关注的是价格的背后，即企业的经营情况和未来发展潜力。根据侧重点不同，基本面分析又大致可以分为价值投资价值投资比较关注的是公司当前的价值，所以会重点关注企业的营收情况，净利率和毛利率变化，ROE（净资产回报率）等等，以及很重要的估值水平。成长投资成长投资更关注的是企业未来的增长潜力，所以成长投资会更多地关注企业的行业市场规模，净利润增长率等等，而对于估值水平的忍受能力相对较高（能够接受比较高的估值水平）。价值投资的关键在于评估企业内在价值，成长投资的关键在于挖掘企业未来的发展潜力。价值投资推荐书籍，邱国鹭老师的《投资中最简单的事》。事件驱动投资也叫概念炒作。概念的炒作就是常常就是击鼓传花，博傻游戏。这种游戏别玩。当你知道这个游戏的时候，说明别人已经要寻找接盘侠，或者等着韭菜入场了。投资总结投资木有那么简单，所有把投资方法总结成口诀的，声称背背口诀就能战胜市场的，要么是骗子要么是傻子。即使真正的投资大师浓缩成的非常简洁的思维精华，实践起来也是需要付出巨大的努力的。投资是一项长跑，我们要关注的是长期的业绩，或者叫长期的胜率。无论何种方式，短时间内赚了50%、80%甚至翻1倍、2倍都不重要，最重要的是这个方式方法是否具备可持续性，是否可以复制。如果不可持续，无法复制的话，其实跟靠运气的赌博没有太大差别。所以，我们在市场里追逐的不应该仅仅是账面上的收益，更重要的是要通过实践去寻找自己的投资方式，而不是一味的去投机，投机可以赚到小钱，但也容易栽大跟头，投机都不可取。相反我们可以花时间，花金钱去不停学习，而不是一味追逐一时的收益。</li>
  <li>工作日的每一天都围绕一些看到、想到的事去写一篇感悟、思考短文，然后周末整理出来发表。通过这种方式强制自己做一些比较深入的思考和记录，同时与朋友更好的交流分享。如何订阅GithubWeekly:https://github.com/maoruibin/Weekly个人博客：https://gudong.site/weekly语雀：https://www.yuque.com/gudong-osksb/weekly公众号：咕咚同学本期目录02/18如何自律02/19系统性学习的重要性02/20选就选好的02/21掌控每一天02/22股票大涨了02/18如何自律如何让自己变得自律找到自己的核心习惯让“超我”管理”自我”你是自己的管理者，也是被管理者你是怎么变自律的？-高冷冷的回答-知乎https://www.zhihu.com/question/284206141/answer/490039014从本质上讲，人是动物，跟所有动物一样，每个人都拥有血肉之躯，与此同时，在几亿年的进化过程中，人体已经变成一台精密的仪器，各个器官都能够做到密切合作。这个进化过程中，我们的身体已经建立了完备的防御、自我保护机制，比如看到一个球朝自己飞过来，正常的人类都会下意识的躲避或者用手挡掉。跟我们平时喝茶、吃水果这些行为不一样，发起挡掉动作这个行为的瞬间，我们的身体几乎没有主观思考的成分，就是个人身体的一个条件反射，这个条件反射来源于大脑。在生活中，我们的很多行为都是大脑自己的最优选择。大脑喜欢懒床的感觉，所以我们早晨总是不自主的想多睡会，大脑中的味觉部分可能喜欢甜味，所以我们就很可能喜欢吃糖…等等，很多时候，我们最自然的选择都是大脑最原始的选择，这种时候表现出的自己就称为”本我”。我们体内其实还有一个”超我”。超我一开始很渺小，随着每个人的成长，学习，超我就会越来越强大。超我，我认为可以理解为一个理性的自己，更有上进心的自己。超我可以认识到本我的局限，所以要让超我去管理本我。而且每当本我想要偷懒时，超我就要去提醒它，激励它，让它无条件服从超我的管理。02/19系统性学习的重要性上周和这周陆续在看一个基金投资相关的知乎专栏，严格来说，自己不是在看，而是在学习。之前也操作基金，最早14年就开始了，但是一直缺乏系统性的了解，每次遇到投资新概念都是去百度一下，比如什么是ETF?基金跟股票是什么区别？分红是怎么回事？等等..一直都是遇到什么查什么，却从没有去找一些书籍去系统性的了解基金投资，这样的做法也使得自己韭菜气质越来越浓。看了专栏后，从方方面面了解了基金的来源，分类，购买卖出规则等等，才觉得自己之前对基金了解的太少了。现在回想一下，自己在没有怎么了解一个东西时，就把自己铺进去，这显然是一种对自己的不负责任，而且拿的还是真金白银。所以，这让我更加敬畏学习，敬畏知识，面对以后新东西或者自己不熟悉的东西，如果要参与，就应该先去花时间学习，而不是看到别人赚钱或者收益就盲目跟风。系统性的学习很重要系统的知识框架学习，是提高效率，节省学习成本很有效的方法。深以为然基金：从0开始学基金投资-知乎02/20选就选好的今天收到了公司的测试机，一加6T。这是一款功能强劲的手机，目前到手体验了几个小时，感觉很不错，只是有点大，这跟我之前一直用小米6有关。接着说说测试机。我们组内十多个人，这次只下来了两部，其中一部就是我的这部，所以下午看到这个6T格外开心。年前的时候，部门统计测试机器，每个人都可以申请，我纠结了一会。，心想到底选哪个类型、什么价位的手机呢？我很喜欢小米，主要是喜欢MIUI，也买了不少小米的设备，但是公司测试机不想继续用小米。什么东西用久了也会厌倦，当有机会可以选择新东西时，我还是愿意尝试新的。除了小米，貌似可选的很多，但是自己不喜欢OV的手机，开发体验太差，贵，使用起来也一股浓浓的苹果风，而且用久了特别卡，所以对于这个根本不考虑。华为不错，但是之前的UI一直看不惯，总觉得丑。锤子ROM不错，我挺喜欢拟物，但是质量，品控真的让人没信心，而且老罗跟王自如骂战之后，对老罗彻底无爱了。魅族，不喜欢flyme15年用过一段时间的一加3，很棒，ROM有点太简洁，但是用起来还挺舒服，速度流畅，那是我第一次觉得Android机原来也可以这么流畅。所以这次最后毫不犹豫便选择了一加。网上查了最新的机器便是6T,，作为18年的旗舰手机，各方面都是顶配。在定测试机时，我还想如果申请的太贵了，别最后不通过，是不是选个便宜点的成功率大，毕竟一加6T3000多呢。后来一想，要选就选最好的，不要犹豫，如果没有申请通过，也无妨，自己也没什么损失，但是放低自己要求，申请一个便宜的，自己不喜欢的，即使最后到手了，自己也不会那么在意它，何必呢。所以最终选择了一加6T,用投资中的话说，买就买赔率更大的标的物。只要赢一次就胜过很多次一般的投资行为。02/21掌控每一天以前，每一天都希望过得不一样，也喜欢新鲜，甚至自己都没有去注意每天是怎么过得的，。当然在学校的大多数时光都是被安排好的，貌似每天都在重复，但是那么多的业余时间，自己很少去规划，大都是想到什么做什么。这也许就是那时的快乐所在，随意、自由自在。现在却发现，每天都希望过得一样。或者说，每天都希望按照计划中进行。每天在特定的时间做特定的事，这样反而会让已经更觉得有意思。，比如每天锻炼身体，每天写文章。我想原因在于自己对自己的掌控感的体现。每天都这样自律的去完成自己指定好的事情后，会给自己一种暗示，—“我成功的管理起了自己”。每个人大都有控制的欲望，可能控制不了别人，后来却发现可以控制自己，而且控制自己更有挑战和难度。总之，让每天都按照自己的想法去过是一件值得挑战的事。我想我会越来越喜欢这种掌控的感觉，目前对自己掌控的还不够，有很多时间还是被浪费了，这是需要思考和不断改变的地方。02/22股票大涨了今天媳妇回家跟我说，他同事跟他炫耀今天一天赚了60万。是的，今天市场很不错，看了下支付宝的自选股，发现很多股票都涨停了，我的自选股里，除了乐视是绿的，其他都是红。每当市场大好的时候，市场就会变得燥热，经常从旁边就能听到别人赚大钱的消息，我怎么看这些呢？1、是的，有人赚钱了，一天之内还赚了不少，但是在这之前呢，他亏的很可能比今天赚的多的多，所以一天赚的那些不能说明什么，倒是可以大概知道这个人的持仓总额大小。2、如果自己还没有做足学习，就不要轻易去追涨，不要让市场搅乱自己的节奏。找到自己的节奏很重要，但是市场总会在你耳边制造噪音，以期打乱你的投资节奏，对于一个入门不深的投资者，小心驶得万年船，不要跟风市场。3、在市场里，每一个投资的人目的都是赚钱、盈利，但是和赚钱同样重要的还有一点，在市场里找到自己的投资节奏风格，建立自己对自己的投资方式的信心。往往其实后者更难。针对这样的市场，理性投资，不断学习。</li>
  <li>地址：《基金：从0开始学基金投资》作者：羊陪家by百度脑图关于基金股票股票，代表的就是一个公司的股份。拥有了一个公司的股票，其实就相当于你拥有了一部分公司的股份。债券债券，代表是一种债权，简单说，就说借钱给别人。国债，简单理解就是国家向你借钱，并给你打了张借条，上面写着“欠某某100元，约定1年偿还，利息1%”，这就是国债啦。买了债券，就相当于借钱给了他人，这个他人可以是国家、地方政府，也可以企业。债券的收益就是一开始说好的利息。基金基金就是一种委托关系。你委托专业机构（基金管理公司），它受你的委托帮你管理资金和进行投资。基金公司根据不同的投资标的，去把一份投资计划包装成一个套餐，然后给你选择。就像你去旅行社报团一样，会告诉你A套餐桂林3天2日游，B套餐上海5天4日游之类的，你根据自己的兴趣选择就是了。可以看出，不管是股票还是债券，他们都属于直接投资，但是基金是一种间接投资方式，投资人并不能直接买到投资标的（买到的东西），而是通过中间人去买。银行理财产品从大的概念讲，指的就是在通过银行来卖的理财产品，这些产品的本质有可能是基金，债券、信托、保险等等（不可能是股票），而具体是什么东东就得根据产品来看了。收益风险比较股票最大，基金次之，债券最低。银行理财产品视具体情况而定。基金主体投资人买基金的人就是投资人基金管理公司负责管理基金的公司，他们的工作包括发起设立基金，进行基金运作，帮助投资者获得收益。一个基金管理公司，可以管理多个基金（大点的基金公司，基本上都是好几十个）基金托管所谓“托管”，我们可以理解为托付保管，所以基金托管公司呢，其实就是被托付来保管基金资产的，他们的职责主要就是保管基金的资产，监督基金管理公司以及向监管机构出报告等等。一般的托管都是大银行来担任，而且基金公司和托管机构由证监会进行监督。基金的生命周期一只基金的一生就是如此了：产品设计——证监会审批——确认发行——公开发行（募集资金）——建仓期封闭——正式运作——清盘按照投资标的的分类，基本上可以分这么几种：货币型基金、股票型基金、债券型基金、混合型基金和指数型基金所谓股票型基金，顾名思义，就是大部分资金（不能低于80%的仓位）投资于股票的基金场外交易和场内交易所谓“场”指的就是二级市场，也就是证券交易所。场内交易，就是指在证券交易所里可以交易的，粗暴点理解，就是可以通过在证券公司开的证券账户里进行交易的。而场外交易，就是不能在证券交易所里交易的，即没办法通过证券账户进行交易的。基金类型开放式基金和封闭式基金这其实也是一种基金的分类方式，是按照运作方式来分类的。封闭式基金，即买了之后，是不能赎回的，只能够转让给其他人，即只能场内交易。而开放式基金，买了之后是可以随时赎回的，但是不能够转让给其他人，即只能场外交易。自己接触的基金都是开放式基金，不能够交易，只能申赎。ETF学名叫交易型开放式指数基金，但是上面说的，开放式基金是不能用来交易的，只能申赎，为什么ETF可以叫为交易型开放式呢？这是一个厉害的基金类型。（1）可以场内交易。可以在场内交易的ETF对比传统指数，就灵活许多，比如可以随时买进卖出，不需要跟传统基金一样需要第二天确认。（2）交易费用较低。相比起传统的指数基金，ETF的费用较低。（3）各种高级玩法。比如所谓的ETF套利，这其实才是ETF的牛逼所在，当由于过于复杂，且操作难度不小，继续跳过。（4）是指数基金只跟踪指数，也只能跟踪指数。LOF学名叫交易型开放式基金，这里没有指数的限定，也就是说LOF的投资标的更灵活，可以有很多选择，比ETF更灵活。ETF联接这是一个很关键的概念，支付宝里的大都数指数基金都是ETF联接。ETF除了上面说的交易型开放式指数基金，还有一个名字叫交易所交易基金，少了开放式，为什么？因为ETF虽然可以场外申赎，但是很麻烦，规定必须用股票来申赎，总之ETF很麻烦，他基本只能场内交易，不能场外交易。而对于大众的我们，大多数只能进行场外交易。这样很多人想买ETF怎么办？难道要去开证券账户吗？所以就有了ETF联接基金，它就是基金公司专门为了让那些没有证券账户，无法在证券公司进行该ETF交易的投资者也能对该ETF进行投资，而复制了一个场外可以申赎的指数基金。QDII可以投资国外证券的基金分级基金通俗的解释就是，把一个母基金劈成两半，一半是优先级，也称A类份额，另一半是落后级，不对，是进取级，也称B类份额。A份额和B份额的资产作为一个整体投资，其中持有B份额的人每年向A份额的持有人支付约定利息，至于支付利息后的总投资亏损由B份额持有人承担。可以这么理解，A是一个土豪，B是一个赌徒。A有钱B有胆。A稳妥为先，想获得固定收益，B赌徒心态，总想在市场上捞一把。于是A和B达成合作协议，俩人按1:1的比例共同出钱。A呢，每年拿约定的利息把钱借给B去赌（投资股票等权益类资产），B呢不管赌赢赌输，总是得按约定支付A利息。这样一来，A可以获得固定收益，B可以利用自己和从A借来的钱做更加激进的投资。分级A就是拿固定收益，分级B就是拿A的钱（加杠杆）去投资，博取更大收益，当然承受的风险也更大。量化基金采用量化投资的方法去管理的基金。什么是量化投资呢？就是“通过借助统计学、数学方法，运用计算机从海量历史数据中寻找能够带来超额收益的多种“大概率”策略，并纪律严明地按照这些策略所构建的数量化模型来指导投资，力求取得稳定的、可持续的、高于平均的超额回报，其本质是定性投资的数量化实践。”现在随着大数据、机器学习的兴起，这种基金可能会越来越好，目前还不怎么了解。基金购买赎回认购VS申购对于新成立的基金，购买行为称做认购；对于成立后的基金，购买行为称为申购。赎回不论申购、认购，卖出统统成为称为赎回。基金转换比如你持有华夏基金的基金A，现在你想买华夏基金的另一只基金B。通常做法是赎回A，再申购B，但其实你可以直接进行基金转换，把A直接换成B。基金直销基金大部分是通过代销来销售的，直销的话则以线上方式为主基金代销代销机构包括银行、证券公司和第三方销售平台（比如天天基金）申购费计算申购费用=申购金额*申购费率净申购金额=申购金额-申购费用申购份额=净申购金额／申购当日基金资产净值举个例子，某基金当天价格为1.5元／份，申购费为0.8%，现在准备拿1000元来申购这个基金。申购费用=1000*0.8%=8元净申购金额=1000-8=992元申购份额=992/1.5=661.333份其他基金A类与C类A类份额就是我们常见的前端收费份额，就是在买基金的时候，就把申购费用给扣除了，赎回费用就根据你持有期限的长短来决定，一般来说基金公司为了鼓励投资者拿久一些，持有时间越长赎回费用越低。C类份额是销售服务费收费模式的产品，在你申购的时候，它不收你申购费（最多可以省去1.5%），持有一定时间（比如你说的广发中证500持有大于7个交易日）则免收赎回费（一般为0.5%），但是羊毛出在羊身上，基金公司会按照你的持有期年化收取0.4%的销售服务费，比如你持有半年，就收你0.2%的销售服务费。按半年的持有期限看，明显C类份额比较便宜，但一旦你打算长期投资，C份额就不适合了，成本可能要超过你买A的成本。按我个人测算，拟持有时间在1年以内的，就买C份额。打算长期投资，或者长期定投的，就买传统的A类份额更合算。均值回归均值回归是指股票价格、房产价格等社会现象、自然现象（气温降水），无论高于或低于价值中枢（均值）都会以很高的概率向价值中枢回归的趋势。根据这个理论，一种上涨或者下跌的趋势不管其延续的时间多长都不能永远持续下去，最终均值回归的规律一定会出现：涨得太多了，就会向平均值移动下跌；跌得太多了，就会向平均值移动上升。其他投资原则好公司，好行业，好价格，适度分散，长期持有！链接以史为鉴：深度回顾中国股市历史上证指数的历史市盈率PE走势图_2019年_乌龟量化分别区分一下ETF，开放式基金，封闭式基金，LOF基金,分级基金都是些啥，有何异同点？-知乎</li>
  <li>今天是2019年春节最后一天。春节放了七天假，今年我没有回家去过年，而是在北京，这不是我第一次在北京过年，2017年春节也是在北京过的，那时在通州住，那个春节跟媳妇、还有丈母娘以及未满两岁的儿子一起过，但是印象并不深刻，那个春节只记得孩子一直在拉肚子，我也是，很悲催。今年跟父母还有孩子、媳妇一起在北京过年，年味确实多多了。在过年之前，老爹老妈在家卤了猪肉、猪蹄子还有鸡腿等，还炸了甜丸子，我们也买了不少年货，包括一些干货、生鲜食品。卤猪肉、炸甜丸子是老家的传统，我们家一般会在大年初一早晨吃火锅，这应该是我高中时开始时的习惯，今年也如此，媳妇也支持。初一早晨吃火锅，中午溜娃，晚上吃饺子。初二陪媳妇看《流浪地球》初三陪老爹老妈第一次去看3D电影《流浪地球》初四在家宅一天，晚上轩轩跳舞跳得很棒。初五晨跑，中午饭不错。初六初七陪娃去游乐场玩耍，玩的超开兴。要说最有意义的事还是陪父母去看电影。看电影之前我妈说，电影不都那样吗，还要跑去电影院看啥，浪费钱，老爹说自己不喜欢看电影，上次看电影还是20年前。我跟他们说，3D电影不一样，这是完全不同的体验。事实证明，3D电影的体验远超父母预期。到电影院后，我把父母带到电影院后，直到电影开始我才把3D眼镜给父母带上。第一次看3D电影，我很期待他们看到3D效果后的反应，老爹很快就别这种观影方式吸引了，对旁边座位的老妈说，很不错。父母大半辈子了，3D电影一直没看过，自己也是想到了这一点，想让他们体验一些没有体验过的东西…</li>
  <li>今天的西二旗地铁早高峰今天是2019春节前的最后一个工作日，我还在公司里上班，因为今年父母、孩子都在北京，所以我没有回老家过年去。今天公司里人已经很少了，大部分人已经提前请假回家了，不过公司里却多了不少小朋友。之前还不知道有这样一个习惯，就是过年前的最后一天，公司有孩子的同事们会把自己的孩子带到公司里玩耍。我旁边工位的产品同学也带了自己的孩子，是个小男孩，很温柔，说话声音很细，一开始并不怎么说话，看着他一个人玩的无聊，我今天也没什么事，所以就主动过去逗他玩，我给他叠了纸飞机，后来还教他叠，他学的不错，模仿的有模有样。不一会儿就玩熟了，便开始主动跑过来跟我玩。他跟我介绍了自己的布娃娃，还有小车，听她妈妈说，他很喜欢车，貌似小男孩都有共同的爱好，就是小汽车，不管什么车好像都喜欢似的。我孩子也是。家里已经给他买了很多车，大的、小的、长的、短的，有卡车、挖掘机、吊车等等，玩起车来，他总是乐此不疲。中午去跟同事一起吃了饭，饭后我还是一如既往的去外面溜达。这个习惯已经很久了，因为吃完饭，如果直接回去工位呆着，总觉得是一种不健康的习惯，去外面溜溜可以让胃里的东西更好的消化，还可以让自己的眼睛也休息休息，这一年，明显觉得视力出现了下降，经常性的，在看电脑时眼睛觉得冒火花，觉得恍惚。昨天和前天在思考这些年开发过的App。自己这几年开发了不少个人App，但是每次都是从头去搭建一个项目，很多经验都没有得到沉淀，突然发现这是一种很大的损失，因为没有累计效应，一直在重复，其实效率低下。所以上周开始思考搭建一个个人的快速开发框架。这个框架包含自己经常用到的一个组件、页面，可以让自己在日后有App新点子时，快速帮助自己实现一个可用的App。最终，我选择了用Kotlin作为开发语言，完成了这个快速开发框架。昨天已经跑通了所有功能，还把编译打包、代码混淆也都完成了，只是在上传到Maven时又出现了问题。今天早晨我想到不再上传到Maven，改为JitPack，上传过程方便多了，很顺利的完成了上传。这是最终的框架地址，https://github.com/maoruibin/MaoAppBase项目发布在了Github，本来打算设置为私有，但是JitPack要求项目必须公开，所以设置了公开，但是这还是一个自用的项目。下午休息完，没过多久，同事们便开始走的差不多了，我也便提前联系媳妇一块回家了。媳妇公司是一家传统行业，今年的福利很多样化。哪天送了他们购物卡，今天给他们送了零食大礼包。回家后看到大礼包，发现有自己爱吃的牛肉干，真是太棒了。回到家里，老爹老妈在炸土豆丸子，貌似馅不是很好，因为土豆的原因，但是味道还可以，妈妈炸完，我们就吃了热腾腾的天丸子，好吃，但是一不小心又吃多了。这两个月，自己经常因为吃多而胃不舒服。这在以前是很少见的。我记得以前胃口好，消化也不错，遇到想吃的、爱吃的，从来不管不顾，吃多了顶多肚子撑一会，但是很快便好了。而现在，我需要小心翼翼的对待我的胃，生怕吃多了，但是今天看到甜丸子，还是吃多了。加之是甜味的，不好消化，所以不舒服是在所难免了。下午妈妈问晚上吃什么，我说吃羊肉面片，但我只少吃一点。这段时间也是，吃东西时，我已经变得越来越小心翼翼，生怕吃多了，因为自己的胃现在真是越来越脆弱。也因此，我会在吃完中午饭会经常去溜达。从以前吃饭不管不顾，到现在吃东西小心翼翼，第一次意识到自己的身体在发生变化。自己也开始调整，毕竟这关乎自己的根本感受。我觉得一段时间内，自己还是应该去刻意控制饮食，少食多餐，多吃清淡，川菜等辛辣的我看我还是过几个月再吃吧，还有各种糖，包括甜食，自己也应该少吃，甚至不吃。目前来看，这些约束为我挺难的，但是不论如何，这次一定要调整了…最后春节前的最后一天就这样结束了，跟其他时间没什么大的区别，只是回来的早了一点。这是今年一整年真真的结束。2018做了很多事，不论工作还是生活，工作中自己还是有很多不满意，有客观因素也有主观因素，这一年，自己还是一线写着没完没了的需求，已经是常态，但我也在不断调整。生活中，逐渐稳定，家庭也在随着孩子的长大，变得越来越协调，希望越来越好。2019年，其实很难说。工作中，我不知道还会有什么变动，但对自己来说，还是应该专心去提升自己价值，但说到如何提升价值，这可能又是一个大话题了，简单来说，还是应该专注于自己能力的提升，多思考多实践。生活中，今天孩子要上幼儿园…这可能会让今年很多事都随之变化，这是一个新的开始。Lessismore…</li>
  <li>Drawable是开发中经常用到的一个概念，我们经常用它去设置View的背景，背景可以一个颜色值，也可以是一张资源图片，还可以是一个自定义的Drawable等等。这篇文章就简单说下Drawable与View的关系，同时结合代码，简要分析一下Drawable如何作用于View。Drawable介绍官方介绍ADrawableisageneralabstractionfor“somethingthatcanbedrawn.”MostoftenyouwilldealwithDrawableasthetypeofresourceretrievedfordrawingthingstothescreen;theDrawableclassprovidesagenericAPIfordealingwithanunderlyingvisualresourcethatmaytakeavarietyofforms.UnlikeaView,aDrawabledoesnothaveanyfacilitytoreceiveeventsorotherwiseinteractwiththeuser.简单翻译下：Drawable是“所有可绘制东西”的一个抽象，大多数时候，我们只需要把各种不同类型的资源作为转化为drawable，然后View会帮我们把它渲染到屏幕上。Drawable类提供了一个通用API，用于解析转化各种可视资源到Canvas，跟View不一样，Drawable不能接受任何事件以及用户交互。总而言之，Drawable就是一个可绘制东西的抽象，相比View，它更纯粹，就是用来做绘制相关事情的，它处理不了用户交互事件，也不需要处理，所有交互相关的事都是由View来完成，但是背景相关的事大都可以通过Drawable来完成。一般的，我们要为View设置背景，可通过如下几种方式：通过颜色为View设置背景通过自定义的shape设置背景用颜色设置背景通过View的setBackgroundColor方法可以设置颜色为View的背景。button.setBackgroundColor(Color.YELLOW);效果如下：用自定义的shape设置背景先用xml自定义一个圆角空心描边矩形shape&lt;shapeandroid:shape="rectangle"&gt;&lt;cornersandroid:radius="4dp"/&gt;&lt;solidandroid:color="#fff"/&gt;&lt;strokeandroid:color="#ef6f06"android:width="1dp"/&gt;&lt;/shape&gt;通过代码进行设置button.setBackgroundResource(R.drawable.bk_normal);效果如下：可以看到，给View设置背景drawable非常简单，具体通过如下的API实现背景设置：setBackgroundColor(@ColorIntintcolor)setBackgroundResource(@DrawableResintresid)setBackground(Drawablebackground)但是设置的背景Drawable是如何在View上生效的，可能很多人没去思考过这个问题，这里简单分析下。Drawable如何作用于ViewDrawable是一个抽象类，这里通过它的的几个抽象方法就能大概猜得出Drawable如何作用于View，下面是Drawable的几个抽象方法：publicabstractvoiddraw(@NonNullCanvascanvas);publicabstractvoidsetAlpha(@IntRange(from=0,to=255)intalpha);publicabstractvoidsetColorFilter(@NullableColorFiltercolorFilter);publicabstract@PixelFormat.OpacityintgetOpacity();可以看到这里有一个draw方法，并且参数中提供了canvas对象。publicabstractvoiddraw(@NonNullCanvascanvas);现在可以想象一下，View通过setBackground方法为自己设置了一个drawable对象后，而drawable又有一个draw方法，那么View绘制自己的背景时，直接调用drawable对象的的draw方法，这个draw方法需要一个canvas对象，这里可直接把View的Canvas对象传递过去，那么Drawable就可以成功的把自己的绘制内容应用到View之上。这个过程，相当于View把自己的背景绘制功能外包给了Drawable对象。而且，这也是一种非常好的设计模式，View负责测量自己大小，给自己指定位置，并绘制View前景，但是把自己的背景绘制外派给了更独立的drawable去做，从而做到了让自己更加轻量，现在View就成功的把背景绘制职责分配给了自己的drawable对象。尽管上面只是想象，但事实上也确实如此。通过查看源码，在View中有一个私有方法drawBackground，它的作用就是把drawable绘制在canvas上。/***Drawsthebackgroundontothespecifiedcanvas.*@paramcanvasCanvasonwhichtodrawthebackground*/privatevoiddrawBackground(Canvascanvas){finalDrawablebackground=mBackground;if(background==null){return;}setBackgroundBounds();//省略部分代码finalintscrollX=mScrollX;finalintscrollY=mScrollY;if((scrollX|scrollY)==0){//调用drawable自己的draw方法，从而将绘制的功能移交到drawable类background.draw(canvas);}else{canvas.translate(scrollX,scrollY);background.draw(canvas);canvas.translate(-scrollX,-scrollY);}}Drawable与View的关系View是皮，它是一个具体的东西，看得见摸得着，因为它自己可以测量自己打消、指定自己位置，还能接受onTouch事件从而处理用户交互。Drawable是毛，它可以不存在，因为View完全可以在自己的onDraw时机中，自己把自己绘制了，无需把绘制进行外包。但是Drawable更专业，更独立，它提供了一整套丰富的背景Drawable机制，它有丰富的实现类，可以提供给View进行方便的背景设置，对View来说drawable提供的那些实现类开箱即用，还可以减少自己的职能，节省自己的维护开销，何乐而不为。总结Drawable是一个抽象的概念，只要理解了它跟View的关系，其实Drawable的想象力会非常大。通过自定义Drawable，可以在Drawable中完成各种绘制逻辑，自定义完成后，只需要让View调用setBackground()方法，把自定义的Drawable传递进去，这样就可以方便把自定义Drawable和View关联在一起。之前写过一个转菊花的Loading效果，就是用自定义Drawable实现的，目前已开源在github，感兴趣的去看看。FlowerLoading:Androidloadingorprogressview,justlikeiOSIndicatorView.</li>
  <li>快过年了，昨天跟媳妇一起去了朱辛庄附近的一个批发市场，去准备购置年货。这是一个很有规模的市场。分别在不同的大棚里有不同种类的商品，比如生鲜、肉类、海鲜大棚、调料、杂货大棚，还有蔬菜水果大棚。在肉类大棚里，会有100个左右的摊位在买着猪牛羊肉，一般我们会先去肉类大棚卖猪肉，这里的猪肉比较便宜，一斤7、8块钱左右。每次我们进这个棚的时候，我们都会先捂着嘴，因为我们知道这里面的气味特别大。这次也不例外，我们进去的时候，扑鼻而来一股令人窒息的气味，这次的味道貌似更重，这是一种各种肉腥味跟消毒液等化学品结合在一起的味道，难闻至极，每次进去后，要过一会儿，自己才会适应这个味道。加之市场鱼龙混杂，所以我们不会带孩子来这里。但就在这样的环境里，我却不止一次的看到很小的孩子偎依在自己父亲或母亲傍边，守着摊位。每家每户都有各自不同的情况，不知道他们为什么会把孩子带到这种环境里，从常理来讲，这里气味大，不安全，嘈杂，潮湿等等因素，都不是一个适宜孩子呆的地方，所以唯一能说的通的的就是生活所迫，为了生意，为了生活，不得不让自己孩子跟着大人一起在摊位。一开始看到后，我觉得挺难受的。这么小的孩子，也就一岁半，为什么要遭这种罪，想想刚进入市场时那刺鼻到令人窒息的气味，就越发觉得小孩子在这种环境下，简直太受罪了。很快的，我便开始去理解了。我觉得这些小孩呆这里是受罪，只是从我自己的角度去出发，拿自己去跟他们进行了对比，参照物是我自己，而我自己工作、生活环境都要比这些摊位的老板们好。我在北京明亮的写字楼里上班工作，在一个还算不错的小区里整租着一件两居室，宽敞明亮，干净舒适，周末双休，自己上班虽不是朝九晚五，但也不是996，父母专职在北京帮忙带孩子，周末有空就会带孩子、父母去游玩等等…所以在这样的对比下，我第一感觉是正常的。但是得出的结果却是不严谨的，这个结果也是我自己的结果，并不是孩子的实际结果，只有他们的父母才知道，这样是不是好的。甚至，在他们看来，这已经是最好的带孩子方式了。他们可能来自一些小城市，孩子一开始在老家呆着，由爷爷奶奶陪着，甚至可能没有爷爷奶奶，在老家孩子更少，可能连陪他的人都没有，父母把他们带北京来，这里人多，有人陪他玩，而且还是在北京这样的大城市，怎么都比早老家的环境好，对孩子的视野见识都有帮助，哪怕跟自己的爸爸妈妈呆着这环境恶劣的批发市场。甚至，在爸爸妈妈眼里，这里的环境一点都不恶劣，这里可以看到很多人，可以看到不同的小朋友，还可以看到小鱼小虾，还有各种水果等等…所以换个角度，父母看待孩子所处的环境跟自己的看法简直天壤之别。</li>
  <li>10年真是一个有意思的概念。上学时或者说大学及以前，是没有十年这个概念的，那是更多的时候是在电影、电视剧中听到剧中人物回忆10年前如何如何，那是总觉得10年是好远的事，也没啥感想，现在不一样了，尤其是这两年。现在一想，擦！！10年前还是高三-大学过渡期，还在怎么一晃10年了，工作都快6年了，结婚了，大学同学好多已经很久不见了，父母也老了，家越来越远了，总之10年发生的事很多，只觉得不像是过了十年。以前觉得自己是十年的旁观者，现在却忽然已经成为了10年的参与者，这种差异确实我带来很多不一样的感觉，有时会觉得难以置信，不敢相信。10年前我1910年后我2910年前我在呼和浩特上大学10年后我在北京写字楼里写代码10年前生活在宿舍楼了10年后在北京沙河10年前桌子旁边最喜欢的吃的是1.5一袋的披萨卷和馍片10年后桌子旁最爱吃得是7.5一盒的蜜汁味薯片10年前在校园球场跟同学打篮球，10年后在公司附近公园跟同事打篮球10年前我用的金立功能机10年后我用着一加智能Android机10年前…10年后…</li>
  <li>存在即合理，这是流传很久的一句话。但事实上并不能应用于所有事。有时我们应该去试着质疑一切存在的事物，当然这不是要去做”杠精”，而是用一种独特的眼光去看世界。一旦真的这样做了，会发现存在的并不一定合理，甚至一些东西存在很久了，或者你已经习惯很久了，但他们可能都是错的或者不好的，总之它们可能并不是合理的。比如说地铁里的”先下后上”，在这之前我是一个坚定的支持者，我认为地铁到站后就是应该先让乘客下完，然后车外的乘客再按顺序上车，自己一直也是这样执行的，只到今天早晨，我觉得这个规则其实并不完善。早晨在换乘地铁站时，人比较多，由于我在车门口，但我还没有终点站，所以我选择下车，等人下完再上车。下去后，我还是按照先下后上，等车里的人下完再上，但是里面的人下的很慢，导致自己最终没上去。里面的人为什么下车慢，一方面是因为人确实太多了，他可能不好出来，另外一方面也许是他就没想着提前换一下，把自己换车门口…不论如何，最终的结果就是自己没上去，我奉行”先下后上”，最后却没有上去。这不禁让我觉得规则是死的，在具体的场景下，一些规则是不能完全遵守的，要去破坏它你才能更好的让自己出于有利位置，甚至规则本来就不一定是完善的，有时就需要一些不守规则的人去破幻它，打破它，让制定规则的人去重新思考规则合理性。</li>
  <li>北京动物园游水的鸭子、天鹅们2018年的最后一天带孩子和爸妈去了北京动物园。天气不是很晴朗，但是风很小，在动物园里看了大熊猫、大象还有一些小猴子，他对动物看上去兴趣不大，直到看到了在水里嬉戏的鹅、鸭子。下面说说我的2018。学习Vue、WebPack等前端技能在工作之初曾有过一段“野鸡”的前端开发的经历，但是那时对前端开发了解并不多，而现在前端变化很快，这几年陆续听到了很多前端框架，所以今年年中有一段时间正好公司内部有一个需求，需要自己写一个前端页面，其中已有的UI是用Vue写的，所以自己便开始边学边用，把Vue用了起来。同时为了了解Webpack打包技术，还找了一个视频教程去学习了Vue以及Webpack打包技术。这里特别感谢慕课网的一个老师，这是教程地址-Vue+Webpack打造todo应用-慕课网，老师讲的特别好，结合一个简单的网页TODO应用，老师完整的开发完了这个项目，我也跟着老师敲完了项目。开发柳叶清单柳叶清单-https://gudong.site/list在学完vue还有webpack后，我终于可以把自己长久的一个想法实现了-**一个类似Trello网页清单程序**。利用Vue技术做UI很轻松，但是没有后端数据库等支持，所以自己找了Leancloud，它提供云函数机制，所以我可以很方便的去用它做后端的事，它极大的简化了柳叶清单的后端工作。后端选择了Python语言进行支撑开发，柳叶清单所有的请求接口都是自己实现，这在leancloud中实现非常easy，试想如果一开始让自己搭建一个服务器环境并部署，我觉得很可能会跪，柳叶清单也不会完成。再次感谢leancloud。玩转后端不知道为什么，一直以来自己都想尝试后端开发，总感觉它有魔力一样，所以今年在开发柳叶清单时，自己便花了不少时间去写后端的代码。我是用的Flask框架去编写后端的API，如清单的登录、注册、添加、删除、更新清单等，自己还对代码结构优化了好几次，代码后来也被自己开源了，严格的说我只是把他放在了github。maoruibin/waishuo:歪理歪说在开发完柳叶清单，后来梳理了所有API，并把它们整理，然后把API开放了处理，尽管现在还没人用我写的清单API。柳叶清单开放Api|咕咚leancloud还支持定时函数，所以开发在开发清单时，我想每天把清单的用户、最新数据都给自己用邮件的形式定时发给自己，就用了定时函数干了这个事。甚至自己还做了一个定时监控程序，用于监控EOS的价格，以便自己做波段操作，后来也是被自己玩废了，短线伤不起。总体来说，做了四五年的前端Android开发后，感觉后端开发更有魔力，它的想象力更大更丰富。工作今年陆续做了不少微博首页相关的功能，其中影响最大的是首页Tab管理重构，其实只是把前人写死的tab顺序做到了动态配置，支持任意的Tab排序，嗯嗯，今天微博首页更新了，很多用户还吐槽发布器找不到了（被移动到了右上角）,视频签被独立了一个Tab。工作中自己技术方面提升的并不多，因为大部分在做业务，所以对业务倒是越来越熟悉，后来自己接手了微博发布器模块，这块经手了太多人，所以维护起来相对麻烦。今年还模仿Facebook重新设计了发布器菜单。最重要的提升我感觉还是工作方式以及工作意识方面的提升。另外对待技术还是要认真、做到知其然之气所以然，精益求精。参加百日计划在朋友圈看到小创的每日打卡计划后，自己也加入了打卡群，完成了两项百日打卡：每日100俯卧撑每天看非技术30分钟任何事情，坚持很重要，坚持是一种能力。让时间慢下来-简书俯卧撑时的思考-简书篮球今年夏天时自己在中午时经常去一号院球场打球，成功纠正了投篮动作，现在投篮确实准多了。西山一号院球场夏日中午一号院打球另外就在12月28号，我们也成功获得了今年新浪内部篮球赛的季军，这已经是非体育专业的最好成绩。今年人员很均衡，大家都很热爱篮球，最终在一开始3局2负的开局情况下下成功在最后逆袭成功，圆满…痛快的比赛折腾天津户口天津在年中开启了海河英才计划，之前需要花3、4万才能办的天津户口，现在只需要有本科学历就可以，所以今年便趁这波机会去办理了天津户口。折腾虚拟币自己从2018年初开始接触，也就是牛市的尾巴才进行参与，后知后觉，这是一个错误的时间，加之之前投资经验并不多，所以这一年注定就是交学费的过程，好在自己并没有Allin，亏损也在接受范围内，自己逐渐开始学习交易、投资相关的东西，总觉得这方面应该会越来越好。时机很重要、本金也很重要，最重要的不要输掉心态、信心，活下去…看书看书能带给人无数的启迪与思考，花费时间看书上，是让时间升值的最有效方式之一。高阳版《胡雪岩全传》1商场典范人物，做大事不拘小节，但小节处理的还特别好。拳王泰森自传《永不后退》一个真实的人，《泰森自传》读后感道德经世间万物都离不开道，物极必反，道德经真是值得反复阅读的好书写给大家看的设计书亲密性、对齐、重复、对比。非常简单有效的四个原则，对于一般的设计，使用好这四个原则已经足够了。理解人性讲了不少孩子心理相关的内容，这是一本心理学书籍。电影龙猫1986年的电影，异常好看，太暖心了，重要的是轩轩更爱看，看不不下5遍了。阳光灿烂的日子姜文，真实的人有魅力，喜欢他，今年还特意去了内务部街的胡同两次，姜文这个导演|咕咚我不是药神年度佳作，成功的现实主义作品，好看，有力量的电影西虹市首富真的没有大家说的那么好看江湖儿女廖凡演的很好，第一次看贾樟柯的电影，很压抑，没怎么看懂。吃喝玩乐9月份跟同事一起去了古北水镇，水镇很漂亮，江南小镇。染布坊安静的胡同水桥司马台长城今年老妈来北京后，享了不少口福，老妈做了不少好吃的，有烙饼、窝窝饭、卷卷子，甜饭…很开心。老家窝窝饭烤土豆片家庭轩轩在越来越长大，带给了我们很多的欢声笑语，在变得越来越好…19年lessismore迎接变化时间、效率、精力</li>
  <li>Photoby223223onUnsplash最近看《地球脉动》纪录片时，有一个情景让人影响深刻。大群的北美驯鹿在迁徙时，狼为了猎食驯鹿会先冲进鹿群，让驯鹿们惊慌四窜，然后一些驯鹿就会脱离鹿群，接着狼才会真真发起攻击，去攻击离散的驯鹿。这个方法很凑效，一些小驯鹿往往以这种方式丧命。反思一下，其实这个道理对人类也非常适用。在生活中，有很多错误往往是自己在慌乱时犯下的。因为在慌乱的情况下，人的大脑一旦处于紧张的状态，就很难去把所有的因素都考虑清楚，因而便很容易的忽略掉一些关键点，从而导致自己做出失败的决定。与此同时，一些机构或者个人会去专门利用这一点来获利，比如一些销售人员，为了让你很快做决定，会刻意通过各种手段制造紧张气氛，就像纪录片中的狼，他们是制作慌乱的高手，他们试图让你的大脑变得慌乱起来。只要处于慌乱状态，局势就很容易被对方控制。面对这些，我们所做的其实很简单。时刻让自己保持清醒的头脑，一旦发觉自己进入慌乱状态，就尽快抽身出来，让自己的大脑停一停，然后去重新思考和审视，而不是被外界因素带节奏。这让我也想起了之前一个同事，他平时经常最爱说的一句话便是：不要慌、不要慌…</li>
  <li>FlutterFlutter是Google开发并开源的一套跨平台移动开发框架，它使用Dart语言进行应用层的开发，一套代码可编译出iOS、Android双平台的应用包。Flutter拥有出众的开发体验，支持热重载。同时提供了一整套丰富、灵活、有表现力的UI组件。Flutter使用Native引擎进行视图渲染，小组件提供完整的原生性能。框架介绍Flutter框架整体分为两层，包括上层的应用层以及底层的Engine层，应用层主要使用Dart语言开发，Engine层使用C++开发，整体框架图如下所示：图片来自：flutterchina.clubFlutterFramework:这是一个纯Dart实现的SDK，Dart之于Flutter就像Java之于Android。这一层用Dart实现了一套基础库，用于处理动画、绘图和手势等，并且基于绘图封装了一套UI组件库，然后根据Material和Cupertino两种视觉风格区分开来。这个纯Dart实现的SDK被封装为一个叫作dart:ui的Dart库。我们在使用Flutter写App的时候，直接导入该库即可使用组件等功能。FlutterEngine:这是一个纯C++实现的SDK，其中囊括了Skia引擎、Dart运行时、文字排版引擎等。不过说白了，它就是Dart的一个运行时，它可以以JIT、JITSnapshot或者AOT的模式运行Dart代码。在代码调用dart:ui库时，提供dart:ui库中NativeBinding实现。不过别忘了，这个运行时还控制着VSync信号的传递、GPU数据的填充等，并且还负责把客户端的事件传递到运行时中的代码。源引：stephenwzl.github.io看完了Flutter的大体概况，下面从UI、网络、线程三个方面分别聊聊Flutter。UI在FlutterUI设计中，“Everything’saWidget”，Widget是Flutter构建界面的基本元素，除了通常意义上的Button、TextView等，在Flutter中控制居中、设置Padding、甚至点击事件都是通过Widget实现的，下面就是一个简单实例：页面居中显示一个Text。如上所示，整个页面是HelloPage就是一个Widget，继承自StatelessWidget，这个类只有一个重要的方法build()，他用来返回页面显示对应的Widget，可以看到Widget是一种树结构，通过嵌套来组织布局，有点像Android中的ViewGroup。关于Widget，它是组织UI的关键元素，大部分时候我们都需要去用它进行页面制作，需要注意的是在Flutter中Widget分为两种，即不可变、没有状态的StatelessWidget，以及有状态可更新的StatefulWidget。怎么理解？什么是不可变、没状态？一些页面或者元素没有任何交互，比如一个Text，给定了文字内容，对于Text这个Widget就不会发生变化了，所以他就是一个StatelessWidget，而对于一些组件，如输入框、选择器…他们在使用过程中根据交互，UI会发生变化，这样的Widget就是StatefulWidget。Flutter推荐在可使用StatelessWidget的情况下尽可能使用StatelessWidget，因为他有更好的性能。但是应用开发中，很多情况下我们还是要使用StatefulWidget，在使用StatefulWidget时，如何更新UI状态呢，具体可看小部件简介-更改小部件以响应输入。另外在Flutter中所有的界面都是不可变的一部分，每次更新时都会重建Widget树结构进行渲染，只是这里Flutter会有一套自己的diff算法，尽可能执行最小更改，所以页面使用越多的StatelessWidget，渲染性能也就会越好，当然也好因地制宜。关于Flutter的渲染，他跟其他的跨平台方案不一样，直接在应用框架层加入了自己的跨平台渲染引擎-skia，这样就完全接管了应用的绘制，Flutter的绘制过程直接跟设备的GPU对话，完全跳过了平台的UI那层东西，所以说FLutter才是真正的跨平台方案。在运行期，Flutter会把自己的Widget树结构转化为RenderObject的树结构，这个树结构是真正的渲染树。网络请求得益于Dart语言的特性，利用Flutter进行网络请求很简单，可以利用http包进行各种各样的网络请求，如下是一个简单的Get请求示例：import'package:http/http.dart'ashttp;varurl="http://example.com/whatsit/create";http.post(url,body:{"name":"doodle","color":"blue"}).then((response){print("Responsestatus:${response.statusCode}");print("Responsebody:${response.body}");});更多关于网络请求的内容可参看在Flutter中发起HTTP网络请求线程Flutter是单线程模型，这块是由Dart语言所决定的，Dart支持良好的单线程模型，并提供了多种异步操作的方法。具体参看dart：异步库-DartAPI。总结Flutter提供了一套彻底的移动跨平台方案，核心在于自己的渲染层设计，目前看来，Flutter野心很大，同时它也提供了非常丰富的文档支持，如果是自学，把官网的文档看一篇基本就可以进行正常的开发了。跨平台开发一定是未来的趋势，我们应该拥抱变化。另外学习应用把握核心知识点，关于Flutter，我们一定要花时间精力去搞清楚它的渲染绘制原理。参考链接/Flutter好文Flutter原理简解·stephenwzlFlutter-不一样的跨平台解决方案-掘金Flutter·闲鱼技术·语雀</li>
  <li>最近一段时间一直在读泰森的自传《永不后退》，今天终于读完了。读完后有很多感悟，其实很多感悟在读的时候更加深刻，但是这里我还是想简单记录一下。在没有读这个书之前，我对泰森的认识很浅薄，大多数都是从网上了解到的只言片语。世界拳王，打拳硬朗。在叶问3中担任过一个角色，跟甄子丹有过一段非常精彩的打斗。被判强奸罪，入狱三年。…上面就是我读书前对他大概的了解了。但是读书的过程中，对泰森这个人的认识却慢慢的清晰起来了。一个十足真实的人这本书是他的自传，是他跟一个传记书作者-拉里.斯洛曼一起合力完成的，顺便说一句，在读这本书之前，我还不知道原来有一个职业叫做名人传记作者。这本书在2012年开始写，2013年写完，期间两人一起写作，主要的写作方式应该是后者跟泰森通过不断的问答来了解泰森过去发生的事，然后拉里进行整理，最终以泰森的口吻进行了整书的叙述。在叙述过程中，泰森是用一种过来人的口吻在讲解，所以阅读的过程中感觉很清切，看书的过程就像是跟一个老朋友在聊天。这本是我读过的第一本个人自传，让我感到影响深刻的是，泰森在描述自己过去的时候，可以说丝毫不掩饰以前的过错，对自己的生活、以及各种各样的丑态丝毫不掩饰，完全是一种极其客观的描述。对于每个人来说，自己要写一本描述自己的书籍，想象到像他这样的身份、影响力，出版后必定会有大量的读者，但是自己却丝毫不去掩饰或者去刻意忽略掉一些对自己影响不好的描述，真的难能可贵。在书籍的评论中，我也不止一次的看到别人在称颂他的这一点，真的是非常勇敢的称述。全书他描述了一个真实的自己，他是混蛋、他是傻瓜、他暴怒、他狂躁、他性成瘾…当然在他描述这些的同时，他也在诉说自己真实的品质以及勇敢的一面。一生最重要的人-库斯在读这本书之前，我是完全没有听过这个人的，但在读完库斯的哪章后，我就知道，这个人必定是泰森一生的贵人。泰森本来的人生路线可能跟他的大多数朋友一样，在那些混乱的街区过着偷盗、抢劫的生活，不定哪天就会被枪杀，但是却机缘巧合的遇到了自己的人生导师-库斯-达马托，从此他的人生硬是被拉上拳击的轨道。这个老头倔强固执，从一开始就认定泰森会是未来的的世界拳击冠军，而泰森自始至终也不知道为什么库斯一开始就会这样认定。全书中泰森都在称颂这个人，我不知道实际生活中泰森会不会这样思考，库斯成就了泰森，泰森也成就了库斯，但是泰森在后来遇到了那么多的麻烦后，他会不会设想没有遇到库斯后的生活，毕竟他后来的生活实际上非常痛苦，如他自己所说“你们只看到了我一次次的击倒别人，你们知道他背负的压力有多少，换做你们，你们做不到”。当然，全书泰森自始至终没有表达过类似的感慨。库斯为泰森做了很多工作，他们的感情亲如父子，库斯投入了所有，很难想象在那个充满种族歧视的年代，这个白人老头跟他的妻子可以如此去接纳一个黑小子，并为他倾其所有。只不过库斯去世的有点早，这一点库斯甚至早有预料，他后来说自己最大的担心就是时间，他在有限的时间里教会了泰森拳击场上的所有的技术，但是却没有时间去教他处理赛场下的事务。这也为泰森后期混乱的生活埋下了伏笔。泰森对拳击十足的爱无疑，泰森曾经对拳击如痴如醉，对拳击是一种完全的爱，这段时间应该在他13岁到18岁之间。他可以整日缩在自己房间里看以前的老拳手的录像，他可以非常自律的完成自己的训练。在自己跟库斯在一起的那段时间，他就是一个训练狂魔，疯狂的训练以及对拳击疯狂的爱成就了一个同年龄段的拳击怪物，他是一个Animal。任何职业当你全情投入的时候，很难不成功，而要全情投入，就一定需要持久的动力，这个动力更多的时候是来自内部，所以最好的动力就是这件事的兴趣。混乱的个人生活凡事都有两面，泰森成名后有钱了，有威望了，随之而来的就是各种麻烦。泰森的经历可能是所有名人遇到问题的放大版，像一个典型。他吸食大麻、酗酒、暴力、性成瘾…直到后来被以强奸罪之名送入了监狱，人生糟糕到了极点，后来出狱后财务问题也非常多，经纪人给他挖坑，甚至连老婆都想法设法掏空他…糟糕透了。但泰森内心依旧是一个坚强的人，他并没有跌倒，他后参加互助会，解毒，在监狱里还学习穆斯林，另外他一直在坚持学习、坚持看书。感觉泰森看过不少书。尽管他只有二年级水平，这一点让我很惊讶。结尾关于泰森真是可以说太多了，他身上有诸多可以讨论的东西，读书的过程就是了解他的过程，他本身有很多故事，这些故事的背后往往可以带来更多的反思，所以这也是读这本书的价值意义所在。</li>
  <li>介绍柳叶清单是自己开发的一个Web清单应用，目前网页版已经上线运行，地址如下：http://gudong.site/list为了方便其他开发者使用清单服务，现在开放了部分API，以便大家可以使用这些API去开发自己的todo应用，而不需要去建立自己的后台。这里先简单说一下具体的数据model关系，目前一共有4个model，分别是User、Project、Group、Todo.User:用户信息Project：清单项目，一个用户（User）可以创建多个清单项目。Group：分组，一个清单项目（Project）包含多个清单分组Todo：事项，每个分组（Group）下有若干Todo组成这个关系用图表示出来如下所示：上面的示意有点抽象，这里用一个具体的例子进行展示如下：下面是目前开放出来的所有数据操作相关的API，包括用户登录、注册，以及事项（Todo）、分组（Group）、项目（Project）数据的操作，如下所示：用户信息登录https://waishuo.leanapp.cn/api/v1.0/users/login请求方式：POST请求参数：响应结果：注册https://waishuo.leanapp.cn/api/v1.0/users/register请求方式：POST请求参数：响应结果：获取用户信息https://waishuo.leanapp.cn/api/v1.0/users/请求方式：GET说明：url请求参数中最后需要指定userid请求参数：无响应结果：Todo创建todohttps://waishuo.leanapp.cn/api/v1.0/todos请求方式：POST请求参数：响应结果：更新Todohttps://waishuo.leanapp.cn/api/v1.0/todos/&lt;todoId&gt;请求方式：PUT说明：url请求参数中最后需要指定todoid请求参数：响应结果：删除Todohttps://waishuo.leanapp.cn/api/v1.0/todos/&lt;todoId&gt;请求方式：DEL请求参数：说明：url请求参数中最后需要指定todoid响应结果：获取Todohttps://waishuo.leanapp.cn/api/v1.0/todos/&lt;todoId&gt;请求方式：GET请求参数：说明：url请求参数中最后需要指定todoid响应结果：分组API创建分组https://waishuo.leanapp.cn/api/v1.0/groups请求方式：POST请求参数：响应结果：更新分组https://waishuo.leanapp.cn/api/v1.0/groups/&lt;groupId&gt;请求方式：PUT说明：url请求参数中最后需要指定groupId请求参数：响应结果：获取项目分组列表https://waishuo.leanapp.cn/api/v1.0/groups/projects/请求方式：GET请求参数：说明：url请求参数中最后需要指定projectId响应结果：删除分组https://waishuo.leanapp.cn/api/v1.0/groups/&lt;groupId&gt;请求方式：DEL请求参数：说明：url请求参数中最后需要指定groupId响应结果：Project相关api创建项目https://waishuo.leanapp.cn/api/v1.0/project请求方式：POST请求参数：响应结果：编辑项目https://waishuo.leanapp.cn/api/v1.0/project请求方式：PUT请求参数：响应结果：删除项目https://waishuo.leanapp.cn/api/v1.0/projects/&lt;projectId&gt;注意：删除时，会把项目下的分组以及todo全部删除请求方式：DEL说明：url请求参数中最后需要指定projectId</li>
  <li>今天看书时突然想到了奶奶。到今年，奶奶已经过世四年多了，我记得很清楚，奶奶是14年六月初左右去世的，那时我在北京工作，当时我正换了第二份工作，在入职之前我回家参加了奶奶的葬礼。奶奶有五个儿子，我爹是最小的儿子，所以按照家乡的传统，奶奶一直跟我们住在一个院子里，我从小也便跟奶奶接触比较多。我对奶奶最早的记事可能是三年级。记得那是三年级开学的时间，我们要开始用钢笔了，第一天我就把钢笔丢了，所以去商店又买了一支，然后奶奶陪我去了学校，这便是对奶奶最初的记忆了。小时候，奶奶走路总是特别快，她身材偏瘦，精神很好，什么时候看上去都一副精神抖擞的样子，那时在屋后的山坡上总能看到她的身影。我对爷爷没有形象，因为我刚出生不久，爷爷就去世了，后来奶奶便一直一个人生活。奶奶跟我们住一个院子，我们的院子大体成L型，坐北朝南，不算大，但是能住的房子也有五件，奶奶住着向阳的两件屋子，我们在朝东的屋子住。奶奶虽然年纪大，但是自己住的房子却收拾的很用心。床单、被套、窗帘等都用喜欢用鲜艳的布料，柜子、桌子平时也擦的很干净，每天早晨，她会按时扫地，而且奶奶有个习惯，扫地前先洒水，柜子底下有个洒水壶，水壶里的水总是满满的。奶奶心很强。我记得一开始奶奶房间的地是纯土地，后来老家那边流行铺砖地，就是用红砖把地铺一遍，地会变得很平整，也容易扫地。那时很多人家都已经铺了砖地，奶奶也便寻思着铺，很想给自己的地也铺一层砖，后来自己买了砖，但却找不到人帮她铺地，当时奶奶好像憋着一股劲，一定要把地铺了。后来正好我跟我表哥在家闲着，所以奶奶找我们铺，那时我们还小，可能还在上小学或者初中，我们也不会铺，但是我们在奶奶的督促鼓励下便开始铺。后来铺了一大半，毕竟没有任何经验，地被我们铺得乱七八糟，一点都不好看，我爹看到后又重新把地铺了一遍，终于铺好了。尽管奶奶心很强，但是作为一个老人，同时对未来的生活却充满了担忧。奶奶总是担心自己填炕的燃料不够用，尽管我们家的后院有一个小房子已经盛满了填炕用的燃料（就是草末或者晒干的羊粪），但是奶奶总是在闲着没事的时间里去四处找草末，有时我们也会给奶奶说，先用着，没有了再找，但是她总是担心没有燃料了怎么办，所以总是想法设法去寻找更多的草末。也许只要找到那些草末或者羊粪，她的心里就会踏实。后来，直到奶奶去世的前一两年，奶奶出行不便了，我妈她们给奶奶填炕时才把那些积压下的草末给用了。那些最久的草末时间可能已经积压十多年了，有些早已经不能用来填炕了。其实不仅仅是草末，生活中的很多东西，奶奶总是担心不够，奶奶有很多被子，有很多碗筷，尽管这些东西平时用到的也就一点点，但是这种物品上的富余应该会给奶奶带来一种安全感，毕竟奶奶其实是一个缺少安全感的人。由于奶奶很长一段时间一个人，所以奶奶是孤独的。我记得小时候的时候，奶奶总是会找我们孙子去她的房间，晚上陪她睡觉，她会提前把褥子、被子铺开暖好，等我们去睡觉。小时候我跟奶奶并不是很亲。其实这在现在是很难理解的，说到奶奶孙子，大都很亲，不过我们家那边，小时候奶奶有太多孙子了，而且小时候奶奶很忙，所以我跟奶奶的那种感情并不是那么深厚。但是我大点的时候，我跟奶奶一直是住在一个院子里的，晚上陪奶奶比较方便，所以后来大部分时候都是我在晚上陪奶奶睡觉，有时我姐姐也会陪奶奶睡觉。一开始我不是很愿意陪奶奶睡觉，所以奶奶总会想办法让我去，比如奶奶会给我苹果吃。那时奶奶经常会把苹果放在已经铺开的被子底下，奶奶总会乐意去买苹果、罐头等吃的留着给我们奖励。后来我已经习惯了去陪奶奶，奶奶也不需要给我好吃的，不过偶尔的还是会有奖励。快要上初中的时候，奶奶开始发愁了，因为我要住校，所以晚上不能陪奶奶，那时她会经常性的念叨，说我要去上初中了，要上初中了..脸上都是愁容。也许就是小学陪奶奶晚上睡觉的那几年，奶奶开始对我变得很在乎。她很喜欢看到我，喜欢夸我，不仅仅是因为晚上陪她，因为平时我还可以帮她上房顶去安烟，可以帮她打水等等，生活中跟奶奶会有很多交集。上初中后，只有周六周日会在家里，每周五下午我会骑车回家。快到家的时候，经常会看到奶奶在山坡傍边的地里收拾草末，我看到奶奶后会主动打招呼，奶奶很开心。就这样，后来我要去县城上高中了，大概一学期才能回家一次，那时我记得奶奶更愁了，在我旁边不止一次的念叨我要去上高中了。初中的时候，每周末我还可以陪她睡觉，但是上高中了，就很难了，只有假期才可以陪她。不过当时，其实我自己内心并没有多想，我很单纯，我知道奶奶会难过但是我自己也没有去说什么宽心的话给奶奶听，后来就慢慢发现，奶奶真的越来越老了…到高中后跟奶奶接触少了，每年只有放假的时候才会回家看到她。每次坐班车回家到院子里了，看到奶奶在房间里，我还是会隔着窗子跟奶奶说我回来了。一般我回去后，先去妈妈哪里把东西搁下，然后再去奶奶的房间，跟奶奶当面打招呼。那时从奶奶的神情上看，感觉她的精神状态已经跟小时候完全不一样了…当然后来奶奶的手指做过一次手术，奶奶的精神状态跟病痛也有关系，不过假期里我还是陪奶奶睡觉。在和奶奶一起的时候，有时会问道一些以前的事，奶奶会聊一些以前的事，不过奶奶也不是那种特别能说话的人，现在让我想，还真的很难想起以前她都说过什么。后来我考上大学了，奶奶很开心，不过已经忘了当时奶奶有没有对我说过什么，只记得在我办升学宴时她整天乐呵乐呵，很开心。对奶奶来说，上大学跟上高中差不多，我都是每一学期才回一次家。我每次回家后还是跟高中一样，跟奶奶打招呼。不过大学时，奶奶的身体已经大不如以前，皮肤变黑了，有时吃饭都是问题。那时感觉跟奶奶交流不多，其实在这么长的相处时间中，跟奶奶也很难有触及内心深处的交流，一方面是我那时还小，另外奶奶本来也应该不是那种善于表达内心情感的人。到后来奶奶有点沉默寡言，平时走在路上看到她，她也如此。总之奶奶老了，不论身体、精神都受了很多磨难，整个人就再也不想小时候的样子了。当时我知道奶奶去世的消息挺难过的。因为奶奶是第一个离我这么近的人去世的，我在坐火车回家的路上回去回忆以前的事，就觉得太难过了。但是，终究，生老病死，自然规律…致我已逝去四年的奶奶…咕咚写于2018年8月</li>
  <li>自己开始了解姜文是从2011年开始。那年他拍了《让子弹飞》，我大二，电影特别火，在舍友的强烈推荐下自己在宿舍里看完了这部让我认识姜文的电影。看后特别爽，节奏紧凑，台词讲究，人物也非常有个性，电影营造的氛围也特别舒服，总之就是爽。其实在这部电影前，听说过姜文，不过一直以为他只是一个演员，看了《让子弹飞》后才知道原来他不仅是一流的演员，更是一个一流的导演。当时觉得很不可思议，简直天才，当然也有很多人说是鬼才。不过后来随着了解的深入，觉得称他天才未免有点太片面了。也许就是这样，如果你对一个人了解的少，或者对他之前的预期都比较低，而突然有一天你发现他完成了一件你看上去很了不得、很棒的事，你就会觉得这人好牛X。《让子弹飞》之后的几年我再没有看过他的电影，后来在网上开始了解了一些他的信息，说他脾气很差，但是非常有才华，比如在拍《让子弹飞》前邀请葛优跟周润发时，分别写了如下的邀请文字（有删减）葛优：壶口一别，竟有二七。春风秋月，杨柳依依。虽谋面不勤，却心存惦记。吾兄凡新作问世，愚弟必争先读之。兄之身手炉火纯青，每令愚弟嚎啕大悦。才惊四海，誉享中外。喜甚幸甚！周润发：香江匆唔，所谈甚欢。新片故事，随信奉上。脚本即将出炉，故事锤炼数载，人物之妙，惊古烁今……发哥盛名，中外有识；为艺厚道，技压群雄。此角色必助发哥携已获之辉煌，跨更高之巅峰……放眼中原，勃勃生机，星汉灿烂，交汇其里。闻听发嫂令下，发哥将至，上下同仁，无不振奋。看到这些文字，可见姜文文字功底一斑。后来接着拍了《一步之遥》，但是听说很难看懂，所以就没有第一时间去看，后来还是想尝试看看，然后去年看了后，最终发现真是云里雾里、稀里糊涂，台词、表演很疯狂，我却看的很懵逼。后来了解到他拍的电影又不少都是这个风格，不去迎合市场，拍电影就拍自己喜欢的，不知在哪看到的一段采访说，要说他拍过电影的艺术品位，《让子弹飞》是他拍过最差的一部。去年特意查了一下姜文的拍电影经历，才知道他拍的第一部电影是《阳光灿烂的日子》，拍摄于1993年，那年我才三岁，之前也听说过这部电影但是一直没看，于是便在今年一个周末在家看了。整个电影营造了一份浓浓的北京大院味道，同时夹杂着浓重的青春荷尔蒙味道，自己在看的时候，会不自觉的对比自己童年时的情形，发现他们童年玩的可真嗨…相比之下，我们的童年可太乖巧了。童年的很多乐趣或在山里，或者放学的路上，或在大树林里，童年大家都是大人口中的好孩子，我在想童年也许放肆点、叛逆点更好…看完那部电影不知不觉的迷恋上了北京的胡同大院，电影里的瓦片房、大烟囱、自行车等等一系列元素都特别有味道，这就是老北京的感觉。后来有一个一个周末，自己特地去了一趟内务部街，骑着车子，把那边的胡同走了一个遍。电影有很多场景是在离内务部街不远的段祺瑞政府旧址拍的，包括米兰的宿舍还有大瓦房，我特别想去里面看看，但是过去的时候，门卫是不允许进去的，而且问了门卫，段祺瑞政府旧址是不开放的，任何时候都进不去的，我只能站在大门看看内部大概的样子。其实来北京这么久了，那次是第一次溜胡同，但是跟电影中对比下，现在的胡同已经没有之前的味道。不过还是有不少的东西保留下来了。比如那些老槐树、柳树，我喜欢胡同里这些没完没了的树，骑车在郁郁葱葱的树荫下，仿佛走在电影里…后来看了许知远对姜文的一个访谈节目《十三邀》，第十三期：许知远对话姜文。节目中，许知远亲自去了趟姜文小时候住过玩过的地方-内务部街11号，其中当年电影中的大烟囱依旧在,十三邀中姜文聊了一些自己对自己的认知。通过姜文的自述，你能感受到姜文是一个特别真实的人，棱角分明，有很强的原则，尽管已经50多岁，但是从语言、表情中能感受他强大的内在力量，他不妥协，同时还特别认真。我很喜欢他，他有很多优秀的点，最喜欢他的真实。咱们的生活中会遇到很多人，但是能做到真实的人太少了。相比而言，小孩还有那些七八十岁、耄耋之年的老年人可能大部分是真实的，因为他们无所顾忌。而我们生活在这样的大环境里，大家都在尽力的通过各种方式在隐藏自己，或者尽管有些人在不同的社交平台上不断的晒着自己的照片、生活点滴，但是你要分辨的清，他只是把他想展示的展示给你看了，你看到的依旧不是真实的他。他的虚伪、怯懦、失败等等一系列东西你根本无从察觉，或者很难察觉。说到这里，其实自己也是所有不真实的人中的其中之一。那让我说说我理解的真实吧：首先，真实的人应该是一个勇敢的人。敢于做决定，敢于拒绝，敢于表达、坚持自己的想法，敢于付诸行动。说道容易做到难，很多人做不到，很多人在面临选择的时候总是犹豫、退缩，畏手畏脚。其次，真实的人大都非常了解自己。人生其实就是一个不断发现自己的过程，有很多人并不了解自己，这跟自己的成长环境有关，经历的越多对自己的认识也就越多，反之如果一个人从小到大都在一个象牙塔里长大，那么他对自己的了解，对这个世界的了解都少之又少。只有更好的了解自己，才知道自己想要什么，厌恶什么，需要去拒绝什么。其实以前没有怎么去特别关注过一个人，今年便不自主的开始关注姜文。但是确实是，关注他们的同时，真的可以给自己很多启发，也可能自己真是缺乏一些这样的东西，才会让自己更加去关注他。姜文-一个真实的人。</li>
  <li>Passbook是自己开发的一个用于存储账号密码的App.开发缘由APP是今年初开始开发的，当时主要是为了学习Kotlin。众所周知，kotlin已经是Google为Android指定的官方语言了，所以自己便开始学习Kotlin，学习语言有很多方式，我选择了自己比较喜欢的这种方式-做项目，通过项目实践来加深巩固对kotlin的理解。开发的过程中，自己主要参考了官方的中文文档，另外还有很多知识细节则是通过百度谷歌获取到的。在开发的过程中自己也在不断积累相关的技术点，期间还整理成了一篇文章-应用开发过程中的一些Kotlin语法点记录-咕咚的个人站点为什么选择密码存储作为应用切入点主要有以下两个原因吧。1、自己在日常生活中有密码存储的刚需。在工作生活中，自己经常需要去记录密码数据，自己曾经在印象笔记、便签等诸多地方记录过，但是体验均不佳，使用繁琐还不安全，所以自己想结合手机的指纹识别，来开发一个安全易用的密码存储app，同时还可以学习了解新技术，何乐而不为。2、自己曾经开发过一个类似的应用自己在2013年开发过一个类似的密码应用，那是我的第一个独立APP，但是当时遇到了诸多问题，最终无奈只得下架。当时的主要问题是加密安全以及用户忘记登录密码的问题，都得不到很好的解决，所以最后给自己徒添很多烦恼。这次，重新用kotlin开发，界面采用了MD的设计，变得很好看，交互也有很多提升，同时使用了指纹识别认证，也让使用体验变得更好。但是最终我还是没有把应用完整的开放出来，毕竟是一个离线应用，而且要存储密码，安全性很难做到可靠，所以自己会先使用。收获1、技术方面的收获基本掌握了kotlin的基本语法，还体验了android的数据库框架Room,但是其他的Android架构组件还没有应用，其实我想在这个应用中更多的尝鲜一下Android新提供的组件，如LiveData、LifeCycle等。2、产品方面的收获自己开发设计的同时也思考了不少产品方面的东西，很有意思，可以单独写一篇文章讲解自己在产品设计方面的取舍了。体验地址Passbook体验版-fir.im未来可能会运营一些付费版的Passbook，让自己的付出价值化，同时优化数据备份还原，争取更加稳定可靠。思考App开发越来越规范化，这一点从谷歌就可以看得出，这是一个技术市场在变得成熟的标志，在开发这个APP之初还没有Flutter，到现在圈里已经谈了很久的flutter，技术发展很快，跨平台是趋势，作为技术人我们和核心能力是什么？值得思考。</li>
  <li>凡事预则立，不预则废。记得有一句话这样讲，“你怎么过每一天，就怎么过每一年，甚至过完这一生。”，且不深究具体逻辑，但是怎么更好的渡过每一天，确实对我们的生活有很大影响，本来一生就是由无数天组成的，一个再小的习惯，经过日积月累，量变引起质变，也会对一个人产生巨大的影响。所以如果有一个健康的习惯，加上日积月累真的可以做到影响一生。下面是一个关于习惯的故事。习惯的开始我记得是在大学的时候，不知从哪看到了一则关于如何提高学习、做事效率的建议，那条建议说，每天晚上睡觉前把第二天要做的事列出来，然后第二天按照清单去一个个完成，这样就可以让第二天的做事、学习变得更有效率。自己当时照做了，然后每晚睡前就去思考明天要做的事，并把他们记在一个小本子上，比如晨跑，做练习题，看书，打球，洗衣服等等这些事，我都会记下，然后第二天执行。那结果呢？自己在坚持了几天后，就发现很有效果。因为每天要做的事提前一天就计划好了，所以第二天对当天要做的事非常清楚，从不会让自己每天都过得浑浑噩噩。所谓“凡事预则立不预则废”，也许就是这个道理。我记得在没有这样做之前，每一天很容易过得特别随意，因为没有规划，所以每天除了正常的学习外，其他时间干什么都可以，做完做不完也没关系，因为所做的很多事没有预期目标，没有一个约束边界。但是现在提前计划好之后，就完全不一样了。自己每天会想着优先去完成那些自己计划好的事，这样每天就会过得更有目标更有方向感。同时在完成了计划的事情之后，内心也会发自内心的愉悦。其实有些事即使自己不计划，自己也可能会去完成，但是当你计划了，然后自己再完成，虽然结果一样，但是内心的感觉完全不一样，会觉得自己做到了一件自己预期的事，时间久了，自己对自己的执行力越来越有自信。尽管这是一种非常好的习惯，可我还是没能很好的坚持下来，坚持了一段时候后，我还是回到了以前的节奏中。不过从那时起，我开始思考怎么让学习生活变得更有条理和有效率。寻找工具软件后来工作后，自己开始做移动开发，也就接触到了大量的应用软件，然后自己试图去寻找一些应用软件去帮助自己做日程规划或者待办事项，因为手机时刻待在身边，还有提醒系统，所以我觉得这是一种不错的方式。我来我尝试了各种不同的清单软件，从一开始用GoogleKeep，后来用奇妙清单，再后来使用Trello，他们各有不同，个人最喜欢Trello，喜欢那种看板式界面，如下是自己的一个看板之一我很喜欢Trello,但是自己完成一个任务后喜欢去把任务进行勾选标记，而Trello只能去归档，这一直让自己很迷惑，所以自己可能需要一个清单+看板功能的应用，我还是喜欢那种勾掉已完成事项的感觉。定制新应用所以，我开发了一个适合自己使用习惯的清单+看板网页应用，名字暂定为柳叶清单。目前功能比较基础，但是主要的功能都有了，包括任务添加、任务分组，任务拖拽排序、添加子任务等，另外还有一个比较有特色的功能，就是每晚邮件提醒当天的任务完成情况。这是应用的网址http://gudong.site/list/，点击即可访问，目前没有适配手机小屏幕，所以更适合在电脑上查看使用，欢迎使用。如果使用过程有任何问题建议，欢迎留言，也可以去这里进行吐槽。关于我是咕咚微博-大侠咕咚知乎-咕咚Github-咕咚</li>
  <li>前段时间加入了一个百日打卡计划社群，每个人加入都是为了在100天内连续做一件事，每天完成后需要拍照在对应的小程序中打卡，如果哪天不打卡就会有惩罚。我加入后给自己列了一个锻炼身体的计划，今天打卡时看到已经连续打卡36天。第一感觉是自己已经打卡很久了，现在怎么才打了36天。随着现在的生活越来越快，每一年都觉得过得特别快，但是每一年的时间都是365天，如果用来完成百日计划，足够完成3个这样的大计划。当用这样的方式去度量时间时，就会发现时间竟然慢下来了，这真是奇妙的一件事。仔细想想，这种感觉应该可以这么理解，最关键的点在于打卡这个过程以及100多人构成的社群环境。现在每天锻炼完身体，都会去拍照，然后打开微信小程序打卡，这个过程有一种仪式感，仪式感带来的就是内心对这个事情的强化。相反，如果每天只运动，不打卡不记录，没有那个社群环境，自己的内心同样对这件事会有印象，但是感知就不会这么深刻，影响深刻后产生的结果就是时间慢下来了。有时候并不是说时间过得快，而是缺乏一个东西去度量而已。</li>
  <li>最近在开发一个小应用密码本，开发的目的是自己确实有存储密码的需要，同时还有更重要的目的便是学习使用Kotlin。最近已经把基本的功能都开发完成了，包括指纹验证登录、手势登录以及最重要的密码条目存储，本地数据库使用Room。下面是使用Kotlin过程中的一些积累点滴，如果有什么错误的地方，欢迎指正。另外，如果你对这个密码本感兴趣，不论是对开发感兴趣，还是对这个产品感兴趣，均可以通过最下方的联系方式联系到我。通过Kotlin为View设置回调事件在Java中通过如下方式设置btnView.setOnClickListener(newView.OnClickListener(){@OverridepublicvoidonClick(Viewv){//todo}});在Kotlin中可以直接通过lambda表达式，如下所示btnView.setOnClickListener({//todo})也可以省略括号直接使用如下简写方式btnView.setOnClickListener{//todo}如果在回调中需要使用view参数，可以通过如下方式btnView.setOnClickListener{view-&gt;view.visibility=View.VISIBLE}Kotlin接口中有多个接口方法需要实现如下有一个接口publicinterfaceOnTaskSwitchListener{voidonTaskSwitchToForeground(ActivitytopActivity);voidonTaskSwitchToBackground(ActivitytopActivity);}对应有一个set方法publicvoidsetOnTaskSwitchListener(OnTaskSwitchListenerlistener){mOnTaskSwitchListener=listener;}在kotlin中如何使用set方法，如下所示taskSwitch?.setOnTaskSwitchListener(object:BaseTaskSwitch.OnTaskSwitchListener{overridefunonTaskSwitchToBackground(activity:Activity){Log.d("88888","到后台")}overridefunonTaskSwitchToForeground(activity:Activity){Log.e("88888","到前台")}})refertohttp://blog.csdn.net/afanyusong/article/details/77866953Kotlin使用Intent跳转valeditorIntent=Intent(this,EditorActivity::class.java)editorIntent.putExtra("pass",entity)startActivity(editorIntent)如果是在内部类中，不能直接拿到this,使用下面的方式valeditorIntent=Intent(this@MainActivity,EditorActivity::class.java)editorIntent.putExtra("pass",entity)this@MainActivity!!.startActivity(editorIntent)Kotlin中使用AlertDialog使用Java生成一个AlertDialognewAlertDialog.Builder(this).setTitle("提示").setMessage("你好，世界").setPositiveButton("确定",newDialogInterface.OnClickListener(){@OverridepublicvoidonClick(DialogInterfacedialog,intwhich){}}).show();Kotlin中如下所示valmsg="你好世界"AlertDialog.Builder(holder.itemView.context).setMessage(msg).setTitle(item.name).setPositiveButton("复制",DialogInterface.OnClickListener{dialogInterface,i-&gt;copyText(holder.itemView.context,item.value)Toast.makeText(holder.itemView.context,"复制成功",Toast.LENGTH_SHORT).show()}).setNeutralButton("取消",null).create().show()另外，在给PositiveButton设置点击回调时，使用了lambda表达式，这里的dialogInterface和i两个参数均没有使用，在AndroidStudio3.0中会提示可以用_代替，修改后如下所示：valmsg="你好世界"AlertDialog.Builder(holder.itemView.context).setMessage(msg).setTitle(item.name).setPositiveButton("复制",DialogInterface.OnClickListener{_,_-&gt;copyText(holder.itemView.context,item.value)Toast.makeText(holder.itemView.context,"复制成功",Toast.LENGTH_SHORT).show()}).setNeutralButton("取消",null).create().show()当然，如果要使用，就不要这么简写了。Kotlin中使用AlertListDialog如下所示的dialog经常看到实现如下所示：vallist=Array(1,{"打开应用","卸载应用","查看详情","去市场查看"})android.support.v7.app.AlertDialog.Builder(this).setItems(list,DialogInterface.OnClickListener{_,i-&gt;when(i){0-&gt;{Log.d(TAG,"open");}1-&gt;{Log.d(TAG,"uninstall");}2-&gt;{Log.d(TAG,"detail");}3-&gt;{Log.d(TAG,"watch");}}}).create().show()Kotlin中强转类型Java中的类型强转如下所示Entityentity=(Entity)getIntent().getSerializableExtra("entity");在Kotlin中可以用更优雅的形式manager=this.getSystemService(Context.FINGERPRINT_SERVICE)asFingerprintManagerkey=keyStore.getKey(KEY_STORE_ALIAS,null)asSecretKeyKotlin设置静态变量提供给其他类使用Java中这样publicstaticfinalintbuttonGravity=120;classTest{companionobject{valbuttonGravity=120}}使用varvalue=Test.buttonGravity关于作者邮箱-gudong.site@gmail.com微博-大侠咕咚知乎-咕咚Github-咕咚</li>
  <li>开发Intellij插件时，比如自己最近开发的一个AndroidStudio插件，需要存储一些状态值，方便做一些UI上的偏好设置。比如这次选中了一个选项，希望下次打开插件时继续选中相应的选项，此时就需要做一些本地状态存储。就像AndroidAPP常见的设置选项。Intellij也提供了响应的API-PropertiesComponent，使用方式如下所示：存数据到本地PropertiesComponent.getInstance().setValue("key","valuw");获取数据Stringvalue=PropertiesComponent.getInstance().getValue("key");Sourcefrmo咕咚的个人站点参考链接PersistingStateofComponents</li>
  <li>GreatArticles收集最好的技术文章具体原则：1、只收集高质量有深度带有自己思考性的技术文章。2、经典有深度的系列在线文章。3、issue中收集编辑自己整理一些文章片段。文章地址: https://github.com/maoruibin/GreatArticles个人主页: http://gudong.site系列文章Android性能优化作者：胡凯时间：2010-03-16来源：个人博客性能优化的方方面面，在这里大概都讲到了。安卓自定义View教程作者：GcsSloop时间：2016-01-05来源：个人博客详细的自定义View教程，从0到1，带你了解自定义View的方方面面。安卓架构组件(ArchitectureComponents)系列文章翻译作者：Chuckiefan时间：2017-06-07来源：简书把国外一个讲解ArchitectureComponents系列的文章进行了翻译，其中涉及了LiveData、Room等新知识点的详细介绍，翻译的不错Java并发性和多线程指南作者：张坤等时间：2013-10-07并发编程网原文：http://tutorials.jenkov.com/java-concurrency/index.htmlJava并发编程指南的一个翻译版本系列，很完整的一个系列JavaJava并发编程：volatile关键字解析作者：海子时间：2014-08-22来源：ImportNew作者围绕volatile关键字把Java内存模型以及Java运算中的原子性，可见性，有序性有非常深入的分析了一下，读完文章会让你对主内存、工作内存从硬件和软件层面都会有一个非常好的认识。—-Java8系列之重新认识HashMap作者：李前时间：2016-06-24来源：公众号见过对HashMap分析最透彻的一篇文章了，HashMap作为面试高频考点，读这篇文章没错！LinkedHashMap的实现原理作者：李大辉时间：2016来源：极客学院LinkedHashMap讲的非常有条理，通俗易懂的好文章。—-轻松搞定面试中的链表题目作者：WalkingInTheWind时间：2012-04-21来源：CSDN文中对常见的链表面试问题都有相应的解答，代码是用C实现的，但重在思路。—-Java多线程同步机制(synchronized)作者：openpk时间：2010-03-16来源：CSDN比较久的一篇文章了，但是对Synchronize关键字的解释非常到位，用上厕所的比喻来解释线程同步的概念，例子非常鲜活，好文章。—-如何正确地写出单例模式作者：Jark时间：2014-08-28来源：个人博客对单例模式的异同点，为什么这样写都有很好的描述和解答，非常不错的文章。—-AndroidDagger2入门,以初学者角度作者：zFxiang_时间：2016-10-29来源：简书 深入浅出Dagger2，讲的非常棒！Dagger2的诸多点都讲到了，而且关联的特别好！Android应用开发之所有动画使用详解作者：工匠若水时间：2015-08-09来源：CSDN 对Android动画的使用做了详尽的介绍，文中没有关于动画的原理做介绍，但是对于整个Android动画的几种使用方式概括的非常全面，包括一些很小众的动画技巧也有提到，不过动画还是要靠不断的练习才能更上一层楼。全面了解AndroidNotification作者：ConnorLin时间：2016-04-21来源：简书 条理清晰，对notification的使用做了方方面面的讲解，一篇好教程。安卓自定义View进阶-MotionEvent详解作者：GcsSloop时间：2016-11-02来源：个人博客对ACTION_CANCEL和ACTION_OUTSIDE的讲解尤其精辟—-ContentProvider从入门到精通作者：澳特慢时间：2016-05-02来源：简书对ContentProvider的作用以及在Android中的地位描述很恰当，另外在使用说明也比较详细。个人平时使用ContentProvider还是做跨进程数据同步多一点，因为SharePreference在跨进程情景下不可靠，所以包装ContentProvider后会特别合适，具体的实现可以参看tray。—-深入理解Android之View的绘制流程作者：absfree时间：2016-11-07来源：简书WindowPhoneWindow概念描述的很清楚。—-Android内存优化杂谈作者：shwenzhang时间：2016-12-15来源：公众号尽管是15年的文章了，但是涵盖的内容还是非常全面的，尤其是微信对待问题的态度，还有处理内存问题的方式都很值得学习。从文章中可以学到他们他们对问题追踪的一些实践经验。—-Android进程保活招式大全作者：张兴华时间：2016-08-11来源：公众号如文章名字一样，一点都不标题档，文章很有条理。从进程优先级说起，然后讲了各种保活方式，更难能可贵的是对不同保活方式在不同Android版本上的表现也做了说明。—-我打赌你一定没搞明白的Activity启动模式作者：尹star时间：2016-05-31来源：简书讲的很透彻，读完后你会对Activity的启动模式，任务栈有更深的了解。—-Android事件分发机制详解：史上最全面、最易懂作者：Carson_Ho时间：2016-01-06来源：简书图文并茂，非常有条理，了解事件分发，只此一篇文章即可，不用多找。另外作者的一些其他文章貌似也不错。—-Handler异步通信机制全面解析作者：Carson_Ho时间：2016-04-30来源：简书Handler的方方面面都说到了，描述很精准，深度好文。  —-Fragment完全解析三步曲作者：YoKey时间：2016-02-27来源：简书对Fragment中的各种bug做了解释,并提供了解决方案，良心作者。—-前端Flex布局教程：语法篇 作者：阮一峰时间：2015-07-10来源：个人博客 自己接触前端页面挺早，但是对前端的布局不感冒，跟客户端布局相比，总觉得前端布局比较麻烦，各种CSS属性，直到遇到了Flex布局，之前就看过阮老师的这篇文章，通俗易懂，非常不错。About咕咚，爱折腾、爱新鲜，爱篮球。你可以通过下面的方式联系到我，欢迎关注。个人博客主页Github主页微博主页公众号-大侠咕咚</li>
  <li>最近一直整理这一年散落在各处的文章、笔记，毕竟一年了，也是该整理整理了，平时我会在印象笔记、简书、Github、掘金、知乎专栏等不同的地方记录一些技术或者个人感悟，也会在Trello、Wunderlist中记录一些一闪而过的点子。到今天终于也整理完了，最终我把技术性的文章都放在掘金，然后逐渐再同步到个人博客。在整理的过程中，总有一种放电影的感觉。一年的时间那么长却也那么短，从头到尾可以做那么多事，但是真真能做好的也就那么几件事，不过一年中还是有很多可以说的东西。生活需要仪式感之前在墨迹天气时遇到的黑羊老师就曾对我们说，生活需要仪式感，我想也是，一年快过完了，如果要给这一年举行一个仪式，现实生活中可以来一串鞭炮，那这里写一篇年终总结也许是最好的方式了，再说15、16年已经连续两年写了年终总结，今年也没有理由让它断掉。关于年终总结，15年写年终总结时是响应当时的社区号召，自己写了很多字，16年就有点拖沓了，基本没写什么。17年我想写的不一样一点，让年终总结有意思些，所以我想采用自问自答的形式，好组织也更加容易表达。2017年这一年最高兴一次出行经历是什么？这无疑要数今年11月跟同事一起去的黄山游了。黄山是从小学就知道的一个地方，那时从小学课本上就知道它有猴子观海、迎客松等诸多景点，但是自己一直没机会去，甚至，直到今年我才算第一次去南方。这次的安徽行先是去了老街，然后第二天去了黄山，最后去了黄村，整个过程让我影响非常深刻，我喜欢徽州的建筑风，喜欢那边的水，安静透彻；喜欢黄山，高大险峻，美不胜收；喜欢黄村，喜欢在古镇里来回穿梭的感觉，喜欢竹林，当我一个人在竹林里奔跑，就仿佛感觉自己在电影里，一种美梦成真的感觉。这一年对你影响最大的事是什么？换了一份新的工作。我在17年初做了一个大概的年度规划，其中就有一项是换工作。简短回顾一下墨迹的工作，在短短一年的工作时间里收获不少，从一开始加入墨迹便开始做项目重构，项目重构的过程很适合锻炼技术能力，因为有很多模块可以彻底的重写，这样就可以从大的角度的重新设计，锻炼自己的设计能力同时也可以引入一些新技术，增加技能点。除了技术上的收获，有时对你更有价值的也许是那些与你共事的人。有幸在墨迹认识了不少优秀的同事，虽然现在已经离开半年多了，但是对他们印象深刻，很感激。（更多关于之前同事的评价，之前曾写过一篇文章有简述-17下半年的这段时间）换工作之前自己先是准备了一段时间的基础知识包括算法、Java、Android基础以及一些高级的内容，后来在5月份开始找工作，找了一个多月，最终6月末入职新浪微博。关于微博这个产品，自己从13年开始注册后，一直使用到现在，算是微博的忠实用户，不过在找工作之前，我怎么也没想到自己最终会去微博，一是一直没怎么看到过微博的招聘信息，二是微博移动端技术人员在圈里相对很安静，所以自己对微博Android团队了解很少。在自己面试的哪天，自己状态并不好，笔试题答得一般，但是最终被录用也是一个有意思的过程，到现在我从心底还是特别感谢溪总。在新的环境下，很多东西跟之前的都不一样，不论开发模式还是工作流程，但是经过一段时间的熟悉，自己很快便找到了节奏。在微博做Android客户端开发是一种什么样的体验？客户端模块很多，自己所在组负责的是那个最容易出问题的模块—首页信息流。都知道微博是国内移动平台上的顶级流量入口，而信息流则是微博的门面，所以大家都知道这里绝不能出问题，所以除了自己在意识上提高觉悟，团队会有非常严格的Review（包括DesignReview以及CodeReview），以及发版后的Checklist，以及最重要的灰度开关策略。在微博工作中技术成长如何？关于技术成长，我一直认为师傅领进门，修行靠个人，所以工作中更多的成长来自于自己对自己的要求，同样一个问题，你可以用不同的方式完成，但是你对你使用的方案以及背后的原理以及潜在的风险有多清楚，完全取决于个人，你可以在做一个需求或者解一个bug时多花点时间把技术点分析透彻，一点点积累，这种积累随着时间的积累会在以后发挥出越来越大的作用。你说了师傅领进门，修行靠个人，你有师傅吗？有，我很感激当初在创新工场时的AndroidLeader，当然我也很喜欢我现在的组长，大家一起时更像是朋友，一起玩游戏一起打球，很喜欢这种环境。在本职工作之外，有没有学习过什么新技能熟悉我的人应该知道，我的本职工作是Android开发，到目前为止，已经五年了。对于Android开发，到目前为止大家都能感觉到，整个开发生态已经非常成熟。不论是看谷歌的动态还是国内市场，现在各种开发框架以及开发思想都已经成型，现在开发一个具有高水准的移动APP已不是什么难事，这是一种技术市场成熟的表现，随之而来的就是市场对技术人员要求的变高。现在能明显感觉到市场上对Android开发人员的技术要求在变高，企业都倾向于招聘高级开发。作为技术人员，很多人应该感同身受，所以适当点亮一些新技能，扩展一下自己的视角也许是一种比较长远的计划。所以17年我还是选择尝试性的接触了一些新东西。比如Sketch以及Pathon。学习Sketch是因为经常需要做一些平面图或者图标。以前刚做Android开发时就跟着做设计的同事学过PS，对于一些基本操作已经可以驾轻就熟，但是PS博大精深，后来在使用的过程中还是应用较少。直到后来接触了Sketch，发现它非常易用，提供的功能以及使用方式刚刚好，很适合自己，而且日常开发中，设计师提供的切图也都是通过Sketch完成，所以今年8、9月份便花了点时间去学习。通过学习Sketch可以或多或少的了解平时与你合作的设计师是如何工作的，这对平时开发工作中的交流会有很大的作用。举一反三，有时你想要跟你圈子外面的世界交流，也许学习他们的交流语言是一种很好的途径。后来，继续学习了Python，Python去年就看着教程写过一些Demo，这次买了一些教程，打算仔细的学一学，期间花了一个多月的时间，把Python的基础知识都学习了一篇，并做了几个小项目。对于Python，自己的期望就是可以掌握它的基本语法，可以看懂一些Python代码，所以一些Python库自己并没有花很多精力去学，总之够用即可。这一年你有坚持过做一件事吗，坚持了多久？坚持锻炼身体。去黄山玩得时候，玩得比较嗨，然后就在朋友圈发了自己的照片，后来看到照片后，大家对美景产生的注意力并没有我想想得多，反而对我的小肚腩更在意，呃呃~~这让我意识到也许自己确实有点发福了，今年的体重已经来到了我最重的时候-170斤，尽管我有183的身高，但是我的潜意识里自己一直都是160的完美体重，所以我坚持每天做俯卧撑以及仰卧起坐，并用Loop这个APP进行记录。关于Loop可以看看下面的介绍，这是一个很不错的开源应用。Loop:好用又永久免费的习惯养成app，让你无法放弃打卡#Android|爱范儿App很好用，目前我已经成功养成了两个Loop。你平时看书吗？今年在年初做计划时就把看书作为了自己的计划之一，目前看来执行的并不怎么好，但是相比去年今年看的算是已经比去年多了。下面是自己今年看到的一些书看过什么印象比较深刻的书？有两本不错，一本叫简约至上，这是一本讲设计的书，书中大多时候用如何设计一个遥控器为例进行讲解，如何对产品功能交互进行有效控制，从而让产品变得好用，其中提到了专家用户这个概念，让我影响深刻。另一本叫《最重要的事只有一件》，我很认同这个观点，书中用很多例子进行论证，关于这本书我觉得完全可以写一本读后感，很好的一本书，类似的观点我在知乎中也看到过一个类似的答案，讲的非常不错，你有什么道理后悔没有早点知道？-风墟的回答-知乎今年影响最深刻的一段时间是那段时间？应该算是5月中旬到6月末的那一个月的时间。那段时间找工作，平时主要就两件事，为找工作做准备以及投简历面试在准备找工作的过程中，一方面要复习巩固一些JavaAndroid基础，并整理成文章输出（那段时间也是今年写文章写得最多的一段时间），另一方面需要把之前的工作做一此回顾，每天会看一下之前工作过程中写的代码以及一些自己负责过的模块，重新思考回顾。相比准备的过程，面试过程更有意思点。每天会跟不同公司的技术人面谈，一起聊技术。很多时候聊得都比较愉快，但是同时也会不断地发现自己存在的一些问题，比如技术深度的问题，在知乎面试完后我有很明显的感觉，自己也确实意识到了这个问题，但是又不是一时半刻能解决的，只能在以后的工作学习中不断去提升，还有一些是技术细节问题，终归总结为对技术的态度问题。都说面试是一个很好的学习过程，确实如此。另外每天会去不同的公司面试，挺奔波的，很多时间可能在地铁、等人中度过，不过忙忙碌碌的感觉还挺充实的。这一年有没有什么比较险的经历？后知后觉，要算的话，今年在求职的过程中差点去了小蓝单车，这应该算是一次吧，原因大家都知道。后来想想自己还是挺幸运的。不过也让我更加明白了互联网的残酷。一个行业的洗盘速度之快让人咋舌，当时还风生水起，转眼之间已经灰飞烟灭。在开源方面做过什么？相比往年，今年并没有很多精力去维护一些开源的东西。咕咚翻译从16年3月发布后连续迭代了几个版本后后来进入了长期的缓慢迭代过程，还在墨迹天气的时候曾抽出时间加过一些小功能，但是到17年，我几乎没有怎么去完善，没有那么多时间和精力，但是一直有用户断断续续的打赏，真的很感谢他们，期间也有部分开源爱好者很热情的为咕咚翻译增加了一些特性，很有意思。今年在找工作之前也开源过一个比较有意思的东西，OneDrawable-仅使用一张资源图片为View设置具有按下效果的背景，关于OneDrawable更多说明可以查看文档，这是当时在墨迹工作时自己开发的一个辅助组件，在内部使用没问题后，后来便开源了出来。直到后来入职微博，继续开源了几个小组件，FlowerLoading:Android中转菊花效果实现方案.以及ActionButton:给TextView设置lefticon可任意定制，这两个都是平时工作过程中抽取出来的小组件，都比较小巧，第一个转菊花View目前已经在微博中使用，目前微博中大部分转菊花View都是FlowerLoading的实现方案，第二个是自己纯粹开发玩的，当时看到项目中的Button设计特别臃肿，所以自己就试着设计了相对比较轻量的View。开源有很多好处。你可以接触到不同公司的开发者，让大家一起贡献智慧到仓库中，也是交朋友、互相学习的一种好方式。如果有时间，我还是希望18年可以有更多这样的输出。17年开发过什么好玩的APP没？从接触编程开始，自己就是那种非常喜欢动手的开发者，我喜欢完美解决一个需求的感觉，喜欢参与一个东西从无到有过程。平时如果有什么好点子，我会尽快把他记录在自己的点子库里，今年要说做完整的东西有两个。易剪：这是一个手机上收集文章片段的工具，一般人好像不怎么使用。当时找工作期间，每天都会在手机上花很多时间去阅读一些文字，看到一些好的片段就像把它摘录下来，当时试着用了各种便签都不方便，所以自己就想自己做一个好用的，我想到了Android6.0中支持自定义文本Action，所以就用这个新特性做了这个APP，效果如下所示：Thisisme，这个APP目前只有自己在用，它主要是用来统计我每天解锁手机的次数，以及每天我的手机轨迹。原型是从一个demo演变而来的，一开始要做Android上的截屏拦截功能，后来便扩展了一个截屏定位的功能，后来又加了摇一摇定位手机的功能，但是后来发现摇一摇定位太频繁了，所以自己加了解锁手机定位，这样一天结束后，你就知道自己这一天大概都去了那些地方。接着又想统计一下我一天手机的解锁次数，所以又加了解锁次数统计功能。如下所示17年烦恼的事？房子。17年对你影响最重要的事？换工作。自己的换工作直接决定了后来搬家。之前在通州那边住，其实在北京的东面我已经住了三年多了，已经有点习惯那边了，不过去年住的小区一般，房子采光也不怎么好，所以搬家相对来说是一个比较轻松愉快的决定。通州照片一二如下后来因为距离原因媳妇也换了一份工作，同时换工作后生活成本也相对降低，再也不用像去年一样，早早挤公交，上班非常匆忙，所以换工作后相对更舒心，况且后来找到的房子各方面条件都比较满意，整体说来这一切都比较满意。重要的日期？06.22自己对自己想说的话做好当下事，保持专注，制定一些长期短期的计划，并严格执行，同时应该保持宽的视线，不能把大部分精力花在一些事情上，工作不是全部，代码也不是全部，生活中有很多其他的东西值得自己认真对待，你怎么对待它，它也会怎么对待你，对生活保持热爱，认真对待生活。</li>
  <li>在知乎看到了上面的问题-有谁是单纯地喜欢编程吗？自己结合自己的情况写了一个答案，现在简单整理到这里。知乎回答地址：https://www.zhihu.com/question/264288696/answer/284162359博客文章地址：http://gudong.site/2017/12/27/why-programe-zhihu.html小时候我是一个特别喜欢动手的人。我来自农村，在我童年生活里，几乎没有买过玩具（主要是穷吧），如果算的话，过年时用压岁钱买的手枪算是为数不多的玩具，但我本身是一个非常爱玩的人。我喜欢凿子，因为用它可以把木头做成各种形状还可以挖窑洞，所以自己就去捡，记得有一次找到一个厚度差不多的铁片后，自己就去磨，后来把这个凿子磨得特别好使，很锋利，几乎每天都带在身边，直到后来丢了，再到后来却再也做不出那么好的凿子了。小时候，还特别喜欢打兔子。冬天的时候我喜欢去田埂、地沟里，草窝里找兔子。冬天的兔子在白天会在这些地方睡觉，找到后就想把兔子打下，但是没有合适的工具。后来我想可以用弓箭，然后开始自制弓箭，就去找了竹子做弓，不知从哪看到的，说是把烧开的油沥在竹子上可以让弓有更好的柔韧性，所以自己趁着家人不在，偷偷把家里的食用油烧开，然后跑到后院去给竹子浇油。有了弓，还需要箭。为了让箭射出去保持准确的方向，我开始仿照电视上的箭给箭尾部找羽毛，后来找了鸽子、鸡、老鹰的羽毛，后来还是选择了鸽子的羽毛。同时为了让箭更有杀伤力，自己又找了家里用的铁叉，把叉头锯下来磨锋利，让后套在箭头。弓箭好了，自己便去找兔子，每次兴高采烈的去找，大多数时候都找不到，或者还没找到兔子，兔子已经被我脚步声音吓跑了，很少能找到睡觉的兔子。终于有一次在附件的小树林子里发现了一个睡觉的兔子，我试着调整各种射击的角度，最终箭还是射在了兔子旁边的毛刺上。后来上初中时还在自家制氧气，自己用青霉素瓶在水里收集氧气，会收集好几瓶，收集好后会把老家的叔叔叫过来，给他们演示带火星的火柴复燃实验，等等..总之小时候只要觉得好玩的东西，自己都喜欢去试试，特别喜欢从头到尾做出一个东西的感觉。后来高中填报志愿，还是09年，那时计算机专业远没有现在这么火，当时我报的第一志愿并不是计算机，而是机械相关专业，当时没取上，到时滑到了当时比较冷门的计算机专业。说到计算机，我高中几乎没有接触过，当时室友经常去网吧通宵，我第一次进网吧还是高三填报志愿时才去的。最终我还是去了大学开始学习计算机专业，大一开始编程，一开始学C语言，但是整个一学期结束了，自己对编程还是没概念，觉得非常晦涩，当时学习数据结构、操作系统、计算机原理，一脸懵逼。直到大二，情况还是没什么好转，后来我开始思考，既然自己是被选择的，况且也没有更适合自己的专业，转专业也是不是什么好选择，为什么不好好学习一下计算机编程呢，我觉得自己需要主动去了解它，而不是一直被动的等待自己对它感兴趣。后来无意在同学那里了解到一门网络教程，教程名现在依旧记得很清楚-《C语言也能干大事》（杨中科老师出品），当时隔壁宿舍同学正在学这个，我看到这个教程中可以实现一个可视化对话框，当时很高兴，原来C语言还可以写出一个对话框，之前的学习都是在黑框框中进行的。后来拷贝了教程开始学习，发现可以用C语言写界面，然后自己跟着教程做东西，当时觉得可以写一个对话框好牛逼，还可以处理点击事件，继续显示对话框，当时感觉就像是进入了另一个世界，原来编程可以是这个样子。这完全激发了自己爱做东西的爱好，后来在寒假为了把可视化做的更好，自己便开始学习MFC，当时还买了侯俊杰的《深入浅出MFC》，这是我买过的第一本技术书籍，现在还在身边，后来在那个寒假里开始学习MFC，假期结束时自己做了一个定时开关机的小应用，非常开心。不过在MFC的道路上自己并没有走很远。开学后，跟同学交流后，她直言现在（2011）MFC已经快过时了，你应该学Java啊，然后一语惊醒梦中人，我开始自学Java，还是采取了之前的套路，从网站找了视频教程开始学习Java语法，后来尽管不怎么写界面，但是对编程已经非常痴迷，觉得只要学习好了一门语言就可以用代码控制一切，写出任何你要要的结果。后来自学JavaWeb、包括CSS等前端知识，还有数据库。然后那个学期结束后的暑假，自己在学校里已经提前下载好了很多系统的教学视频，包括MLDN的Oracle数据库视频以及Struts2等其他框架视频，那个假期基本就是在听视频的过程中度过的，一个假期学到的东西比一学期学的还多。依旧记得当时用三大框架组合起来做一个Web应用时出现了一个问题，自己硬是死磕了三天终于把一个整合了三大框架的web项目跑起来了，当时开心的无以言表，还记得自己跟老妈描述我问题的傻样子。到后来，毕业后来到北京，加入浩浩荡荡的IT大军。每个人有每个人的故事，编程不是一个体力活，编程是一个富有创造力的工作，我喜欢创造的感觉，就像小时候喜欢做的凿子、弓箭。</li>
  <li>记忆大师引爆者烈日灼心羞羞的铁拳独自等待阳光灿烂的日子美丽人生非凡任务嫌疑犯X的献身缝纫机乐队战狼杀破狼—贪狼摔跤吧爸爸追龙英伦对决迫在眉睫金刚：骷髅岛血战钢锯岭第一滴血[1，2，3，4]</li>
  <li>版权声明：本文为咕咚原创文章，可以随意转载，但必须在明确位置注明出处。个人主页: http://gudong.site文章地址: http://gudong.site/2017/12/01/imageview-scaletype.html介绍在使用ImageView的时候，经常需要设置它的scaleType，但是一些时候对他们的区别总是很难把握，这次通过示例完整的了解一下不同的scaleType对一个ImageView的展示到底会有什么样的区别。这是原图片可以看到，其实他有一个内部padding的距离。ImageView布局下面使用ImageView用来显示这个图片资源，然后分别使用不同的scaleType进行展示，布局代码如下&lt;ImageViewandroid:layout_width="300dp"android:layout_height="500dp"android:layout_centerInParent="true"android:scaleType="center"android:src="@mipmap/ic_launcher"/&gt;这是一个宽300dp高500dp的ImageView，现在设置scaleType为center说明：为了显示方便，这里设置ImageView的背景为灰色，下面所有截图中看到的灰色区域就是ImageView的区域。1、scaleType=”center”scaleType为center表示按照图片尺寸在给定的ImageView上居中显示图片，如下所示，当ImageView尺寸很大足够容纳图片时，图片会居中显示在ImageView中。但是当ImageView的size被设置的较小，如下ImageView的宽高被设置为20-50时，此时ImageView的size小于图片的大小，会发现图片依旧居中显示，但是为了居中显示，图片会被按ImageView的宽高比例进行缩小然后裁剪如下所示：2、scaleType=”centerCrop”它会根据ImageView的尺寸，把目标图片按照ImageView的尺寸进行等比例放大或缩小然后裁剪，最终显示。这里因为原图尺寸没有ImageView尺寸大，所以图片会被放大，然后最终被裁剪后显示成如下图所示的样式。3、scaleType=”centerInside”目前跟center一致，看不出有什么区别，但是如果ImageView的尺寸小于图片自己的尺寸，它就会跟center的效果不一样了，它会自适应ImageView进行自适应，比如，我们将ImageView的尺寸特意设的特别小。&lt;Imageandroid:layout_width="20dp"android:layout_height="50dp"android:layout_centerInParent="true"android:scaleType="fitCenter"android:src="@mipmap/ic_launcher"/&gt;然后效果如下。对比scaleType=center在ImageViewsize小于图片size的情况下,center会把图片进行裁剪，但是centerInside就不会，这也是为什么叫inside的缘故吧。4、scaleType=”fitStart/fitEnd/fitCenter”fit表示图片自己会根据ImageView的尺寸进行自适应。start表示在图片靠上面，end表示靠下边，center表示居中这里区分一下fitCenter和centerInsidefitCenter会放大图片自身，然后居中显示，如上图所示。但是centerInside不会放大图片，还是根据图片尺寸居中显示在ImageView中。5、scaleType=”matrix”matrix是ImageView默认的scaleType,他不改变原图的大小，从ImageView的左上角开始绘制原图，原图超过ImageView的部分作裁剪处理。同样对比下ImageView在不同尺寸下的样式ImageView尺寸大于图片尺寸ImageView尺寸小于图片尺寸6、scaleType=”fitXY这中类型最好理解，不管原图的宽高比例，直接把原图按照ImageView的大小尺寸进行拉伸，使原图填满ImageView，非常暴力，实际开发中用到的不多，因为很容易造成图片变形的问题。总结结合平时的开发经验，一般主要用的scaleType就几种，比较多的是center、centerInside以及fitCenter,主要掌握这几个类型的区别。</li>
  <li>不经意间，十一已经过完了，从大学开始，每年的十一都有不一样的主题，不知为什么自己对十一影响也很深。每年十一结束后，可以来这更新一下了。2020/10/082018/12/13晚上20年十一今年十一是呆的最久的一次，更多详细内容见岁月在变迁，亲人都安好—2020十一假期儿子老妈一起坐飞机回家分户办理一卡通取社保卡带媳妇去娘家吃烧烤回老家毛家道被推平了带妈妈去下湖参加韩金凤婚礼吃各种小吃孩子吃药，坐车回来，硬座19年十一十一结束了今年的主题:回老家，看山，回家后的第二天中午去了东寨，然后在那边陪孩子玩，吃，很开心。十一当天看了阅兵，中午吃完饭，老爹骑摩托送我们到公路，然后回永昌，当天没有逗留，下午老爹叫车一起挤车回了老家。家里被挖的坑坑洼洼，院子里杂草丛生，老爹之前已经做了祛除，我随即想到把它们烧了，然后烤土豆吃。下午带轩轩，灵杰去地里捡土豆。他俩玩的很开心。晚上吃完饭开始烧火，轩轩很喜欢灭火，土豆烤了一小时，吃到了烤土豆。第二天制作了鱼钩，鱼饵去钓鱼。下湖景色跟以前一样，鱼没有，轩轩爱爬山，就这样玩了回来。到家我终于按捺不住骑摩托的心，把轩轩交给老妈后，一个人骑车去了后山。喜欢那种感觉，正如吴翩所说，以前都在想以后，没有关注当下，所以现在看原来的山，原来的地都那么好。我奔跑在山里，爬上了儿时放牛的山顶，那是我的地盘，回忆历历在目，但是再站在哪里，心里想到，思考的事却乱七八糟，在山顶重新唱羽泉的《哪一站》，非常应景。天色渐晚，我要回去了，我喜欢骑车在西北隔壁摊的感觉…回家吃饭…第三天早晨天气一般，带轩轩去爬山，前山坡，爬的很轻松很愉快，还带他去了山沟沟里…下午便坐姐夫车回到了永昌…第二天参加张鹏的婚礼。宴席不错，吃的很舒服，下午去潘万万家，呆了一下午，吃过晚饭回家睡觉。第五天去了大哥家里，二个侄子挺有意思。下午张鹏叫去喝酒，一直到了晚上十一点，喝的不错，嫂子不错，人挺nice？最后一天白天去了哥哥家，轩轩吃了垃圾食品，晚上我终于吃到了甜丸子跟麻辣粉，在四舅家喝酒到晚上，哥哥骑车子送我到车站…假期结束。18年十一本打算提前请三天假去内蒙参加朱元婚礼，然后回家接孩子还有妈妈来北京。但是婚礼第二天便得知孩子得了手足口病，然后匆忙从磴口出发到临河然后到中卫，第二天下午到医院。后来媳妇也回家了，很折腾后，后来我按时到公司，孩子跟妈、媳妇一起从兰州坐飞机到了北京，轩轩跟老妈第一次坐飞机。实际两天参加婚礼17年十一我跟媳妇回家看孩子，老家天很蓝，水很清，孩子很调皮，我很开心，一开始在媳妇家，我在我们家呆了两天，然后带着轩轩怕了长城、上了山坡，还去了下湖。家乡变化很大，站在老家的土地上，我再也找不到以前的那种感觉。另外因为有孩子，也没有太多时间跟老爹老妈聊天，老爹老妈老了，我在乎孩子，也很在乎父母，好想像14年那样，再带着老爹老妈去逛一趟北京，爬长城，看天安门。一切应该简单，想做什么做什么，我很怀念14年11月带着老爹老妈逛北京，也是目前为止对父母做过最好的事。16年十一那时我妈还有媳妇都在北京，然后十一没有出去，一直在家陪孩子。忘记有什么特别的感觉了。15年十一恍惚间，15年十一到了，这时我送媳妇回家，然后在家过完了十一，挺好，当时记得在村里看到邻居，说我长得越来越好看了…14年十一那一年有很多事，十一时正是我刚入职创新工场的第一周后，当时的Android团队也是我最喜欢的团队，尤记得当时十一前，leader分配了我一个任务，是一个首页的交互效果，说让我挑战一下，尽管没说让我假期做，但当时自己因为没有任何假期安排，所以就试着在我的小房子里完成了那个效果，尤记得当时画图、计算的场景。十一结束时和几个朋友一起去吃了大闸蟹。然后十一过了13年十一去了兰州，却也忘了都在干嘛…12年十一北京潘家园，每一天在阴暗中度过，却是难忘、刻骨铭心的求学体验。</li>
  <li>版权声明：本文为咕咚原创文章，可以随意转载，但必须在明确位置注明出处。作者博客地址: http://gudong.site本文博客地址: http://gudong.site/2017/05/15/leakcanary-theory.htmlLeakCanary是Square公司为Android开发者提供的用于在开发期检测内存泄漏的神器，本文简单分析一下LeakCanary具体的检测原理。通过本文你将会收获：Application.ActivityLifecycleCallbacks（应用中所有Activity生命周期检测）WeakReference的另一个构造方法原理分析LeakCanary在Application中安装完成后，会注册对应用内所有Activity生命周期的监听，具体监听的原理在于Application的registerActivityLifecycleCallbacks方法，该方法可以对应用内所有Activity的生命周期做监听。那具体在什么地方注册了对应的监听呢？追踪发现具体在：#ActivityRefWatcher#watchActivitiespublicvoidwatchActivities(){//Makesureyoudon'tgetinstalledtwice.stopWatchingActivities();//注册Activity生命周期监听application.registerActivityLifecycleCallbacks(lifecycleCallbacks);}这里的lifecycleCallbacks是一个监听的简单实现，但是这个实现只对Activity的销毁回调onDestory做了监听处理，如下所示：privatefinalApplication.ActivityLifecycleCallbackslifecycleCallbacks=newApplication.ActivityLifecycleCallbacks(){@OverridepublicvoidonActivityCreated(Activityactivity,BundlesavedInstanceState){}@OverridepublicvoidonActivityStarted(Activityactivity){}@OverridepublicvoidonActivityResumed(Activityactivity){}@OverridepublicvoidonActivityPaused(Activityactivity){}@OverridepublicvoidonActivityStopped(Activityactivity){}@OverridepublicvoidonActivitySaveInstanceState(Activityactivity,BundleoutState){}@OverridepublicvoidonActivityDestroyed(Activityactivity){ActivityRefWatcher.this.onActivityDestroyed(activity);}};接着看onActivityDestroyed方法：voidonActivityDestroyed(Activityactivity){refWatcher.watch(activity);}publicvoidwatch(ObjectwatchedReference){watch(watchedReference,"");}//存放被GC后对象队列ReferenceQueuequeue=newReferenceQueue&lt;&gt;();publicvoidwatch(ObjectwatchedReference,StringreferenceName){//.....finalKeyedWeakReferencereference=newKeyedWeakReference(watchedReference,key,referenceName,queue);//.....}这里会把检测到的activity实例关联包装为一个自定义的弱引用（KeyedWeakReference），但是这里在指定弱引用时，LeakCanary同时还为这个弱引用指定了一个ReferenceQueue队列。这个队列很重要，它是WeakReference的第二个构造参数，下面是ReferenceQueue的文档介绍Referencequeues,towhichregisteredreferenceobjectsareappendedbythegarbagecollectoraftertheappropriatereachabilitychangesaredetected.该队列的具体作用就是当发生GC后，WeakReference所持有的对象如果被回收就会进入该队列，所以只要在activityonDestory时，把Activity对象绑定在WeakReference中，然后手动执行一次GC，然后观察ReferenceQueue中是不是包含对应的Activity对象，如果不包含，说明Activity被强引用，也就是发生了内存泄漏。接着LeakCanary会使用Square开源库haha来分析Androidheapdump文件，并把最终结果通过通知的方式显示在通知栏。这就是LeakCanary工作的大致原理。本文原创发布于公众号大侠咕咚，欢迎扫码关注更多原创文章。</li>
  <li>该文主要探究Android中Activity与Window、PhoneWindow、DecorView之间的关系。Activity的概念都比较熟悉，但是Window、PhoneWindow、DecorView这几个类并不常用，所以很多时候容易忽略了它们。其实在Activity的背后，它们都发挥着很重要的作用，比如下文即将要说到的setContentView()原理以及事件分发源头都可以看到他们。版权声明：本文为咕咚原创文章，可以随意转载，但必须在明确位置注明出处。作者博客地址: http://gudong.site本文博客地址: http://gudong.site/2017/05/08/activity-windown-decorview.html下面从类关系的层次上简述一下他们的关系。关系简述每一个Activity都持有一个Window对象，publicclassActivityextendsContextThemeWrappe{privateWindowmWindow;}但是Window是一个抽象类，这里Android为Window提供了唯一的实现类PhoneWindow。也就是说Activity中的window实例就是一个PhoneWindow对象。但是PhoneWindow终究是Window，它并不具备多少View相关的能力。不过PhoneWindow中持有一个Android中非常重要的一个View对象Decor(装饰)View，它在PhoneWindow中的定义如下：publicclassPhoneWindowextendsWindow{//Thisisthetop-levelviewofthewindow,containingthewindowdecor.privateDecorViewmDecor;}查看DecorView继承关系得知，DecorView继承自FrameLayout。publicclassDecorViewextendsFrameLayout{}现在的关系就很明确了，每一个Activity持有一个PhoneWindow的对象，而一个PhoneWindow对象持有一个DecorView的实例，所以Activity中View相关的操作其实大都是通过DecorView来完成。但是具体呢，DecorView如何与Activity关联起来，下面简单分析两个案例。实例讲解这里分析两个开发中常见的与window、decorView相关的案例，一个是setContentView()作用原理，一个是View事件分发原理相关。setContentView()与DecorView我们对Activity的setContentView(intresId)方法都非常熟悉，通过该方法，Android可以帮我们把自己写好的布局文件(resId)最终展示在Activity的内容区域中。但具体是怎么做到的呢？这里其实就是通过不断的传递，把布局文件对应的资源id一直传递到这个Activity对应的decorView中，decorView本身是一个FrameLayout，当decorView接受到来自Activity传递过来的布局id后，通过inflater，把布局资源id转换为一个View，然后把这个布局View添加在自身中。到此为止，我们就在Activity中最终看到了自己指定的布局样式。下面稍微看看源码中的逻辑流转。从MainActivity的onCreate方法开始MainActivity@OverrideprotectedvoidonCreate(BundlesavedInstanceState){super.onCreate(savedInstanceState);setContentView(R.layout.activity_main);}ActivitypublicvoidsetContentView(@LayoutResintlayoutResID){getWindow().setContentView(layoutResID);initWindowDecorActionBar();}这里可以看到，Activity的setContentView方法紧接着又调用的WindowsetContentView方法，从上面的描述可知，这里的window其实就是PhoneWindow，所以查看PhoneWindow的setContentView方法实现。PhoneWindow@OverridepublicvoidsetContentView(intlayoutResID){if(mContentParent==null){//初始化id为android.R.id.content的根布局，将其赋值给mContentParentinstallDecor();}else{mContentParent.removeAllViews();}//把Activity中指定的布局id最终inflate到mContentParent中mLayoutInflater.inflate(layoutResID,mContentParent);finalCallbackcb=getCallback();if(cb!=null&amp;&amp;!isDestroyed()){cb.onContentChanged();}}这个方法就是最终发生作用的地方，执行完该方法后，从Activity传递而来的布局资源id最终就会添加到decorView中。这里的installDecor方法很重要，通过该方法做了很多初始化相关的操作，这里不展开，有兴趣可以自己看看。事件分发与DecorView都知道在一个界面中，如果发生触摸点击事件，事件分发的源头在Activity的dispatchTouchEvent方法中，事件会从这里开发向下分发，然后分发到页面中具体布局View中，不断递归调用ViewGroup/View的dispatchTouchEvent方法，如果在递归过程中，和事件分发相关的三个方法dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent都返回了false那么事件最终会执行到Activity的onTouchEvent方法中，那么表示一次事件分发结束。如果根据这个流程画出一个流程图，就可以看到一个U形图。关于事件分发的细节有很多，这里不展开了，具体可以参考我收集的最佳文章。但是Activity如何能把触摸事件从Activity中分发到具体的ViewGroup/View呢？跟上面的setContentView原理类似，Activity在接受到上层派发来的事件后，会把事件传递到自己的dispatchTouchEvent方法中，然后Activity会把触摸、点击事件传递给自己的mWindow对象，最终传递给decorView的dispatchTouchEvent方法。追踪代码如下所示ActivitypublicbooleandispatchTouchEvent(MotionEventev){if(ev.getAction()==MotionEvent.ACTION_DOWN){//不关心onUserInteraction();}//派发给window对象if(getWindow().superDispatchTouchEvent(ev)){returntrue;}returnonTouchEvent(ev);}PhoneWindow@OverridepublicbooleansuperDispatchTouchEvent(MotionEventevent){returnmDecor.superDispatchTouchEvent(event);}可以看到，最终的事件传递到了decorView，看decorView怎么处理事件DecorViewpublicbooleansuperDispatchTouchEvent(MotionEventevent){returnsuper.dispatchTouchEvent(event);}可以看到DecorView直接调用了super的dispatchTouchEvent方法，也就是最终走了ViewGroup的dispatchTouchEvent方法。从这里就可以知道了，都说Activity的dispatchTouchEvent方法是事件传递的源头（其实如果向上追应该还能追踪源头），但是不断传递事件，最终Activity接受到的事件还是到达了Activity对饮的DecorView中，而DecorView是一个FrameLayout，所以接下来的分发规就是正常的ViewGroup分发逻辑了。补充关于Activity与Window之间的关系以及他们具体是怎么关联起来的，这里并没有给出具体的答案，这里面会涉及到WindowManage已经IPC相关的内容，具体可以查看《Android开发艺术探索》的第八章。不过这里还是从大体上简单概括一下Activity启动后Window与View是怎么跟Activity关联起来的。Activity的启动代码具体位于ActivityThread的performLaunchActivity方法中，如下所示：ActivityThread#performLaunchActivityActivityactivity=null;java.lang.ClassLoadercl=r.packageInfo.getClassLoader();//初始化Activityactivity=mInstrumentation.newActivity(cl,component.getClassName(),r.intent);if(activity!=null){ContextappContext=createBaseContextForActivity(r,activity);CharSequencetitle=r.activityInfo.loadLabel(appContext.getPackageManager());Configurationconfig=newConfiguration(mCompatConfiguration);//执行attachactivity.attach(appContext,this,getInstrumentation(),r.token,r.ident,app,r.intent,r.activityInfo,title,r.parent,r.embeddedID,r.lastNonConfigurationInstances,config,r.voiceInteractor);}可以看到ActivityThread通过类加载的方式实例化Activity完毕后，会调用Activity的attach方法。然后在Activity的attach方法中初始化了mWindow对象。finalvoidattach(Contextcontext,ActivityThreadaThread,Instrumentationinstr,IBindertoken,intident,Applicationapplication,Intentintent,ActivityInfoinfo,CharSequencetitle,Activityparent,Stringid,NonConfigurationInstanceslastNonConfigurationInstances,Configurationconfig,Stringreferrer,IVoiceInteractorvoiceInteractor,Windowwindow){...//实例化window对象mWindow=newPhoneWindow(this,window);mWindow.setWindowControllerCallback(this);mWindow.setCallback(this);mWindow.setOnWindowDismissedCallback(this);...}这里已经可以知道，当Activity启动时对应的Window对象也已经创建好，但是在Activity调用setContentView之前，window上没有任何View，然后经过setContentView，最终执行ActivityThread的handlerResumeActivity方法，然后调用Activity的onResume方法，最终调用activity的makeVisible方法后，最终才把decorView添加到WindowManage，如下所示：voidmakeVisible(){if(!mWindowAdded){ViewManagerwm=getWindowManager();//添加到WindowManagewm.addView(mDecor,getWindow().getAttributes());mWindowAdded=true;}mDecor.setVisibility(View.VISIBLE);}总结到此为止，我们应该已经大概了解了Activity中的一些View相关的逻辑是怎么跟window发生关系的。其实可以看到上面两个跟View操作相关的分析过程中，Activity、以及Activity的成员变量mWindow什么也没干，他们拿到参数都第一时间都是外抛，最终都会抛给mWindow的decorView去做具体的逻辑。这里可能会想，难道ActivityWindow都是傀儡吗？为什么上面的分析中，他们接受到命令后都是一个劲的外抛，自己不处理呢？他们没作用吗？我想其实这里应该是一种特意的设计策略。作为一个Activity，它承载了很多功能和使命，它不仅仅是为View操作而服务的，所以它把View相关的操作交给DecorView去完成，通过这种“外包”的方式使得自己不用关心View操作的细节，到最后其实有点管理中经常说的“授权”的意思。本文原创发布于公众号大侠咕咚，欢迎扫码关注更多原创文章。</li>
  <li>在软件开发中，池一直都是一种非常优秀的设计思想，通过建立池可以有效的利用系统资源，节约系统性能。Java中的线程池就是一种非常好的实现，从JDK1.5开始Java提供了一个线程工厂Executors用来生成线程池，通过Executors可以方便的生成不同类型的线程池。但是要更好的理解使用线程池，就需要了解线程池的配置参数意义以及线程池的具体工作机制。版权声明：本文为咕咚原创文章，可以随意转载，但必须在明确位置注明出处。作者博客地址: http://gudong.site本文博客地址: http://gudong.site/2017/05/03/thread-pool-intro.html下面先介绍一下线程池的好处以及创建方式，接着会着重介绍关于线程池的执行原则以及构造方法的参数详解。线程池的好处引用自 http://ifeve.com/java-threadpool/ 的说明：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。创建线程池//参数初始化privatestaticfinalintCPU_COUNT=Runtime.getRuntime().availableProcessors();//核心线程数量大小privatestaticfinalintcorePoolSize=Math.max(2,Math.min(CPU_COUNT-1,4));//线程池最大容纳线程数privatestaticfinalintmaximumPoolSize=CPU_COUNT*2+1;//线程空闲后的存活时长privatestaticfinalintkeepAliveTime=30;//任务过多后，存储任务的一个阻塞队列BlockingQueue&lt;Runnable&gt;workQueue=newSynchronousQueue&lt;&gt;();//线程的创建工厂ThreadFactorythreadFactory=newThreadFactory(){privatefinalAtomicIntegermCount=newAtomicInteger(1);publicThreadnewThread(Runnabler){returnnewThread(r,"AdvacnedAsyncTask#"+mCount.getAndIncrement());}};//线程池任务满载后采取的任务拒绝策略RejectedExecutionHandlerrejectHandler=newThreadPoolExecutor.DiscardOldestPolicy();//线程池对象，创建线程ThreadPoolExecutormExecute=newThreadPoolExecutor(corePoolSize,maximumPoolSize,keepAliveTime,TimeUnit.SECONDS,workQueue,threadFactory,rejectHandler);具体参数介绍corePoolSize线程池的核心线程数。在没有设置allowCoreThreadTimeOut为true的情况下，核心线程会在线程池中一直存活，即使处于闲置状态。maximumPoolSize线程池所能容纳的最大线程数。当活动线程(核心线程+非核心线程)达到这个数值后，后续任务将会根据RejectedExecutionHandler来进行拒绝策略处理。keepAliveTime非核心线程闲置时的超时时长。超过该时长，非核心线程就会被回收。若线程池通设置核心线程也允许timeOut，即allowCoreThreadTimeOut为true，则该时长同样会作用于核心线程，在超过aliveTime时，核心线程也会被回收，AsyncTask配置的线程池就是这样设置的。unitkeepAliveTime时长对应的单位。workQueue线程池中的任务队列，通过线程池的execute()方法提交的Runnable对象会存储在该队列中。ThreadFactory线程工厂，功能很简单，就是为线程池提供创建新线程的功能。这是一个接口，可以通过自定义，做一些自定义线程名的操作。RejectedExecutionHandler当任务无法被执行时(超过线程最大容量maximum并且workQueue已经被排满了)的处理策略，这里有四种任务拒绝类型。线程池工作原则1、当线程池中线程数量小于corePoolSize则创建线程，并处理请求。2、当线程池中线程数量大于等于corePoolSize时，则把请求放入workQueue中,随着线程池中的核心线程们不断执行任务，只要线程池中有空闲的核心线程，线程池就从workQueue中取任务并处理。3、当workQueue已存满，放不下新任务时则新建非核心线程入池，并处理请求直到线程数目达到maximumPoolSize（最大线程数量设置值）。4、如果线程池中线程数大于maximumPoolSize则使用RejectedExecutionHandler来进行任务拒绝处理。任务队列BlockingQueue任务队列workQueue是用于存放不能被及时处理掉的任务的一个队列，它是一个BlockingQueue类型。关于BlockingQueue，虽然它是Queue的子接口，但是它的主要作用并不是容器，而是作为线程同步的工具，他有一个特征，当生产者试图向BlockingQueue放入(put)元素，如果队列已满，则该线程被阻塞；当消费者试图从BlockingQueue取出(take)元素，如果队列已空，则该线程被阻塞。(From疯狂Java讲义)任务拒绝类型ThreadPoolExecutor.AbortPolicy:当线程池中的数量等于最大线程数时抛java.util.concurrent.RejectedExecutionException异常，涉及到该异常的任务也不会被执行，线程池默认的拒绝策略就是该策略。ThreadPoolExecutor.DiscardPolicy():当线程池中的数量等于最大线程数时,默默丢弃不能执行的新加任务，不报任何异常。ThreadPoolExecutor.CallerRunsPolicy():当线程池中的数量等于最大线程数时，重试添加当前的任务；它会自动重复调用execute()方法。ThreadPoolExecutor.DiscardOldestPolicy():当线程池中的数量等于最大线程数时,抛弃线程池中工作队列头部的任务(即等待时间最久的任务)，并执行新传入的任务。参考聊聊并发（三）Java线程池的分析和使用Android线程池(二)——ThreadPoolExecutor及其拒绝策略RejectedExecutionHandler使用示例多线程线程池ThreadPoolExecutor介绍本文原创发布于公众号大侠咕咚，欢迎扫码关注更多原创文章。</li>
  <li>墨迹天气是一款免费的天气信息查询软件，由于要展示各种各样的数据信息，所以项目中有大量的涉及到图表相关的自定义View，如展示24小时的温度曲线图、潮汐图等等。这里就简单分享一些自己在开发空气质量页面时，开发逐小时预报曲线的一些经验。版权声明：本文为咕咚原创文章，可以随意转载，但必须在明确位置注明出处。作者博客地址: http://gudong.site本文博客地址: http://gudong.site/2017/04/28/custom-preference-view.html目前该View的实现已开源在GitHub，TrendChartView，如果觉得不错，就star支持下。如下是最终的效果示意图。整个View需要显示最近6天的逐小时空气质量信息，共绘制了144个小柱子，以及背景还有随着手指移动的指示器，但是最终实现完成的效果还是挺流畅的，在手机上做帧率测试时一直维持在60fps，滑动几乎没有卡顿的感觉。下面简单分析下这个View有哪些需求点。分析1、该View用于按照逐小时来展示最近6天的空气质量指数（后文简称为空指）。2、最左侧纵轴展示空指的大小，一直处于显示状态。3、逐小时预报柱状图显示在纵轴左侧，可滑动显示出每一天的预报数据。4、数据指示器显示滑动到时间对应的空值数值，且颜色要随着等级而变化。5、数据指示器需要一直显示在屏幕可见区域。6、滑动到哪天，哪天对应的日期要高亮，其余未滑动的日期置灰。想了想重要的就这些，还有些细节就不一一列举了。现在考虑实现，可不可以直接把整个区域画在一个View上？当然可以，但是考虑到这里面有滑动操作，这样做会很麻烦，费力不讨好。由于左边的纵轴区域位置固定，所以现在考虑把整个区域拆成两部分，可以分为最左边的纵轴部分和位于其右侧的可滑动柱状图两部分。这样最左侧纵轴部分可以使用一个LinearLayout就可以实现，但是实际做的时候，因为他的背景有一些曲线效果，随意最终还是使用了自定义View来绘制实现。接下来考虑位于其右侧的柱状图部分，这部分比较复杂，这里仔细分析一下，他主要的特征有两个：1、响应手势，可左右滑动2、跟随手势，显示指示器这里，如果一开始就形成思维定势，仅使用一个View来做滑动以及绘制，那么你就必须在自己的自定义View里处理onTouch事件，这样这个View就会因此复杂很多。之前看到过一个开源的曲线项目SuitLines，就是把触摸滑动逻辑做在View中，通过处理onTouch事件来做滑动效果，整个View代码逻辑会复杂很多。这里，我们采用了取巧的方式，把柱状图以及滑动效果的实现通过View组合的形式实现。滑动效果的实现通过HorizontalScrollView实现，而我们自定义的View处理所有元素的绘制。然后让HorizontalScrollView把自定义View包起来即可。这样就完了吗？显然不是，看上面说到的第二点-跟随手势，显示指示器,这里需要实现这个效果，那么就需要这两个View来互相通信才能完成。HorizontalScrollView可以通过设置监听拿到当前的水平滑动距离，所以他可以把这个距离传递给柱状图View(这里把这个柱状图View命名为TrendChartView)，然后TrendChartView拿到这里距离值，然后自己做计算，控制指示器位置。大概逻辑就是这样。很显然为了更好的控制HorizontalScrollView，这里对他也要进行简单的自定义。下面就是整个布局的layout代码。如下所示&lt;!--水平的LinearLayout整个根布局--&gt;&lt;LinearLayoutandroid:layout_width="match_parent"android:layout_height="wrap_content"android:layout_gravity="center"&gt;&lt;!--纵轴View--&gt;&lt;name.gudong.trendchart.TrendYAxisViewandroid:id="@+id/trend_y_axis"android:layout_width="wrap_content"android:layout_height="wrap_content"/&gt;&lt;!--自定义的HorizontalScrollView--&gt;&lt;name.gudong.trendchart.HorizontalScrollChartParentViewandroid:id="@+id/sv_container"android:layout_width="match_parent"android:layout_height="match_parent"android:scrollbars="none"&gt;&lt;!--核心的柱状图View--&gt;&lt;name.gudong.trendchart.TrendChartViewandroid:id="@+id/trend_chart_view"android:layout_width="wrap_content"android:layout_height="wrap_content"/&gt;&lt;/name.gudong.trendchart.HorizontalScrollChartParentView&gt;&lt;/LinearLayout&gt;实现具体可见代码TrendChartView.java下面贴出核心onDraw方法的代码。@OverrideprotectedvoidonDraw(Canvascanvas){super.onDraw(canvas);//画等级虚线背景drawGradeAxis(canvas);//画柱状图drawCharts(canvas);//画指示器drawIndicatorLine(canvas,mOffset,mCurrentData);//画底部的时间drawBottomDateInfo(canvas);}卡顿问题按照思路开发完成花费不了多少时间，但是一开始开发完成后，发现滑动会有明显的卡顿，因为每一次滑动都需要根据手势移动的距离去重新设置指示器的位置，所以每次计算完新的位置后需要不停的invalidate,与此同时就会不停的触发onDraw方法，所以如果onDraw里的操作如果耗时比较多，就会很容易出现卡顿。所以，现在主要的优化点就应该集中在onDraw方法中，只要把onDraw方法的耗时降下来，卡顿问题也就迎刃而解。解决问题后来仔细查看后，发现在onDraw中有大量的计算逻辑，比如使用for循环计算每一个柱子的高度、计算背景虚线对应的path等等。尤其是柱子高度，其实没必要每次都去计算，因为只要空气指数大小确定，那么对应的柱子高度就是确定的，包括颜色，所以这里没必要每次去计算，只要计算一次即可，了解了这些就去做优化。提前计算把所有能提前完成的计算都尽可能的提前完成。那什么时候去做这个计算比较合适呢？TrendChartView有一个fillData的方法，用于提供给外部设置填充空值数据集合并刷新界面，所以这个地方就是最佳的地方，我们可以在拿到数据后就去做一些绘制相关的数据计算，如柱子区域、日期对应的坐标点集合。对应到代码中，如下所示：publicvoidfillData(List&lt;ITrendData&gt;dataList,List&lt;String&gt;dayListInfo,intdayCount){mListSize=dataList.size();mControlPoints=newArrayList&lt;&gt;(mListSize);mChartTrendWidthAbs=mListSize*getItemWidthWithSpace();mDataList=dataList;mDayCount=dayCount;mDayRecord=newSparseIntArray(mDayCount);mDayListInfo=dayListInfo;mCurrentTimePosition=getCurrentTimePosition(mDayListInfo);mAverageDayWidth=mChartTrendWidthAbs/mDayCount;//省略部分代码//计算柱状图的点集合calculateCurveDot();//计算背景虚线的pathcalculatedLinePath();//计算底部时间对应的坐标信息calculateBottomTextPoint();//发起重绘请求requestLayout();}这里拿calculateCurveDot这个方法举例说明，该方法用于提前计算柱状图的点集合。所以这里实现定义好一个集合//图表绘制点集合privateList&lt;ChartRect&gt;mChartRectList=newArrayList&lt;&gt;();其中，ChartRect为封装的用于画柱状图的属性对象。/***封装的用于画柱状图的属性对象*/privatestaticclassChartRect{/***柱状图矩区域*/RectFrectChart;/***柱子颜色*/@ColorIntintcolor;}现在就要提前把对应的点集合计算完成，如下所示：privatevoidcalculateCurveDot(){mChartRectList.clear();floatcurrentPosX;floatcurrentPosY;floatlastX=0;floatlastY=0;introundRadius=dp2;intlastDay=0;intposition=0;for(inti=0;i&lt;mListSize;i++){ITrendDatadata=mDataList.get(i);intdataWrapValue=data.warpValue();ChartRectchartRect=newChartRect();floatleft=(i+1)*mChartSpace+i*mChartItemWidth;floatbottom=mViewHeight-mBottomBlankSize+roundRadius;floattop=bottom-(dataWrapValue/mMaxAqiValue)*(mChartContentHeight)-roundRadius;floatright=left+mChartItemWidth;chartRect.rectChart=newRectF(left,top,right,bottom);chartRect.color=data.levelColor();mChartRectList.add(chartRect);}}这里主要领会精神即可。总之数据提前计算，不要做无意义的重复计算，除非一些属性要变化，只要不变化的属性能提前计算尽量都提前完成。使用位运算在onDraw方法中总有一些计算无法避免，这时为了追求极致的运算效率，对除法可以使用位运算。如下所示：width/2-&gt;width&gt;&gt;1使用ClipRect对于绘制过程中可能存在重复绘制的View区域，此时为了绘制效率，建议使用Canvas的clipRect方法lai来精确控制View可绘制的边界，具体clipRect的详细介绍，可参看链接。Path优化该View中的背景有三根垂直排列的直线，这里用到了path，一开始自己也是在onDraw中每次去计算这三根线的起始点坐标，后来经同事提示，可以事先一次性把Path的坐标都计算好，然后绘制时，一次性就可以把三根线绘制好。如下所示：//提前计算pathprivatevoidcalculatedLinePath(){mPathGradLine.reset();for(inti=0;i&lt;mGradeCount;i++){mPathGradLine.moveTo(0,bottomLine-averageGradleHeight*i);mPathGradLine.lineTo(getChartRealWidth(),bottomLine-averageGradleHeight*i);}}/***绘制三根背景虚线*@paramcanvas*/privatevoiddrawGradeAxis(Canvascanvas){canvas.drawPath(mPathGradLine,mGradeAxisPaint);}总结当然，具体做绘制优化时，可能不同的View需求，具体优化策略也可能千变万化，这里只是拿这个具体的View来做一点具体的介绍，不具有通用性，但是优化的思想应该有共性。View绘制的优化是无止境的，始终保持学习钻研、精益求精的态度方可做到最好。</li>
  <li>本文将结合自己的项目开发实践，简单分享一下关于多状态Layout的开发实践Tips。版权声明：本文为咕咚原创文章，可以随意转载，但必须在明确位置注明出处。作者博客地址: http://gudong.site本文博客地址: http://gudong.site/2017/04/26/loading_layout_practice.html什么是多状态Layout对于大多数App而言，项目中都有多状态加载View这种需求，如下图所示。对应到开发中，我们通常会开发一个对应的自定义layout用于根据页面不同的状态来显示不同的提示view。在项目中，我们大多会在开发初期就把这套layout框架写好，然后其他人的自己的开发过程中直接使用即可。如下所示：&lt;name.gudong.MJMultipleStatusLayoutandroid:layout_width="match_parent"android:layout_height="match_parent"&gt;&lt;ListViewandroid:id="@+id/lv_activity_center"android:layout_width="match_parent"android:layout_height="match_parent"/&gt;&lt;/name.gudong.MJMultipleStatusLayout&gt;这篇文章不讨论如何去实现这样的自定义loadinglayout，Github上这样的layout太多了，这里主要思考、总结在实际开发中开发这样的自定义Layout时应该注意那些地方。但是为了说明方便，这里还是采用的方案简单叙述一下。为了后文描述方便，这里把这个多状态自定义Layout先称为MultipleStatusLayout。实现方案在实现MultipleStatusLayout时，首先选择继承一个ViewGroup作为自己的父类，然后默认把内部的第一个子View作为ContentView，其它各种情形下对应要显示的layoutview，根据不同的加载状态，在MultipleStatusLayout中通过动态addView去控制对应layout的加载显示，也可以通过ViewStub把不同情形的layout进行懒加载，然后对外提供不同的方法，方便外部调用、控制不同状态下的layout显示。嗯，简单说来就是这样，原理很简单，实现起来也没什么技术难度，对于一般的开发人员只要一开始明白具体的产品逻辑和实现思路，相信花不了多少时间就可以完成这样的MultipleStatusLayout。具体这种方式的实现可以参看一个开源项目的实现。下面着重列举一下开发MultipleStatusLayout过程中的注意点或者要点。Tips考虑到MultipleStatusLayout开发完成后，会在项目中的很多页面中应用，而且很多时候是作为页面顶级父容器而存在，所以开发过程中一定要注意其性能还有稳定性，否则一旦出现问题，整个项目中应用到该MultipleStatusLayout的页面都会随之出现问题。以下就从性能角度、可维护性、稳定性等方面考虑出发，列举一些开发tip。选择最合理的父容器首先FrameLayout、RelativeLayout、LinearLayout都可以作为MultipleStatusLayout的父类，抛开现在的应用场景不谈，都知道RelativeLayout在layout时需要measure两次，所以对于一个未来要在很多页面中使用的Layout，把RelativeLayout作为父类这个方案首先pass掉。但是因为MultipleStatusLayout中显示的view大都需要居中显示，所以使用RelativeLayout相对比较容易控制居中位置，这可能是很多人选择RelativeLayout作为父类的初衷。这里自己可以做一下权衡。关于LinearLayout和FrameLayout，如果按照上一节提到的实现方案，其实都可以采用，不过考虑到该类Layout的应用场景，建议选择FrameLayout。因为MultipleStatusLayout未来在大多数情况下是作为页面父容器存在的，既然是父容器，内容可能会有各种变化，这时使用LinearLayout这种线性布局就会在布局时显得特别局限，比如一些页面可能需要在MultipleStatusLayout之上显示一个FloatActionButton或者其他的view，这时使用FrameLayout就会好做很多也会灵活很多。选择最优的加载View方式如何控制这些多状态对应的View?对于一般的情形，至少有两种View类型，一种是加载中的loading样式view，一种是异常状态的layoutview，当然还可能有更多具体的情形。不同的样式对应一个不同的布局，为了简便我们可以一次性的把所有状态对应的布局都写在一个layout布局里，然后可以通过控制隐藏、显示来根据不同的状态来展示不同view，这是最直接的想法。但是，只要多思考一步，就会发现这种方式非常不可取。因为很多时候，MultipleStatusLayout作为一个父容器只关心自己的ContentView，异常页面和加载页面甚至可能没有机会出现，但是现在这样做就表示，这个页面不论有没有异常或者加载逻辑，你的布局里都会存在对应的layout布局代码。这样在界面绘制时就会白白耗掉多余的时间。而且这个Layout后续会在项目很多页面用到，所以这里的布局耗时问题放大后就显得很严重。鉴于此，取而代之的更好的做法应该是动态去addView，只有这个页面第一次调用loading或者showError这样的方法，我才去把对应布局加载进来，当然这里使用ViewStub也是一样的效果。这里也就是说，只有调用了相应的方法，才去加载对应的layout.资源命名其实这个问题是自己开发公用Api普遍面临的问题，由于开发MultipleStatusLayout可能会定义一些颜色资源或者背景资源，这里建议所有资源开头使用一个固定的开头，这样可以防止跟主版本中的资源重名。进而早成一些奇怪的UI问题或者编译问题。比如按钮的背景你可以定义为msl_btn_normal而不是btn_normal，文字的颜色你可以定义为msl_text_white而不是text_white。这样就可以有效避免一些资源冲突。更多关于如何开发一个第三方库，可以查看天之界线的开发第三方库最佳实践提供友好的方法调用方式既然是提供给大家使用，你就应该在方法命名上多花点心思，最好见名之意，这样大家调用时也会舒服很多。另外对外提供Api时也应该保持克制。不要一下子提供出去太多的方法，不论有用没用，一下子都对外提供，这样会对后续的维护造成隐形的负担，因为提供的公用方法越多，表示你后续都要对这些方法进行维护。最好的原则就是用到什么提供什么，不要提前设计。另外，随着项目迭代，对外提供方法的参数可能会变得多起来，比如以前显示错误页面的方法是voidshowErrorView(Stirngerror)后来要增加自定义的icon或者点击事件响应，这时你就需要扩展方法参数，往往这种参数可能会变得很多不可收拾，这时建议使用Build构建模式设计，如下示例所示：showErrorView(StatusViewConfigconfig)调用时就可以这样调用showErrorView(newStatusViewConfig.StatusViewBuild(getContext()).icon(icon).message(message).subMessage(subMessage).layoutMode(mLayoutMode).withActionText(actionText,clickListener).build())良好的文档当你开发完成后，最好趁热写一份简单明了的使用文档出来，这样大家就可以直接对照文档使用你写的库，不用去关心代码实现，直接调用Api就可以完成自己的业务需求，同时也省的自己去面对面跟别人讲怎么使用了。前段时间在V站上看到一个问题，说你们公司使用什么样的文档管理工具？其中有一个回答言简意赅，很有意思，四个字口口相传。其实对于任何一个项目都是，有时间写点文档，梳理自己思路的同时方便别人，何乐而不为。其他这种Layout在项目中会随着项目的更新迭代而不断的更新，所以一开始你就应该知道，后续还要不断迭代更新，所以代码设计实现时应该留意扩展性。另外，相关的开源方案有很多，建议一开始可以参考一些好的方案，然后结合自己项目的实际需求，来开发维护属于自己项目的一套框架。因为多状态loading加载提示框架大都和产品设计强相关，不具备一般的通用性。下面列举一些自己收集到的多状态加载开源方案，方便对比。开源方案StatefulLayoutprogress-activityStateLayoutMultipleStatusView总结同样功能的Layout可能在不同的业务场景下实现方式也会有很大的区别，所以不论哪种实现方式，无所谓好坏，只要适合就好。但是开发此类Layout要遵循的基本准则、以及要注意的点应该大都相同，希望此文可以给你一些启示帮助。本文原创发布于公众号大侠咕咚，欢迎扫码关注更多原创文章。</li>
  <li>版权声明：本文为咕咚原创文章，可以随意转载，但必须在明确位置注明出处。个人主页: http://gudong.site文章地址: http://gudong.site/2017/04/24/jvm_oom_gc.html关于JVM内存模型以及垃圾回收的文章网上很多，自己以前也看过很多，但是却从来也没有系统的去了解学习过，这次正巧再看周志明老师的《深入理解Java虚拟机》，内容非常棒，所以自己就花了点时间，认真系统的学习了一遍。这篇文章主要简单记录分享一下关于JVM内存模型、内存溢出、内存分代、以及垃圾回收算法的相关知识。当然在原书中，这几部分作者都花了不少篇幅去讲解。如果这篇文章让你对相关知识产生了兴趣而意犹未尽，推荐去阅读原书。JVM内存区域都知道JVM的内存区域分为5个部分，如果有疑惑，可以参看之前的一篇文章-JVM内存区域介绍。这里也简单罗列一下JVM的五部分程序计数器这是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器，线程私有。Java虚拟机栈它是Java方法执行的内存模型，每一个方法被调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程，线程私有。本地方法栈跟虚拟机栈类似，不过本地方法栈用于执行本地方法，线程私有。Java堆该区域存在的唯一目的就是存放对象，几乎应用中所有的对象实例都在这里分配内存，所有线程共享这一区域。方法区它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，所有线程共享。有关OOM都知道，任何一个应用在启动后，操作系统分配给它的内存一定是有限的，所以如何合理有效的管理内存，就变得尤为重要。而从上节可知，我们一般讨论的对象内存分配均发生在Java堆上，所以这里说的内存管理大部分情况下即指对Java堆内存。而程序计数器、虚拟机栈他们随着线程生而生，亡而亡，所以他们内存相对比较好管理，出现的问题也比较少。一个应用启动后，在不停的运行过程中，不断创建新对象，而这些对象，大都存放在堆内存区域，但是这部分区域的大小是有限的，而需要生成的对象是无限的，所以当某一次创建对象时发现堆内存实在没有空间可用来创建对象的时候，JVM就会爆出OutOfMemoryError异常（后文统称OOM），程序就会挂掉。上面只是说明了一下表象。其实OOM远不是上面说的那么简单。如果要理解OOM，这里还有一些其他知识需要说明。OOM发生前，JVM会进行内存的垃圾回收（GC）垃圾回收有多种不同的实现算法为了更好的管理内存，堆内存进行了分代堆内存的新生代和老年代的垃圾回收算法不一致所以这里要对OOM有一个全面的认识，就必须对前面的知识点有一个综合的了解。接下来先说说OOM引申出的内存分代。内存分代一个应用启动，操作系统会给他分配一个初始的内存大小，由上可知，这部分内存大部分应该属于堆内存，JVM为了更好地利用管理这部分内存，对该区域做了划分，一部分成为新生代，另一部分称为老年代。一开始对象的创建都发生在新生代，随着对象不断创建，如果新生代没有空间创建新对象，将会发生GC，这时的GC称之为MinorGC，位于新生代的对象每经过一次MinorGC后，如果这个对象没有被回收，则为自己的标记数加1，这个标记数用于标识这个对象经历了多少次的MinorGC，对于Sun的Hotspot虚拟机，如果这个次数超过15，该对象才会被移动到老年代。随着时间的推移，如果老年代也没有足够的空间容纳对象，老年代也会试着发起GC，这时的GC被称为FullGC。相比MinorGC，FullGC发生的次数比较少，但是每发生一次FullGC，整个堆内存区域都需要执行一次垃圾回收，这对程序性能造成的影响比MinorGC大很多，所以我们应该尽量避免或者减少FullGC的发生。同时，在堆内存区域，发生最多的GC情形就是新生代的MinorGC了，因为所有的对象会优先去新生代开辟空间，所以这块的内存变化会很快，只有内存不够用，就会发生GC，但是一般的MinorGC执行比FullGC快很多。为什么呢？因为新生代和老年代的垃圾回收算法不一样。垃圾回收算法标记-清除算法（Mark-Sweep）这是最基础的收集算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的，它的主要缺点有两个：效率问题标记和清除过程的效率都不高；空间问题标记清除之后会产生大量不连续的内存碎片，空间碎片太多会更容易导致垃圾回收，因为当程序需要分配较大对象时，会更加容易因为无法找到足够大的连续内存而不得不提前触发另一次垃圾收集动作。复制算法（Copying）为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，未免太高了一点。但是这种算法的效率相当高，所以，现在的商业虚拟机都采用这种收集算法来回收新生代。为什么新生代可以使用复制算法呢？IBM有专门研究表明，新生代中的对象98%都是朝生夕死，所以就不需要按照1:1的比例来划分内存空间。这里鉴于此，新生代采用了如下的划分策略。现在把新生代再划分为三部分，一块较大的Eden(伊甸园)和两块较小的Survivor(幸存者)区域。当执行垃圾回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存是会被“浪费”的。这样清理完成后，原来的Survivor就空了，并一直保持为空，直到下次MinorGC时，它再作为存活对象的盛放地。两个Survivor就这样轮流当做GC过程中新生代存活对象的中转站。但是，如果使用复制算法的内存区域有大量的存活对象时，复制算法就会变得捉襟见肘，这时需要更大的Survivor区用于盛放那些存活对象，甚至可能需要1:1的比例。所以针对堆内存区域的老年代，就有了下面的算法。标记-整理算法标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。这种方法避免了碎片的产生，同时也不需要一块额外的内存空间，对于老年代会比较合适。但是相比复制算法，虽然该算法占用的内存空间少，但是耗费的垃圾回收时间会比复制算法久(时间换空间)，所以上面也说了我们应该尽量避免或者减少FullGC的发生。   这两种算法用精炼的语言描述就是复制算法:用空间换时间标记-整理算法：用时间换空间一句话鱼与熊掌不可兼得，但是针对新生代和老年代，他们都是最佳的选择。总结简单梳理一下文中讲到的一些知识点为了更好的管理堆内存，该区域分为新生代和老年代新生代发生垃圾回收要比老年代频繁新生代发生的垃圾回收成为MinorGC；老年代发生的GC成为FullGC新生代使用复制算法进行垃圾回收；老年代使用标记-整理算法为了更高效管理新生代的内存，按照复制算法，结合IBM的研究论证，新生代分为三块，一块比较大的Eden区和两块比较小的Survivor区，比例为8:1:1参考《深入理解Java虚拟机》-周志明老师AndroidGC原理探究</li>
  <li>在每个github项目的右上角，都有三个按钮,分别是watch、star、fork，但是有些刚开始使用github的同学，可能对这三个按钮的使用却不怎么了解，包括一开始使用github的我也是如此。这篇博客，结合自己的理解和使用，说说这三个按钮的用法以及一些个人见解。如下图所示这是我们经常看到的三个按钮。从左至右，依次是watchstarfork，下面分别说下他们的具体作用。watchwatch翻译过来可以称之为观察，点击watch可以看到如下的列表。对于别人的项目，默认自己都处于Notwatching的状态，当你选择Watching，表示你以后会关注这个项目的所有动态，这个项目以后只要发生变动，如被别人提交了pullrequest、被别人发起了issue等等情况，你都会在自己的个人通知中心，收到一条通知消息，如果你设置了个人邮箱，那么你的邮箱也可能收到相应的邮件。如下，我watching了开源项目android-cn/android-discuss，那么以后任何人只要在这个项目下提交了issue或者在issue下面有任何留言，我的通知中心就会通知我。如果你配置了邮箱，你还可能会因此不断的收到通知邮件。如果你不想接受这个项目的所有通知，那么点击NotWatching即可。另外这里有一篇文章讲如何正确接收GitHub的消息邮件，很不错的一篇文章，推荐大家看看。starstar翻译过来是星，但这个翻译没任何具体意义，这里解释为关注或者点赞更合适，当你点击star，表示你喜欢这个项目或者通俗点，可以把他理解成朋友圈的点赞吧，表示对这个项目的支持。不过相比朋友圈的点赞，github里面会有一个列表，专门收集了你所有star过的项目，点击github个人头像，可以看到yourstars的条目，点击就可以查看你star过的所有项目了，如下图所示不过，star列表很容易出现这样的问题：如果你平时比较爱逛github，star的项目过多后怎么快速查找自己想要的项目？这时，如果github可以提供一个分类功能该多好，就像微信公众号文章的收藏，你在点击微信菜单中的收藏后，微信会提示你对收藏的文章设置tag。这样设置的好处是，以后在微信收藏列表中查找项目时，可以根设置的tag归类查找，这样查找效率会提高不少。但是，不知道github的产品经理是怎么想的，github本身没有这个功能。但是github这个全球最大的程序员社区从来也不缺有思想有执行力的程序员。这不，现在就有人做了一个Chrome插件，这个插件可以对github中所有star的项目进行分类，如下所示，注意看图片右侧，多了一个Filterbytag列表。下载地址.尽管这个插件已经很好了，但是还是有缺点，你只能star完项目后去star列表，才能对项目打tag，这是很不方便的。真心希望，未来github可以自己支持对star的tag处理。憧憬…更新也许是github自己也发现了检索的问题，现在github增加了一个类似的功能，可以给自己给自己的项目设置topic.如下图所示。给自己的项目设置topic后，相当于自己给自己的项目设置了一个tag，这样可以方便别人搜索。比如要搜索所有topic为android的项目，你只需要在GitHub搜索时输入topic:android然后搜索。fork当选择fork，相当于你自己有了一份原项目的拷贝，当然这个拷贝只是针对当时的项目文件，如果后续原项目文件发生改变，你必须通过其他的方式去同步。一般来说，我们不需要使用fork这个功能，除非有一些项目，可能存在bug或者可以继续优化的地方，你想帮助原项目作者去完善这个项目或者单纯的想在原来项目基础上己维护一个属于自己项目（比如我fork的AndroidWeekly客户端），那么你可以fork一份项目下来，然后自己对这个项目进行修改完善，当你觉得项目没问题了，你就可以尝试发起pullrequest给原项目作者了。然后就静静等待他的merge邮件通知了。我看到很多人错误的在使用fork。很多人把fork当成了收藏一样的功能，包括一开始使用github的我，每次看到一个好的项目就先fork，因为这样，就可以我的repository(仓库)列表下查看fork的项目了。其实你完全可以使用star来达到这个目的。使用建议1、对于一些可能会经常发生变化的会不定期更新的好项目多使用watch.比如android-cn团队的android-discuss项目，你就可以watching它，这里面都是一些关于Android技术的交流，如果有任何新问题，你都可以收到通知，你可以查看别人的回答，你可以回答别人提出的问题，这是一个很好的学习成长方式。其他值得watch的项目还有很多，比如github上很多的Awesome系列的项目,如Awesome-MaterialDesign等，你watch这些项目了，只要项目新增一些好玩好用的东西，你就会收到通知。我在知乎上看到有人问这样的问题，说github上有哪些值得watch的项目，其实有很多，我自己也整理了一些，但是没放到github.值得注意的是，如果watch多了，你可能会被无休止的邮件通知烦死（邮件通知可设置），因为被watch项目有任何留言、PR等更新都会触发通知，所以做好权衡。2、喜欢一个项目就star它吧~3、修改开源项目就使用fork，这样你就可以在原项目的基础上，对项目进行修改提交，现在你是这个项目的主人啦~小细节有些时候，你看到一个项目的star数有很多，你就想知道到底都有那些人star了这个项目，或者fork了这个项目，但是环顾一圈，你却找不到一个入口，后来自己不经意的发现，只要点击star傍边的数字，就可以查看有哪些人star了这个项目。是不是有点意思，现在你就可以去试试，watch、fork上面的数字都是可以点击的，道理一样。结语这里只说了关于这三个按钮的使用，github肯定还有很多使用技巧，欢迎大家多多讨论，互相学习。另外我在android-cn的android-discuss下面和知乎上都分别提了类似的问题，大家感兴趣的可以关注下。GithubGithub上都有哪些有意思、不为大家熟知的小功能？知乎Github上都有哪些有用但不为大家熟知的小功能？链接简书地址:http://www.jianshu.com/p/6c366b53ea41微博地址:http://weibo.com/1874136301/Dc8nWqBeJ?type=repost</li>
  <li>作者博客地址: http://gudong.site本文博客地址:http://gudong.site/2017/04/18/jvm_memery_area.htmlJava内存模型Java内存模型定义了线程跟主内存之间的抽象关系：线程之间的共享变量存储在主内存，每个线程都有一个私有的本地内存，本地内存中存储的是该线程读写共享变量的副本。本地内存是一个抽象概念，并不真实存在。from全面理解Java内存模型_Java_HeavenWang的专栏-CSDN博客汇编语言：了解寄存器与内存模型-地铁程序员-博客园多线程内部运行机制硬件模型计算机内所有的计算都发生在CPU中，这是计算机专门用来做计算的地方，这里只做计算，不适合做存储，要计算的数据都存储在内存RAM这个地方，也就是RAM存储数据，CPU计算数据，计算完毕然后同步到内存。但是CPU直接操作RAM的效率并不高，这里如果有一个缓存，CPU计算时直接使用缓存就会快很多，除此之外，这样的高速内存依旧不够快，所以还为CPU设计了寄存器，它的存取速度接近于CPU的操作速度。这样的模型在单线程下很好的处理了CPU与RAM之间的存储效率之间的矛盾，是一种非常好的解决方案。但是在多线程的情况下，就会存在问题。两个线程A、B，A线程更改了变量值后，其实是在自己的缓存中更改的，并不是直接更新到RAM区，所以A线程对共享变量的更改是对副本的更改，并不能及时的同步到线程B，如果线程B也操作的同样的变量，就可能出现多线程同步问题。它保证了被包含的代码在执行时是原子的，只有代码执行完成，工作内存跟主内存已经同步完成，下一个线程才能执行代码，这样就解决了同步的问题，与此同时，程序的效率下降了，因为失去了CPU高速内存的设计。volatile如果一个变量是volatile修饰的，JMM会在写入这个字段之后插进一个Write-Barrier指令，并在读这个字段之前插入一个Read-Barrier指令。这意味着，如果写入一个volatile变量，就可以保证：一个线程写入变量a后，任何线程访问该变量都会拿到最新值。在写入变量a之前的写入操作，其更新的数据对于其他线程也是可见的。因为MemoryBarrier会刷出cache中的所有先前的写入。https://blog.csdn.net/suifeng3051/article/details/52611310Java虚拟机在执行Java程序的过程中，会把它所管理的内存划分为5个不同的数据区域。这些区域都有各自的用途，以及创建、销毁的时间，有的区域空间随着虚拟机进程的启动而分配，有些区域则是依赖用户线程，他们随着线程的启动和结束而建立和销毁。Java虚拟机管理的内存包括以下几个运行时数据区域，如图所示可以看到有五部分组成，下面分别介绍程序计数器程序计数器（ProgramCounterRegister）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。Java虚拟机栈Java虚拟机栈与程序计数器一样，Java虚拟机栈（JavaVirtualMachineStacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（StackFrame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。以前经常说Java内存分为堆内存和栈内存，这其实是一种不严谨的说法，这里说的堆内存没问题，但是栈内存，其实就是这里的Java虚拟机栈，或者说是虚拟机栈中的局部变量表。局部变量表局部变量表应该是一个典型的栈，他存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。怎么理解呢？比如现在正在执行一个方法，方法中定义了各种变量，voidtest(){intage=0;Stringname="mao"Personperson=newPerson(age,name);}这时方法test在虚拟机中执行时，agename这种基本数据类型会直接存放在局部变量表中，而person这种引用类型变量只会在局部变量表中存放一个引用指针，具体person的内存分配并不在局部变量表中分配，而是在后面讲到的Java堆中分配。JVM规范中规定了Java虚拟机栈可能会发生两种异常：当线程请求的栈深度大于虚拟机所允许的深度，则抛出StackOverflowError;如果虚拟机可以动态扩展，扩展到到无法申请更多的内存会抛出OOM。本地方法栈关于本地方法栈，这里可以拿上面刚讲到的虚拟机栈做一下对比。虚拟机栈为虚拟机执行Java方法而服务，本地方法栈则是为虚拟机使用到的Native方法服务。其余跟Java虚拟机栈并没有什么特别的区别。所以对应的异常抛出机制，跟虚拟机栈一致。Java堆至此你会发现，上面说到的三个区域：程序计数器，Java虚拟机栈、本地方法栈都是线程私有。但是跟上面三种不一样，Java堆是所有线程共享的一片区域，它随着一个Java虚拟机实例的创建而分配好。该区域存在的唯一目的就是存放对象，几乎应用中所有的对象实例都在这里分配内存（非绝对）。因为上面三种内存空间为线程私有，他们随线程生而生，随线程死而死，所以这三种空间一般不需要执行垃圾回收，所以我们我们通常说的垃圾回收大多都发生在Java堆。从内存回收角度讲，现在的垃圾收集器大都采用分代收集法。所以根据此可以把Java堆分为新生代和老年代对新生代又可以细分为Eden空间、FromSurvivor空间、ToSurvivor空间。根据Java虚拟机规范，Java堆可以处与物理上不连续的内存空间中。只要逻辑连续即可。一般的Java堆都被设计成可扩展的。如果堆中没有内存分配实例，并且堆也无法扩展时，将会抛出OutOfMemmoryError.方法区与Java堆一样，方法区（MethodArea）是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。Java虚拟机规范规定，该区域可以不实现垃圾回收。因为相对而言，这个区域垃圾回收行为比较少见，但是并非数据进入方法区就一直不回收了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。运行时常量池运行时常量池是方法区的一部分。这里先说说一般的class文件，即一个.java文件编译后成为字节码文件.class.Class文件中除了有类的版本，字段，方法，接口，等描述信息，还有一项信息是常量池。Class文件中的常量池用于存放编译期生成的各种字面量和符号引用。这部分内容将在类加载后存放在方法区的运行时常量池。这里对Class文件常量池和JVM运行时常量池进行一下区别。这俩是两个不同的概念，前者其实是一个物理上的概念，当我们的.java文件编译成.class文件后，该区域已经在.class文件中占据了固定的位置。这一点你可以通过查看具体的.class文件得到。而当这个class文件加载到JVM中后，Class文件常量池中的信息将会全部存放在JVM方法区的运行时常量池。所以前者是实实在在存在的，而后者是一个JVM中的内存区域，两者存在一个简单的对应关系。运行时常量池相对于Class文件常量池的一个重要特征就是前者具备动态性，运行时常量池可以在程序运行期间动态的把新的常量放入运行时常量池。参考JVM垃圾回收</li>
  <li>该篇文章主要分享记录一下自己对Java虚拟机这个概念以及Dalvik虚拟机的理解，同时也会对他们做一个简单的对比。对于Java虚拟机自己也在不断学习认识中，如果有什么描述有误的地方，欢迎指正。虚拟机从一开始学Java，我们就知道，我们写的所有的Java代码最终都会被编译器编译为以.class结尾的字节码文件，然后最终被Java虚拟机执行，从而得到我们想要的结果。这里说到的Java虚拟机是一种规范。这个规范由Sun公司指定，然后具体的设备上执行字节码文件的Java虚拟机可能不一致，但是这些虚拟机都必须遵守相同的规范。那目前主流的Java虚拟机有那些呢？具体可移步主流JAVA虚拟机。可以看出Sun公司开发的HotSpotVM是绝对的主流。Java虚拟机与Dalvik虚拟机的关系首先Java虚拟机是一个规范，由Sun公司制定，任何实现该规范的虚拟机都可以用来执行Java代码。比如说，你们公司对现有虚拟机的垃圾回收或者其他特性不满意，完全可以自己去按照JVM规范来开发一个自己的虚拟机，当然一般的公司或者个人几乎没有这么干的，毕竟这需要相当的技术实力或者业务场景。但是Android就这样搞了。由于Androd运行在移动设备上，内存以及电量等诸多方面跟一般的PC设备都有本质的区别，一般的JVM没法满足移动设备的要求，所以在开发Android过程中，Android团队一开始就必须打造一个符合移动设备的可以执行Java代码的虚拟机。这就是我们说的Dalvik虚拟机。JVM与Dalvik的区别到这里你会发现，其实Dalvik是一个更符合移动设备的用于执行Java代码的虚拟机，但又不是一个严格按照JVM规范的虚拟机实现，下面分别从执行文件格式等其他方面介绍一下他们的区别。格式JVM可以执行的文件是.class结尾的字节码文件，而Dalvik执行的是dex文件。但是按照JVM的规范，虚拟机只能执行.class文件，所以这里也印证上面抛出的那个结论，Dalvik并不是一个符合JVM规范的Java虚拟机。为什么Dalvik执行dex文件而不是.class文件，其实这里是Android专为Dalvik虚拟机做的一个优化。Java虚拟机执行.class格式的字节码。每一个Java文件对应一个.class的字节码文件，JVM在运行时为每一个执行到的类装载字节码。而Android设备上为了提高执行效率，在编译Android项目时，Android通过SDK提供的工具dex.jar会把所有的.class文件最终打包成一个.dex文件(不一定是一个)。BaseDalvik基于寄存器，而JVM基于栈，很明显，基于寄存器的Dalvik在速度方面优势会更明显。运行环境Dalvik经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik应用作为一个独立的Linux进程执行。独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。除了上面提到的，还有以下几点。Dalvik负责进程隔离和线程管理，每一个Android应用在底层都会对应一个独立的Dalvik虚拟机实例，其代码在虚拟机的解释下得以执行。dex文件格式可以减少整体文件尺寸，提高I/O操作的类查找速度。有一个特殊的虚拟机进程Zygote，他是虚拟机实例的孵化器。它在系统启动的时候就会产生，它会完成虚拟机的初始化、库的加载、预制类库和初始化的操作。如果系统需要一个新的虚拟机实例，它会迅速复制自身，以最快的速度提供给系统。Dalivk与ART虚拟机从AndroidL开始，Android开始启用了新设计的虚拟机ART。与Dalvik不同，在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器（JustInTime，JIT）转换为本地机器码，这会拖慢应用的运行效率。而在ART环境中，应用在第一次安装的时候，会使用设备上的dex2oat工具进行字节码转码，把字节码预先编译成本地机器码，使其成为真正的本地应用。这个过程叫做预编译（Ahead-Of-Time，AOT）。采用AOT策略后的好处显而易见，应用的启动速度会因此快很多，但是与此同时，应用的安装时间就会因为执行AOT操作而变长，但是相比之下还是非常值得。另外，ART的另一个缺点就是对存储空间占用变大。一般的字节码在编译转码后占用的空间大小比之前要增大10%-20%。除了AOT机制，ART另外一个显著的提升就是垃圾回收方面的提升。相比Dalvik虚拟机，ART虚拟机具有更高的回收性能。具体可以查看知乎的一个同学的回答，或者可以直接看官方的文档说明。总结Dalvik其实可以理解为一个专为移动设备优化过的JVM，它的大部分地方都遵守了JVM规范，其实那些不符合规范的地方，就可以理解为为移动设备做的优化工作。而ART是一个具有更高性能的Android虚拟机，从一开始他就是为取代Dalvik而来，它的AOT机制相比Dalvik的JIT机制使得应用有更快的启动速度。同时ART虚拟机在垃圾回收方面也比Dalvik更加高性能。附：JIT：Dalvik虚拟机运行App的机制，运行期实时翻译（JustInTime）。AOT：ART虚拟机对App运行的优化机制，它在应用安装时就提前（Ahead-Of-Time）做好了字节码到机器码的翻译工作。参考链接ARTandDalvik-官方文档ART和Dalvik的区别-知乎目前主流的Java虚拟机有哪些?Dalvik虚拟机和JVM的区别。Java里面的，Android里面的区别Java虚拟机与Dalvik虚拟机(简书)Android：ART优化配置（Mstar-6A648）-sheldon_blogs-博客园</li>
  <li>该篇文章主要分享介绍，如何使用一张资源图片为View设置具有按下效果的BackgroundDrawable.开源地址OneDrawable缘起前段时间在开发项目新版本的过程中，设计师出了一套项目的按下效果规范。规范大概是这样的。对于一般的按钮，按钮按下的效果只有两种不同的实现。1、按下后将前置背景图片变暗，具体就是在正常状态的drawable上面增加一层20%的黑色遮罩。2、按下后降低前置背景资源透明度，具体就是在按下时改变正常状态的drawable透明度为原来的70%。很明显，这套规范会带来以下好处。设计师在出图时只需要出一张图，然后只需要告诉开发人员对应的按下效果策略，这样可以减轻设计师的出图负担。客户端这边也是，不需要因为实现一个按下效果而导入两张资源图片，这样在减小包大小的同时也省去了客户端开发人员去写selector文件的麻烦。实现方案其实在之前的开发过程中，我也曾有过这样的思考，想怎么可以根据一张图来设置View的背景，并让他具有按下效果。一开始自然而然的想到了处理View的touch事件，然后在按下时动态的根据正常背景设置按下后的背景资源。但是后来觉得还是麻烦，而且一些时候一些View本身就需要处理touch事件，会造成冲突，所以当时也就一了百了。这次经过一些搜索，思考，最终使用StateListDrawable达到了了目标效果。StateListDrawable有一个方法addState用于设置不同状态下的drawable，包括按下、聚焦、不可用等等所有的状态。所以结合需求，这里只需要根据正常状态下的drawable计算出按下状态的drawable，然后设置给按下按下状态，就可以完美实现一套资源实现View的按下状态。具体实现方案已经说清楚了，实现其实很简单，代码如下所示。privatestaticDrawablegetBackground(@NonNullContextcontext,@DrawableResintres,@StatePressedMode.Modeintmode,@FloatRange(from=0.0f,to=1.0f)floatalpha){Drawablenormal=context.getResources().getDrawable(res);Drawablepressed=context.getResources().getDrawable(res);pressed.mutate();//根据不同的按下要求设置不同的按下drawablesetPressedStateDrawable(mode,alpha,pressed);finalStateListDrawablestateListDrawable=newStateListDrawable();//按下状态stateListDrawable.addState(newint[]{android.R.attr.state_pressed},pressed);//正常状态stateListDrawable.addState(newint[]{},normal);returnstateListDrawable;}根据不同按下模式，处理按下的drawableprivatestaticvoidsetPressedStateDrawable(@StatePressedMode.Modeintmode,@FloatRange(from=0.0f,to=1.0f)floatalpha,@NonNullDrawablepressed){switch(mode){caseStatePressedMode.ALPHA:pressed.setAlpha(convertAlphaToInt(alpha));break;caseStatePressedMode.DARK:pressed.setColorFilter(alphaColor(Color.BLACK,convertAlphaToInt(alpha)),PorterDuff.Mode.SRC_ATOP);break;default:pressed.setAlpha(convertAlphaToInt(alpha));}}下图为demo截图兼容问题后来有网友反馈在4.4的机型下按下效果失效，后来发现是因为Drawable的setColorFilter方法在4.4的手机上失效，后来采用了BitmapDrawable的方式解决，具体可以看代码实现，这里贴出最重要的一段代码。privatestaticDrawablekitkatDrawable(Contextcontext,@NonNullDrawablepressed,@PressedMode.Modeintmode,@FloatRange(from=0.0f,to=1.0f)floatalpha){Bitmapbitmap=Bitmap.createBitmap(pressed.getIntrinsicWidth(),pressed.getIntrinsicHeight(),Bitmap.Config.ARGB_8888);CanvasmyCanvas=newCanvas(bitmap);switch(mode){casePressedMode.ALPHA:pressed.setAlpha(convertAlphaToInt(alpha));break;casePressedMode.DARK:pressed.setColorFilter(alphaColor(Color.BLACK,convertAlphaToInt(alpha)),PorterDuff.Mode.SRC_ATOP);break;}pressed.setBounds(0,0,pressed.getIntrinsicWidth(),pressed.getIntrinsicHeight());pressed.draw(myCanvas);returnnewBitmapDrawable(context.getResources(),bitmap);}一些细节在设置按下状态的drawable时，Drawablenormal=context.getResources().getDrawable(res);Drawablepressed=context.getResources().getDrawable(res);这里的normal和pressed使用的资源res资源是同一个id。但是由于drawable在加载过程中，同一个res资源只要在内存中加载过一次,这个drawable对应的state就会保持一致，所以这里要对pressed进行可变设置。pressed.mutate();关于mutate方法的官方说明Thisisespeciallyusefulwhenyouneedtomodifypropertiesofdrawablesloadedfromresources.Bydefault,alldrawablesinstancesloadedfromthesameresourceshareacommonstate;另外需要注意的是，由于View的按下效果只有在设置了clickable为true时才可以看到效果，所以当你使用OneDrawable为View设置背景后却发现没有按下效果，你应该知道怎么办。最后，如果你发现还有什么问题，欢迎在issue或者评论区指出，也欢迎你把更好的方案PR上来。</li>
  <li>良好的开始是成功的一半，对于一个Android项目更是，一个好的项目基础架构可以对项目的后续发展有至关重要的作用。所以我们在项目开发之初，应该花费一些时间去调研、设计符合自己项目的基础架构。而且从项目长远的发展来看，这些时间花的非常值得。下面就从项目的方方面面出发，介绍一下自己搭建项目时的一些经验。当然个人水平经历有限，自己的分享可能有片面性和不足性，欢迎指正补足。代码质量保证项目开发是一个团体活动，每个人都有自己不同的技术风格以及代码风格，但是为了项目后续的可维护性、健壮性，我们需要项目开发过程中，尽早采用统一的编码风格和代码质量检测跟进，防止后续的代码管理变得混乱不堪。下面介绍几个已经被大家广泛采用的代码质量保证工具。CheckStyleFindBugsPMDAndroidLintCheckStyleCheckStyle是一个帮助开发者严格按照指定的编码规范标准编写代码的一个工具，它能结合AndroidStudio与相应的插件在开发过程中自动检测Java编写规范，以减少人工检测代码的成本。也可以使用Gradle通过task去检测代码是不是符合指定的规范。具体如何在AndroidStudio中使用，可以参考之前的一篇文章使用CheckStyle检查代码FindBugsFindBugs这个名字本身已经揭示了它的作用“FindBugsusesstaticanalysistoinspectJavabytecodeforoccurrencesofbugpatterns.”FindBugs是一个工具，它能通过静态分析方式扫描Java字节码，发现其中的可能出现bug的代码，它能发现一些常规的低级的错误，例如一些错误的逻辑操作，也能发现一些比较隐晦的错误。PMDPMD是一个非常强大的工具，它的作用类似Findbugs，但是它的检测扫描是基于源码的，而且PMD不仅仅能检测Java语言，还能检测其他语言。PMD的目标和Findbugsd非常的相似，都是通过定义的规则静态分析代码中可能出现的错误，为什么要同时使用PMD和Findbugs呢？由于Findbugs和PMD的扫描方式不一样，PMD能发现的一些Findbugs发现不了的问题，反之亦然。PMD可以发现程序中的无用变量、空的catch块、不必要的对象创建等。AndroidLint“TheAndroidlinttoolisastaticcodeanalysistoolthatchecksyourAndroidprojectsourcefilesforpotentialbugsandoptimizationimprovementsforcorrectness,security,performance,usability,accessibility,andinternationalization.”正如官网所说，AndroidLint是另一个静态代码分析工具,专门针对Android工程。AndroidLint除了对代码扫描，分析潜在问题之外，还能对Android的资源进行检测，无用的资源，错位的dip资源等。同时，AndroidStudio以及集成了lint，你可以很方便的使用。步骤如下。AndroidStudio-&gt;菜单-&gt;Analyze-&gt;InspectCode另外，你可以通过gradle脚步指定自己的lint规则，以及报告生成路径android{lintOptions{abortOnErrortruelintConfigfile("${project.rootDir}/config/quality/lint/lint.xml")//iftrue,generateanHTMLreport(withissueexplanations,sourcecode,etc)htmlReporttrue//optionalpathtoreport(defaultwillbelint-results.htmlinthebuilddir)htmlOutputfile("$project.buildDir/reports/lint/lint.html")}}代码质量保证工具终究只是一些辅助手段，如何在项目开发过程中，保持持续高质量代码的输出更多的要依靠开发者自身对自己的要求，以及团队长期的技术文化建设上。持续集成travisjenkinsflow.ci如果是开源项目可以使用travis进行持续集成，travis跟github结合的特别好。使用起来也比较简单，如果你的开源项目已经跟travis结合成功，你可以使用下面的bubble代码为自己的项目加一个bubble，方便在项目主页查看项目最新的编译状态。![BuildStatus](https://travis-ci.org/maoruibin/TranslateApp.svg?branch=master)效果如下如果是企业项目，还是自己搭建个持续集成工具比较好玩，嗯，就是Jenkins。你可以按照Jenkins的安装文档在自己公司的内网环境下安装Jenkins，然后就可以随意配置各种task。另外，前段时间发现另一个国内的持续集成工具也不错，是在线形式的，类似Travis，叫做flow.ci,比较有意思的是他有一个工作流的东西，比较好玩，而且跟fir天然支持。生产力/效率真实的团队项目开发是一个持续的过程，一个项目的生命周期有长有短，参与的人数有多有少，但即使比较短也可能要持续数月之久，所以一般的项目都需要花费不少时间精力。对于研发来讲，我们可以不关注效率方面的信息，使用最原始的工具、API通过刀耕火种的方式完成开发，其实Android刚流行的时候，我们的开发确实是这样过来的，各方面的工具，开源方案较少。但是经过10年的发展，Android开发生态已经有了长足的进步和完善，包括开发工具、开源方案都已经非常完善，所以有必要在开发中留意并使用一些已经被其他团队证明可行的方案技术以及一些生产力工具。下面列举一些对Android开发效率有提升的工具以及相关的东东。AndroidStudioTemplete项目开发过程中，随着开发框架的成熟，总会有一些代码经常重复性的编写，这时，你可以通过使用AndroidStudio的templete来快速生成代码。如新建Activity,现在大项目都会有一个BaseActivity,尽管AS也提供了Activity的模板，但是跟我们项目需要差别很大，所以，这时可以自定义自己项目的模板。其实模板的适用范围特别大，不仅仅是Activity所有一些重复性比较强的模块类代码都可以使用自定义模板，这里的想想空间比较大，结合项目中的一些成熟的开发框架，你可以使用模板去把一些重复性的工作用模板完成。至于如何自定义模板，网上的文章很多。神奇的AndroidStudioTemplate-Hongyang-博客频道-CSDN.NET参考链接android-guidelines/project_and_code_guidelines.mdatmaster·ribot/android-guidelinesAndroid-Studio-MVP-templateAndroidStudio插件下面列举一些自己常用的AS插件。GsonFormat首推GsonFormat，这个插件我在2015年开始使用，简直是神器。尤其是自己已经手工写了很久的实体类后，当时发现这个插件后，欣喜若狂，具体它是干什么的，简单说，就是帮助开发者快速将服务端返回的一个JSON实体字符串转化为Java实体类的AS插件。具体可以查看项目主页。zzz40500/GsonFormat:根据Gson库使用的要求,将JSONObject格式的String解析成实体ButterKnifebutterknife是JW主导开发的一个View注入工具。它使用注解简单明了的替换传统的findViewById，还可以简化事件点击的监听等等，更多使用介绍可以看官网或者之前的一篇关于ButterKnife的介绍文章。上面提到的这些用法只是让你提速，但真正意义的效率飞跃是使用它提供的AS插件-ButterKniferZelezny，使用他后可以让你的View实例化从此自动化，工具化，无需手动码代码。生产力/效率总结在开发中，个人非常注重生产力效率。因为你的效率提升意味着你在同样的时间里产出就比别人多，侧面体现了你的价值比别人大，而这仅仅是因为你比别人会使用一个工具，多么神奇的结论。使用工具后，在节省你工作时间的同时，从另一方面讲也是节省公司的人力成本，所以如果有工具可以提升自己的工作效率，那么我会非常乐意的分享使用它。另外，对于效率的追求没有终点，你应该花点时间和心思去收集和整理一些效率工具，从而使自己的工作生活更加轻松。其实，如果你关注过一些大公司的话，在大公司里甚至会有一个专门的部门用于研究生成企业内部的生产力效率工具。可想而知，生产力/效率是一个多么重要的话题。开源框架选择合适的开源框架可以有效的避免自己重复创建轮子，所以项目中针对一个应用场景恰当的使用一些开源的大家比较任何的开源项目可以让开发事半功倍。其实关于开源框架的选型，GitHub上已经有很多项目做了总结，并且总结的很全面UltimateAndroidReference下面是自己整理出来的开源框架选型指导。网络OkHttpRetrofit数据库LiteOrmLitePalsugargreenDAORealm事件总线EventBusOtto图片GlidePicassoFreso网络解析GsonJacksonFastJsonHtmlPaserJsoupLogloggertimberhugo调试stethoChuckTinyDancerAndroidPerformanceMonitorBlockCanaryExBattery-historian]Recovery(acrashrecoveryframework.)这里也有一篇国外的文章介绍了目前Android中比较有用的一些开发工具，具体可以查看AndroidDevelopmentUsefulToolsSharePreferenceAptPreferencesEsperandroTray路由框架ARouterAndRouterAndroid-Router技术文档在项目开发过程中，必然会涉及到团队成员的沟通，如何更好的沟通？QQ？微信？？对于一般的非技术性的事务，这些桌面沟通工具确实可以很便捷的完成我们的需求，但是对于我们开发者，大多时候需要沟通一些技术上的问题，对于技术上这种非常严肃的问题，如果只是在群里讨论，粘代码会很容易把答案淹没，无法形成一个长久的记录。所以，文档就显得特别重要。在实际开发中，不同的人负责的模块不一样，但是不论你负责那个模块，只要你的模块有可能为其他成员提供支持，那么你都应该写一份简单的使用文档，方便其他人在使用时，直接看你的文档就可以解决问题。不至于其他人在用到你写的模块时，缅甸的同事在项目中搜索你在什么地方使用了相关的API，然后大海捞针般的搜到相关的代码后，一边阅读你的代码一遍思考怎么在自己的业务场景中使用。直率点的同事可能不顾你现在是不是忙工作，直接会发消息给你，询问相关API的使用，然后你的工作遭到打断，马上指点如何使用自己设计的API。然后这样的事情，一遍遍的发生在开发过程中，不同的同事遇到同样的问题，每次都是直接去询问当事人。这是一种非常低效的开发模式。尤其是那种大项目，模块可能很多，这种问题也会很多。所以，如果大家在开发自己的模块时，使用文档把一些技术要点简单罗列出来，然后把文档放在一个统一的地方，大家以后有问题，直接找文档，如果文档还没解决问题，再去找负责人，是不是会节省很多沟通成本。关于文档，这里不仅仅是技术文档，开发中的文档有很多类型，下面列举一些文档。技术说明文档如上所述，就是典型的技术模块说明文档，应该包括简单明了使用说明以及一些特殊情况处理。规范说明类文档比如代码中的命名规范，提交规范等。下面是GitHub上自己的一些开源文档。ribot公司的代码规范LoranWong/Android-Code-Style:AcommonAndroidcodingstyle.可在组内推行的Android代码规范Blankj/AndroidStandardDevelop:安卓开发规范(updating)工具使用类文档比如项目中一些开发工具使用说明。常用信息检索类文档比如项目中的全局属性类介绍。其他类Commitmessage和Changelog编写指南-阮一峰的网络日志ruanyf/document-style-guide:中文技术文档的写作规范参考链接Android通用流行框架大全-Android技术漫谈-SegmentFaultAndroidStudio好用的插件-Android技术漫谈-SegmentFault从零开始的Android新项目11-组件化实践（1）|markzhai’shomecctanfujun/android-tips-tricks-cn:震惊！这么多的安卓开发Tips</li>
  <li>易剪是自己为了解决在手机上阅读文章时而开发的一个收集笔记内容的Android工具App，核心功能就是帮助用户在移动设备上快速剪贴自己感兴趣的文章片段。下载Fir下载地址酷安市场-易剪开发缘由当我们在手机上阅读文章时，对于自己感兴趣的片段，我们可能会想粘贴到便签或者印象笔记作为自己的笔记，方便日后查阅。类似的场景就像小时候读作文时，经常在旁边放一个小本子，看到别人作文中有写的比较好的排比句或者拟人句，我们常常会把这些句子摘抄下来，作为自己的摘抄笔记。在以前这不失为一种非常好的阅读习惯。长大了，我们再也不需要去写作文了，但是我们依旧会阅读，不过我们把大量的阅读时间都花在手机上，而不是书本上，这就带来了一个问题，如文章开始所言，我们在阅读文章时，看到感兴趣的片段大都会复制粘贴在印象笔记或者便签。但是频繁的切换应用无疑对沉浸式的阅读体验是一种非常大的破坏。期望能不能通过一种简单的方式做到及时剪辑，统一保存，而且无需切换应用，如下gif图所示，这就是易剪所实现的功能。通过易剪，可以在当前页面即可完成片段剪贴的功能，无需切换到其他App。它会把每次选择的内容不断的在同一份剪报里进行追加，当你阅读完成后，你再安心打开易剪，即可看到自己的剪辑结果，如下所示。在这里你可以对剪报做二次加工，发送到印象笔记或者删除无用段落，你都可以在这里完成。Note这里6.0以下的手机，因为不支持自定义文本操作按钮，所以长按文本后，不能在文本操作栏找到追加到剪报的Action,这时你可以在长按文本后，选择文本操作栏上面的分享按钮，然后选择易剪，同样可以达到同样的目的。关于作者咕咚，Android开发者，咕咚翻译作者。个人站点gudong.sitegithubmaoruibin微博大侠咕咚</li>
  <li>该篇文章主要讲解Android6.0设备上自定义文本操作栏。通过以下文章你会学习到以下几点。什么是Android设备上的文本操作栏如何在Android6.0设备上为自己的App自定义文本操作首先说说什么是Android设备上的文本操作栏。文本操作栏我们在平时使用手机的过程中，总是避免不了去操作一些文本，比如常见的复制、粘贴等功能。一般我们只需要长按输入框内或者网页上的文本，系统即可弹出一个文本操作栏，上面会显示复制、粘贴、剪切等操作按钮，如下图所示。这就是文本选择操作栏，但是一直以来，这个操作栏上面的按钮都是系统级别的，通过一般的方法是不能去自定义该操作栏上面的按钮的。比如说，你做了一个翻译App，为了更好的用户体验，你想让用户长按英文单词后，在这个系统文本操作栏上显示一个自定义的翻译按钮，然后用户点击这个按钮后，就可以直接查询网络释义，显示单词解释，那将是多么友好的用户体验。但是这在6.0之前的Android设备上都是无法实现的，因为Android没有提供相关的API供开发者自定义文本操作按钮。直到Android6.0，Android开始支持在文本操作栏上自定义操作按钮，开发者可以根据自己App的需要，为自己的App自定义文本操作按钮。这不，去年年初我发布了一款自己开发的软件—咕咚翻译，咕咚翻译是一个手机上用于划词翻译的开源App，长按文本后选择复制操作，咕咚翻译即可以悬浮窗的形式展示单词释义，如下所示。后来发布市场不久后，就有人在市场上建议我适配6.0的新API。当时还不知道Android6.0已经可以支持自定义文本操作按钮，但是一经提示，我觉得这个API确实很适合咕咚翻译的应用场景。之前的咕咚翻译，用户都是选择复制操作后，App监听系统粘贴板然后进行查词，算是通过一种取巧的方式完成了划词翻译功能。但是如果使用自定义文本操作Action，那么用户是使用时可能更加容易接受这样的操作。所以后来便实现了自定义文本操作栏Action。自定义文本操作栏按钮注意：以下操作只支持Android6.0及以上设备首先，既然自定义文本操作栏按钮，那么拿到用户选择的文本后，就需要一个可以处理文本的组件。这里Android定义使用一个Activity去完成这个处理操作。注意，可能有人会想使用Service处理获取到的文本，这里Android对这个处理组件做了限制，只能使用Activity。创建处理文本的Activity这里我们给处理文本的Activity起名叫ProcessTextActivity，接着创建Activity，比较简单。这里通过一个名为Intent.EXTRA_PROCESS_TEXT的key来获取用户选择的文本，可以看到获取文本很简单。拿到文本后，这边就可以对文本做操作了。但是别忘了，Android中每个使用到的Activity都需要注册，但是这个Activity的注册跟一般的Activity不一样。如下所示注册自定义文本处理Activity可以看到上面跟一般Activity注册不一样的地方就是IntentFilter的配置。这里的配置写法是固定的，表示这个Activity用于处理用户从文本操作栏点击自定义按钮后的操作。然后自定义的文本选择操作就完成了。至于拿到文本后怎么操作，那就看自己App的需求了。示例中的咕咚翻译是拿到文本后去请求公开的翻译API去翻译文本，然后以悬浮窗的形式显示出来，如下所示。当然，由于自定义文本操作栏按钮是Android6.0设备上才有的API，所以6.0之前的设备上咕咚翻译还是采取了监听粘贴板来达到划词翻译的效果。如果对源码感兴趣，因为咕咚翻译是一个开源App，你可以随意查看源码实现。链接如下https://github.com/maoruibin/TranslateApp可能还有一些细节文中没有提到，大家可以查看参考链接对应的一篇译文。参考链接自定义文本操作栏的方法文档地址使用ACTION_PROCESS_TEXT来创建自定义的文本选择操作-泡在网上的日子</li>
  <li>算是17年第一篇文章，初衷就是简单介绍下用xml配置设置界面，为自定义设置界面UI做一个铺垫。场景介绍为了更好的用户体验，现在的大多数的应用都会提供一个设置界面，供用户去设置一些应用属性，比如用户名、昵称等信息的修改，或者还会有一些消息开关等都会在设置界面中完成。如下所示就是一个常见的设置界面截图（from咕咚翻译）类似这样的设置界面在一个应用中都会或多或少的存在。对于开发者而言，如何快速开发这样的设置界面呢？如果他对Android提供的设置API不了解，可能会自然而然的想到使用layout去画出来。然后在Activity中实例化每个item对应的view，接着处理对应的click、check等事件。但是这样有很多不足和麻烦。你需要自己编写布局文件，设置样式，还需要处理设置数据的本地存储逻辑。其实，Android早就提供了相应的设置API可以方便开发者快速开发设置UI。这就是现在要说的PreferenceActivity/PreferenceFragment。更多关于设置相关的官方介绍可通过Setting查阅。建议直接看官方文档，比这里更加全面。主要API介绍见名知意PreferenceActivity偏好设置ActivityPreferenceFragment偏好设置Fragment这俩是Android系统提供的两个跟设置相关的API组件，使用他们就可以方便快捷的开发出具有统一体验的设置UI。鉴于灵活性，大多数时候个人使用·PreferenceFragment较多，官方也推荐使用Fragment。开发指南这部分建议直接看官方文档，很清晰。下面罗列自己简单总结的一些点。几个要点不同于一般的Fragment,PreferenceFragment的布局是通过在XML文件中声明的 Preference 类的各种子类构建而成，而不是使用 View 对象构建用户界面。您必须将XML文件保存在res/xml/目录中。尽管您可以随意命名该文件，但它通常命名为preferences.xmlXML文件的根节点必须是一个PreferenceScreen元素。您可以在此元素内添加每个Preference。在元素内添加的每个子项均将作为单独的项目显示在设置列表中。如下所示就是一个常规的设置配置文件。&lt;?xmlversion="1.0"encoding="utf-8"?&gt;&lt;PreferenceScreenxmlns:android="http://schemas.android.com/apk/res/android"&gt;&lt;CheckBoxPreferenceandroid:key="pref_sync"android:title="@string/pref_sync"android:summary="@string/pref_sync_summ"android:defaultValue="true"/&gt;&lt;ListPreferenceandroid:dependency="pref_sync"android:key="pref_syncConnectionType"android:title="@string/pref_syncConnectionType"android:dialogTitle="@string/pref_syncConnectionType"android:entries="@array/pref_syncConnectionTypes_entries"android:entryValues="@array/pref_syncConnectionTypes_values"android:defaultValue="@string/pref_syncConnectionTypes_default"/&gt;&lt;/PreferenceScreen&gt;使用配置文件publicstaticclassSettingsFragmentextendsPreferenceFragment{@OverridepublicvoidonCreate(BundlesavedInstanceState){super.onCreate(savedInstanceState);//LoadthepreferencesfromanXMLresourceaddPreferencesFromResource(R.xml.preferences);}...}然后，正如您对其他任何 Fragment 的处理一样，您可以将此片段添加到 Activity。例如：publicclassSettingsActivityextendsActivity{  @Override  protectedvoidonCreate(BundlesavedInstanceState){    super.onCreate(savedInstanceState);    //Displaythefragmentasthemaincontent.    getFragmentManager().beginTransaction()        .replace(android.R.id.content,newSettingsFragment())        .commit();  }}至此，启动SettingsActivity就可以看到一个设置界面了。原理分析这里简单说下背后的原理。PreferenceFragment和PreferenceActivity的布局本身包含一个ListView，使用addPreferencesFromResource方法后，PreferenceFragment他们会去解析xml文件中定义的Preference对象，并把它们实例化，然后通过Adapter的形式填充到ListView。然后就是我们看到的设置界面了。关于这篇文章属于技术介绍类文章，主要是为下一篇文章《自定义设置UI》做铺垫，其实没什么干货可写的，因为官方文档已经很详细，所以文章一开头，我也建议直接去看官方提供的文档，现在已经有很好的中文版本了，而且讲得很详细，很权威。</li>
  <li>去年不知什么时候，自己Mac上的G键坏了，一开始只是不灵敏，到后来直接失效。很无奈，所以一开始去了苹果店，但是工作人员告诉我，是物理键损坏，只能换键盘，我问换键盘多少钱，3000。。。好吧，我还是回来了。后来自己试着用软键盘解决了这儿问题，但是体验还是相当差啊，你需要在打G的时候，用鼠标去屏幕软键盘选择G别提多麻烦了。不过到目前为止，我已经这样干快5个月了。说到这，真有点心疼我的手。其实，16年写文章少，和这个事有很大关系，毕竟这个写作体验真的很差劲。我在写ViewController那两篇介绍文章时，简直难受的要死，后来一部分文章是在媳妇电脑上完成的。直到今天，因为有空写点东西，但是G键依旧是一个问题，是在忍不了了。所以就下定决心去网上找答案。终于找到了这个链接http://bbs.feng.com/read-htm-tid-7973153.html其实之前也搜到这个链接，但是没仔细看，这次静下心来，发现了keyremap4macbook这个关键字，然后就发现了这个Mac上修改键盘映射的神器。友情提示：以下链接需要科学上网keyremap4macbook不过官网提供的版本不支持MacSierra版本，如果要用需要去下载这个版本。Karabiner-Elements其实这在它的官网也有介绍macOSSierrasupportstatusKarabinerdoesnotworkonmacOSSierraatthemoment.WearedevelopingKarabiner-ElementswhichprovidessimplekeymodificationformacOSSierraatfirst.(Karabiner-ElementsworkswellonmacOSSierra.Weareworkingonfixingseveralremainingissues.)We’llstartupdatingforthefullfeaturedKarabinerforSierraafterKarabiner-Elementsiscompleted.https://github.com/tekezo/Karabiner-Elements最终的示意图。感想有时候，不是你完成不了一件事，而是你没有完成这件事的决心。其实一开始我也试着去找过修改键盘映射的软件，但是总是找一会没找到就放弃，直到这次，我觉得我再不能忍受用虚拟键打G了，所以决心找，后来发现其实不难找到，遂作此文。</li>
  <li>不知不觉，就已经2017了，时间飞快，2016很短暂，但是却很丰富，却也不想重来。在16年三月时我最终离开了我的上家公司，尽管离开的过程有点不愉快，但是离开是一个2016做的第一个正确的决定。同时也是在三月初，我发布了自己开发的咕咚翻译，一个划词翻译App，从一开始推出就得到了很多同行的支持，自己在这个过程中也认识了一个非设计专业的UI设计爱好者，他帮我完成了咕咚翻译的1.0UI设计，我也打鸡血式的快速迭代了1.0，后来发布到市场，好评如潮，后来尝试加入了打赏功能，没想到一开始的一段时间，每天都能收到来自不同用户的打赏，不论多少，我都觉得这是一件有意义的事。在发布咕咚翻译后自己认识了很多同学，包括给咕咚翻译贡献源码的支付宝的一个同学，后来也认识了今日头条的一位同学，等等，后来在找工作时也充分利用这些资源，找内推，很感谢他们的支持。但最终，我去了墨迹天气。从一进入墨迹，墨迹的Android就正巧在进行项目重构，所以从3月末到墨迹，一直到7月，自己一直在做重构相关的事，不过基本是功能重构。重构的过程中思考良多，我还是喜欢写框架，因为写框架更能锻炼你的大局观，同时也要求你需要足够细心。后来在10月，因为项目存在两个网络框架的缘故，跟leader讨论后，决定统一为一个，然后自己负责了整个网络框架的重构整合。然后自己用了一个月时间，还算顺利的完成了重构，但是整个过程中自己也遇到了很多问题和挑战，这里就不一一列举了，如果可以，我觉得后续可以专门写一篇文章，记录一下重构的过程。重构完成上线后，一直没有爆出什么异常问题，这让我很开心，因为在重构过程中，由于之前代码的耦合性，所有的网络请和业务代码是严重耦合的，所以所有和网络相关的业务代码我也做了相应的更改。一直很担心这块会出现问题，比较修改的内容太多。不足写的文章变少了。主要原因是工作开始变得很忙，而且生活中的事情也变得多起来，所以技术方面输出偏少了，也许这是开发者都会经历。期许多读书。我觉得微信读书是个非常不错的读书软件，推荐。</li>
  <li>ReView是一个用于帮助程序员、设计师方便查看字体大小以及颜色等属性的View组件集合，这篇文章简单介绍一下ReView的开发初衷及用途。问题在日常开发过程，程序员一般都需要根据设计师的设计图以及标注图来进行UI开发，一般来说，设计师往往会在标注图上标注清楚每个View的大小以及字体颜色等等属性，我们开发者需要严格按照设计师的标注进行界面开发。开发完成后，设计师往往会review我们的实现效果，这时如果设计师感觉到有一个TextView好像字体小了点，跟他标注的有出入，而且字体颜色也有点浅，这时也许他就回过来找你理(si)论(bi)，然后对你说，你这个字体大小好像不对啊，看上去有点小，你是不是搞错了.这时，在没有任何辅助工具的情况下，只能默默找到对应的layout文件，然后查看xml文件，找到具体的View属性设置，看是不是跟字体大小或者颜色跟标注有出入，而且你还要考虑代码中动态设置字体大小颜色的可能性，不论最终结果如何，整个过程都显得效率低下，一点不高效，这些事有没有更好的解决方式呢？如果能让View显示自己的大小、颜色，这个问题不就解决了吗？解决方案如下图所示这就是自己最近开发的一个View组件ReView。他可以帮助你查看当前View的字体大小以及颜色，目前只支持TextViewButtonImageView这三个View。由于gif图质量一般，效果看的不是很明显，推荐下载示例demoAPK查看。下载地址也可扫码下载推荐用法你可以在项目中增加一个开关用于控制是不是启用这个高级属性，正常的开发模式下，你不需要使用这个功能，只有在特定场合下，如文章一开始说到的，设计师都找到你头上了，这种时候你直接打开你自己定义好的控制开关，秒杀设计师，”哼，我的字体木有任何问题！！就是这么叼！”，当然也不排除打自己脸的时候。当然，你可以可以直接把这个开关告诉设计师妹妹，他们review时直接打开开关就可以方便的看到View的字体大小，如果你字体设置的有问题，她直接告诉你那个View有问题，省的你自己再去layout文件中找了。这也是为什么叫ReView的原因。项目已开源，具体使用方法可以查看项目主页介绍，如有问题，欢迎issue或者评论。</li>
  <li>本人博客地址http://gudong.site本文简书地址:http://www.jianshu.com/p/e70c1478cd9eViewController是一种界面开发组件化的实现方式,利用它可以将一些复杂的UI界面开发组件化,从而更好的组织代码结构,从而提高开发效率,降低维护成本。不同于Fragment，ViewController更加小巧、灵活、易控制，代码也超级简单，目前只有一个不到100行的类。目前项目已经开源，项目地址：ViewController介绍关于ViewControler这种思想的介绍,也可以查看上一篇文章,Android复杂界面开发实践之ViewController:前言在日常开发中，当我们看到如下的UI原型时，在实际编码实现过程中，通常我们会把所有的布局先用xml实现，然后在Activity中编写所有的UI操作逻辑。这里，稍微思考下，这种方式的开发会有什么弊端。所有的UI元素都需要定义在同一个类中，所有的UI逻辑操作也都发生在同一个类里，在加上一些业务逻辑，这个界面的代码会在不断迭代的过程中越来越难保持clean.但是使用ViewController这种思想后，你可以把页面逻辑按UI块做拆分，进行组件化开发，最后在Activity中只需要把组件进行组合即可。下面是一张ViewController示意图，如下所示。如上图所示，现在把界面拆分为了四个ViewController，每个ViewController管理自己的一组View集合，这样就巧妙的把原本需要写在Activity代码分发到了不同的ViewController中去。至于代码如何分发，可以查看项目主页Readme，或者直接看源码。使用具体如何使用，请移步项目主页，那里有详细的介绍，因为代码很简短，如果有兴趣，建议直接看源码。适合ViewController的情形首先，不是所有的界面都适合用此种方式去开发，一些界面从设计之初就是浑然一体的，咱们没法做拆分，就没法使用，当然也没必要使用。但是比如示例中的房屋详情设计，就特别适合使用ViewController，因为他可以很容易的让我们去划分程序概念上的块。如上所述，在合适的地方使用ViewController，优点就显而易见。优点界面开发组件化，解决Activity/Fragment中UI代码臃肿问题。灵活的UI开发，同一组件可在多处复用，从而做到代码重用。易维护，开发简单。作者个人主页：咕咚新浪微博：大侠咕咚</li>
  <li>本人博客地址http://gudong.site本文简书地址:http://www.jianshu.com/p/e3f86d5a4474首先说明的是ViewControler并不是Android中存在的一个组件，而是在技术实践中总结创造出的一个开发理念，这是一种业务开发过程中的UI模块化思想的体现，依附于现成的Activity或者Fragment而存在。在特定的场景下使用ViewControler，会使你原本复杂的界面开发逻辑变得清晰明了,易于维护。下面进入正题。场景介绍先简单介绍一种常见的界面开发情形。示例在我们日常Android开发过程中经常会看到类似下面这样的UI界面。如下，这是一个普通的房屋详情页面。一个简单的房屋详情示意界面在实际的开发中，这种看上去长长的详情界面比比皆是，上面只是自己简单用画图板画的一个房屋详情示意界面。简单介绍下这个界面。如图所示，最上面是一个用于展示房屋图片的画廊区域，下面是房屋基本信息展示块，下面是房屋最近几月的价格走势图，下面是房屋评论，实际开发中，下面可能还会有各种各样的功能模块，如户型区域之类的。总之，一般的详情页大都很长，而且页面里可能会有各种各样的View元素，上面的示意图还好，整体就是四个View块，还不算太多，但是实际开发中，我们拿到的设计图可能比这长多了。从产品角度详情页就是这样，大而全，用户就是要看到最详尽的信息展示，但是具体到编码实现时，我不知道大家遇到这样的页面后会怎么编码实现。其实在写这篇文章时，我特别想知道大家在实际开发这样的长页面时会采用什么样的方式去开发，如果你有自己独特的实践方法，欢迎在评论区评论。一般做法通常，按照一般的想法，尽管这个页面比较长，但它依旧是一个普通的不能再普通的Activity或者Fragment，具体要开发这样的界面，先写好Layout文件，然后在Activity中初始化View、接着处理业务逻辑。问题对于上面说到的一般做法，应对实际开发中80%的界面开发都没有特别大什么问题，但是，如果是上面提到的详情界面开发，就会有如下的问题。由于这个界面比较长，我们在写layout时可能就会发现一个问题，layout文件太复杂了，如果界面布局比较简单还好，但是只要复杂点，这个layout就会变得异常复杂，相信对大多数开发人员都有过类似的体验，当layout变得复杂，后续的UI调试或者需求变更，都会变得很痛苦，你需要在layout文件内定位到合适的位置，然后调试或者修改。当然，说到这里。你可能会说用include后者merge标签啊，当然可以，假设你使用了include标签已经解决了layout文件过于复杂的问题，那我们接着讨论业务逻辑代码的问题。气喘吁吁的写完了layout，终于可以写会业务代码了，我们开心的切换文件到具体的activity，准备进行具体的业务代码开发，但面对这样的长页面，单单申明View成员变量，就需要申明一大串，接着你要处理各中View的初始化以及更新，还可能要处理数据变化等等逻辑，详情页的逻辑会变得越来越复杂。对于这样的详情页面，可以预见的是，代码会超级多。面对这样的页面，如果你是一个新人，后续需要你负责开发迭代，不得不说是一件很痛苦的事，自己也经历过，当你为一个复杂页面增加新功能，或者修改bug，你往往先需要理解一下整个页面逻辑，接着才可以修改。没有人会喜欢阅读动不动就两三千行的Activity代码的。Activity两三千行？？这一点也不夸张。思考到这里，面对这种稍微复杂的页面开发，你已经发现用这种最原始的开发方式暴露出的问题了，代码堆积问题，维护问题。现在不仅layout文件管理起来麻烦，更重要的是Acticvity里的代码也变得难以维护。一般的，我们遇到这种问题可能会持有两种态度。一：既然别人能开发的出来，我就可以维护，就是稍微费劲点，多读几遍代码，还是能看懂的，加班加点还是可以开发完的，只要完成，以后爱谁开发谁开发，我再也不碰了。典型的得过且过心态。另一种：灵机一动上MVP，MVP为解耦而生，是时候祭出MVP了。嗯，现在的情形，使用MVP确实可以解决Activity臃肿的问题，使用MVP后可以把DetailActivity中的业务逻辑代码都移到对应的Presenter中去，Activity中剩下的只有view操作方法或者监听方法。这样Activity确实瘦了不少。但是这不是解决问题的根本，Layout文件依旧很复杂，同时Activity中虽然把业务逻辑代码成功迁移到了Presenter中，但是很多view的操作逻辑代码还是在Activity。那说了这么多，到底有什讲么办法可以解决上面提到的问题！终极大招模块化—将一个大的复杂界面拆分为若干子界面模块，这里需要通过一种恰当的代码组织方式去帮助我们实现一个子界面模块，这种所谓的恰当的模式就叫ViewController，通过ViewController我们可以把一个布局和业务逻辑封装为一个模块，Activity只需要拿到这个模块的实例，就可以操作这个模块。在ViewController的帮助下，我们面对这种复杂页面，只要做好模块划分，那么每一个模块对应一个ViewController实例，Activity或Fragment只要持有他们的集合，就可以方便的操作控制他们。有木有很灵活，很轻量。当你真的使用它之后，你会发现他带来的便利其实不仅仅实现了模块化。特别感谢之前的Leader对ViewController这种思想给予最初的启发和引导。关于开源目前代码已开源，项目地址。</li>
  <li>今天终于有时间可以更新一下博客了。之前，一次偶然的机会，在网上看到黄玄的博客，也就是现在自己博客的风格，第一眼便喜欢上了这种风格，不论是大背景的Header还是侧边栏的设计，都是自己非常喜欢的设计，但是苦于自己前端能力薄弱，自从去年选择了一个Jekyll的主题后，能做的也只是一些简单的修建，如果要按照自己的想法去设计一些个性化的feature还是太难了。直到遇到这个博客风格，一见如故，所以在今年3、4月份的时候，就果断换了。这里顺便放一张上一版博客的旧照。整个切换过程还是挺顺利的，无非是一些配置、图片资源的替换，没有花费太多时间就搞定了，中间遇到了一些前端的问题，最终也通过作者同学的热情解答很顺利的解决了。但是，后来博客上线一段时间后，一个同学跟我反映，多说评论系统的发送按钮背景有问题，默认是白色的，这样会让很多人找不到按钮，就会导致别人无法评论。后来我看了也确实是，但是从那时开始，自己已经忙的要死要活，根本没时间去改这个问题了，这同时也导致博客的留言从此一落千丈，到现在为止，也只有两个同学的留言，达达，androidmalin,这可以从博客首页的最近留言中看到，真不知道你俩是怎么找到【发表】按钮的，对你们执着点赞，很多好友估计因为找不到发表按钮，根本不会多看两眼就离开了，对此，自己也很抱歉，这么久了，博客的小bug一直也没有改！直到今天，自己也终于可以坐在客厅，悠闲的拿起本本，做点工作之外，生活之外的事了，所以第一件事就是把那个发表按钮颜色给恢复回来。其实方法很简单，改css而已，不过这个博客使用了Less，所以需要借助Grunt才能让css更改生效，这在那个issue中也提到了，总之更改很顺利。想想过去的这段时间，自己感触还是挺多的。加班.加班.加班.加班.加班.加班……从三月初来了新东家后后，正好赶上项目重构，no应该是重写，自己便进入了新项目的重写状态，从老代码找接口，然后写新项目。后来自己不知不觉就给自己挖了几个大坑，让后后知后觉的跳了下去，从此代码写的不亦乐乎，但是在重写代码，重新架构也让自己最终的交付出了很多问题，UI的bug、功能上的bug…测试的妹子都为我着急，自己的bug数量也一直名列前茅。后来我只能这样安慰自己，做的越多，错的的越多啊！其实这和写代码一个道理，一个函数代码写的越少，出错的可能性也就越小。同样是做事，做的越多，出错的可能性也就越大。不过总归来说，这段时间的工作还是收获不小，知道了自己的薄弱点，以及一些缺陷，这也是未来需要加强的部分。相信以后会越来越好。上面的都是工作，生活中，这段时间也是没少折腾！生活不止眼前的苟且，还有诗和远方。诗和远方…远方…</li>
  <li>首先说点关于这篇文章的题外话。公司项目重构，我建议老大使用ButterKnife,因为自己使用了很久，而且自己跟周边的同事演示了一下ButterKnife的功能，都觉得很赞，所以就想自己要不彻底调研一次ButterKnife，包括用法以及源码。最终我给组长的结果是这东西可用，也没有什么太大的性能问题，但是最终还是被老大给kill掉了，后来也没有理论过老大，好吧，那就继续findViewById吧。但是作为自己当时的记录，这里还是把写在内部博客系统的文章发出来，没有什么技术含量，但也不想一直就搁置在哪里。好了，进入正题。ButterKnife项目源地址：https://github.com/JakeWharton/butterknife具体介绍也可查看项目主页。介绍ButterKnife是什么，下面是Github上的原文介绍FieldandmethodbindingforAndroidviewswhichusesannotationprocessingtogenerateboilerplatecodeforyou.翻译过来就是说用注解处理器为程序在编译期生成一些样板代码，用于把一些属性字段和回调方法绑定到Android的View。描述可能不好理解，但是只要一看例子，相信一眼就能看懂他是干什么的。1、实例现在需要做一个登录页面，页面很简单，两个输入框，一个登录按钮，点击登录、获取输入框数据，然后执行登录逻辑。布局代码如下：&lt;LinearLayoutandroid:layout_width="match_parent"android:layout_height="wrap_content"android:padding="16dp"android:orientation="vertical"&gt;&lt;EditTextandroid:id="@+id/editText"android:layout_width="match_parent"android:layout_height="wrap_content"android:hint="用户名"/&gt;&lt;EditTextandroid:id="@+id/editText2"android:layout_width="match_parent"android:layout_height="wrap_content"android:ems="10"android:hint="密码"android:inputType="textPassword"/&gt;&lt;Buttonandroid:id="@+id/button_confirm"android:layout_width="match_parent"android:layout_height="wrap_content"android:text="登录"/&gt;&lt;/LinearLayout&gt;然后在LoginActivity我们通常会这样写代码，如下所示。publicclassLoginActivityextendsAppCompatActivityimplementsView.OnClickListener{EditTextmEtUserName;EditTextmEtPassword;StringmErrorInfo;@OverrideprotectedvoidonCreate(BundlesavedInstanceState){super.onCreate(savedInstanceState);setContentView(R.layout.activity_main);mErrorInfo=getString(R.string.error_info);//初始化ViewmEtUserName=(EditText)findViewById(R.id.editText);mEtPassword=(EditText)findViewById(R.id.editText2);ButtonloginButton=(Button)findViewById(R.id.button_confirm);//设置按钮监听loginButton.setOnClickListener(this);}@OverridepublicvoidonClick(Viewv){switch(v.getId()){caseR.id.button_confirm:Stringusername=mEtUserName.getText().toString();Stringpassword=mEtPassword.getText().toString();login(username,password);break;}}}上面的代码没有任何问题，但是如果遇到一个布局界面中有很多View的情况时，你可能需要写一大段的findViewById()，另外，如果有很多按钮的点击事件需要处理，那么你也需要写一大堆的setOnClickListener(),如下所示。title=(TextView)view.findViewById(R.id.tv_title);bannerIcon=(RecycledNotImageView)view.findViewById(R.id.iv_banner);contentTitle=(TextView)view.findViewById(R.id.tv_content_title);contentDesc=(TextView)view.findViewById(R.id.tv_content_desc);perPraiseCount=(TextView)view.findViewById(R.id.tv_vote_agree_percent);unPerPraiseCount=(TextView)view.findViewById(R.id.tv_vote_not_agree_percent);praiseBtn=(RecycledNotImageView)view.findViewById(R.id.iv_vote_agree);unPraiseBtn=(RecycledNotImageView)view.findViewById(R.id.iv_vote_not_agree);wordLeft=(TextView)view.findViewById(R.id.tv_vote_agree);wordRight=(TextView)view.findViewById(R.id.tv_vote_not_agree);wordMid=(TextView)view.findViewById(R.id.tv_vote_num);animationLine=(VoteView)view.findViewById(R.id.vv_vote);mRlVoteResult=(RelativeLayout)view.findViewById(R.id.rl_vote_result);mLlVoteAgree=(LinearLayout)view.findViewById(R.id.ll_vote_agree);mLlVoteNotAgree=(LinearLayout)view.findViewById(R.id.ll_vote_not_agree);mSkinSelectorBack.setOnClickListener(this);mLocalRbtn.setOnClickListener(this);mOnlineRbtn.setOnClickListener(this);mDiscoverRbtn.setOnClickListener(this);mViewPager.setOnPageChangeListener(this);perPraiseCount.setOnClickListener(this);contentDesc.setOnClickListener(this);其实，如果快捷键用得好，写这些代码倒也挺快的，用Ctrl+D的快捷键可以方便的快速复制,不过你在享受了Ctrl+D的高效后，蛋疼的事就接踵而至，你可能还需要在快速复制后一个个的修改强转的类型，相信有过同样经验的你，一定知道我的意思。但是时间久了，你有时可能回想，有没有办法可以简化这些操作啊，毕竟他们的重复性太强了。好，ButterKnife该登场了，看看使用ButterKnife后的LoginActivity是什么样子。classLoginActivityextendsActivity{@Bind(R.id.user)EditTextusername;@Bind(R.id.pass)EditTextpassword;@BindString(R.string.login_error)StringloginErrorMessage;@OnClick(R.id.submit)voidsubmit(){//TODOcallserver...}@OverridepublicvoidonCreate(BundlesavedInstanceState){super.onCreate(savedInstanceState);setContentView(R.layout.simple_activity);ButterKnife.bind(this);//TODOUsefields...}}现在，可以翻回去看看原来的LoginActivity是怎么写的，对比后，你会知道ButterKnife都做了什么。现在的LoginActivity，已经完全不存在findViewById了，取而代之的是一个注解@Bindusername=(EditText)findViewById(R.id.editText);---&gt;@Bind(R.id.user)EditTextusername;也找不到setOnClickListener,以及对应的onClick回调，取而代之的是一个简单的@OnCLick注解loginButton.setOnClickListener(this);@OverridepublicvoidonClick(Viewv){switch(v.getId()){caseR.id.button_confirm:Stringusername=mEtUserName.getText().toString();Stringpassword=mEtPassword.getText().toString();login(username,password);break;}}—&gt;@OnClick(R.id.submit)voidsubmit(){//TODOcallserver...}当然，上面只是列举了最常用的两个场景。可以看到，使用ButterKnife后，代码量少了不少。而且使用注解的方式，也很形象。@Bind(R.id.user)EditTextusername;就是把R.id.user这个id绑定到了username这个对象。理解起来也很好理解。上面的实例只是列举了ButterKnife最常用的两种情形，下面详细列举一些具体的使用场景2、ButterKnife用法/使用场景1、绑定Activity中的View如上所示。classLoginActivityextendsActivity{@Bind(R.id.user)EditTextusername;@Bind(R.id.pass)EditTextpassword;@OverridepublicvoidonCreate(BundlesavedInstanceState){super.onCreate(savedInstanceState);setContentView(R.layout.simple_activity);ButterKnife.bind(this);}}注意，这里需要在Activity的onCreate中手动调用ButterKnife.bind(this);这个方法，注解才能生效。另外，这句代码，一定要在setContentView之后调用，否则Activity中的layout都没有加载到内存中来，你叫人家那里去找layout中的view，皮之不存，毛将焉附。只要记清楚这点，就没什么问题。2、绑定点击事件@OnClick(R.id.submit)publicvoidsubmit(Viewview){//TODOsubmitdatatoserver...}这里的方法名没有任何限制，只要你指定了@OnClick后面的id,就表示下面的方法体会在这个id对应的View被点击时调用。所以这里的方法名你可以任意起，想怎么写怎么写，另外方法的参数是可选的，你可以不填。@OnClick(R.id.submit)publicvoidsubmit(){//TODOsubmitdatatoserver...}当然，这里也可以指定具体的View类型@OnClick(R.id.submit)publicvoidsayHi(Buttonbutton){button.setText("Hello!");}但是，既然要指定，就最好把类型写正确了，否则会报错。这里还可以为多个id同时指定点击事件。如下所示@OnClick({R.id.door1,R.id.door2,R.id.door3})publicvoidpickDoor(DoorViewdoor){if(door.hasPrizeBehind()){Toast.makeText(this,"Youwin!",LENGTH_SHORT).show();}else{Toast.makeText(this,"Tryagain",LENGTH_SHORT).show();}}这个用法还真没怎么用过，可以看到上面是为用一个类型的三个View指定了点击事件处理，然后根据不同View的属性去做了不同的判断。当然这里应该可以使用switch判断，对id进行判断然后做具体的点击处理，比较灵活。ButterKnife也可以为自定义View绑定点击监听。直接在View内部实现，如下所示。publicclassFancyButtonextendsButton{@OnClickpublicvoidonClick(){//TODOdosomething!}}说道这里，我们只看到了点击事件的绑定，那么ButterKnife支持其他事件绑定吗？比如onCheckChangeListener，onLongClickListener以及ListView的onItemClickListener，当然可以,具体支持哪些，可以从源码包结构对注解的定义可以看出。如下图所示。可以看到，一般的，我们能用到的事件，大都囊括其中了。不错的链接ButterKnife使用详谈http://www.jianshu.com/p/b6fe647e368b</li>
  <li>这么晚了我还在给咕咚翻译加在线发音功能！！还好有音乐作陪…其实实现发音很简单，金山的API支持单词发音。访问http://dict-co.iciba.com/api/dictionary.php?type=json&amp;w=nice&amp;key=3BE8E8ACA43FDA088E52EC05FA8FA203即可在返回单词解释的同时，返回单词的发音URL，如下所示，自己使用了三家翻译API，只有金山支持发音，也算是良心，给金山翻译API点个赞。{ph_en:"naɪs",ph_am:"naɪs",ph_other:"",ph_en_mp3:"http://res.iciba.com/resource/amp3/oxford/0/24/8a/248a2aa9259a98ecb7a1ff677a0feed2.mp3",ph_am_mp3:"http://res.iciba.com/resource/amp3/1/0/7c/64/7c6483ddcd99eb112c060ecbe0543e86.mp3",ph_tts_mp3:"http://res-tts.iciba.com/7/c/6/7c6483ddcd99eb112c060ecbe0543e86.mp3",}在已经知道发音MP3路径的条件下，其实做发音功能很简单。MediaPlayer支持播放urlStringurl="http://........";//yourURLhereMediaPlayermediaPlayer=newMediaPlayer();mediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);mediaPlayer.setDataSource(url);mediaPlayer.prepare();//mighttakelong!(forbuffering,etc)mediaPlayer.start();使用上面的代码块，传递一个url进去就可以播放单词发音。但是个人觉得，尽管发音文件很小，但是每次都去做网络请求，也未免太暴力了，所以自己想每次请求发音时，先去本地缓存找，有没有缓存的音频文件，如果有，就直接使用，没有再去网络下载，下载完成后播放，顺便把文件缓存在本地，所以就有了下面的下载、播放、缓存逻辑。其实这个逻辑写完整了还是挺长的，如下所示，首先要拿到数据实体，然后做各种判断，还要多url做解析判断，最终执行网络请求等等一系列操作。真是『一会儿排成个人字，一会儿排成个一字』具体代码如下所示。//判断实体是否为空if(entity==null){return;}//拿到entity中的resultResultresult=entity.getResult();if(result==null){return;}//获得发音URLStringamMp3Url=result.getEnMp3();if(TextUtils.isEmpty(amMp3Url)){return;}//判断URL是否合法if(!amMp3Url.startsWith(DownloadService.KEY_URL)){return;}//解析包装URLStringurl=amMp3Url.replace(DownloadService.KEY_URL+"resource/amp3/","");String[]param=url.split("/");if(param.length!=5){return;}//去本地查询FilecacheFile=mFileManager.getChacheFileByUrl(mActivity,amMp3Url);if(cacheFile!=null&amp;&amp;cacheFile.exists()){playSound(cacheFile);return;}//封装网络请求Call&lt;ResponseBody&gt;call=mDownloadService.downloadFileWithDynamicUrlSync(param[0],param[1],param[2],param[3],param[4]);//发动网络请求call.enqueue(newCallback&lt;ResponseBody&gt;(){@OverridepublicvoidonResponse(Response&lt;ResponseBody&gt;response,Retrofitretrofit){if(response.isSuccess()){try{//执行本地存储cacheAndPlaySound(mActivity,amMp3Url,response.body().bytes());}catch(IOExceptione){e.printStackTrace();}}}@OverridepublicvoidonFailure(Throwablet){Logger.e(t.getMessage());t.printStackTrace();}});使用RxJava后Observable.just(entity).filter(newFunc1&lt;AbsResult,Boolean&gt;(){@OverridepublicBooleancall(AbsResultabsResult){returnabsResult!=null;}}).map(newFunc1&lt;AbsResult,Result&gt;(){@OverridepublicResultcall(AbsResultabsResult){returnabsResult.getResult();}}).filter(newFunc1&lt;Result,Boolean&gt;(){@OverridepublicBooleancall(Resultresult){returnresult!=null;}}).map(newFunc1&lt;Result,String&gt;(){@OverridepublicStringcall(Resultresult){returnresult.getEnMp3();}}).filter(newFunc1&lt;String,Boolean&gt;(){@OverridepublicBooleancall(Strings){return!TextUtils.isEmpty(s)&amp;&amp;s.startsWith(DownloadService.KEY_URL);}}).map(newFunc1&lt;String,String&gt;(){@OverridepublicStringcall(Strings){returns.replace(DownloadService.KEY_URL+"resource/amp3/","");}}).map(newFunc1&lt;String,String[]&gt;(){@OverridepublicString[]call(Strings){returns.split("/");}}).filter(newFunc1&lt;String[],Boolean&gt;(){@OverridepublicBooleancall(String[]strings){returnstrings.length==5;}}).subscribe(newSubscriber&lt;String[]&gt;(){@OverridepublicvoidonCompleted(){}@OverridepublicvoidonError(Throwablee){}@OverridepublicvoidonNext(String[]param){FilecacheFile=mFileManager.getChacheFileByUrl(mActivity,entity.getResult().getEnMp3());if(cacheFile!=null&amp;&amp;cacheFile.exists()){playSound(cacheFile);return;}Call&lt;ResponseBody&gt;call=mDownloadService.downloadFileWithDynamicUrlSync(param[0],param[1],param[2],param[3],param[4]);call.enqueue(newCallback&lt;ResponseBody&gt;(){@OverridepublicvoidonResponse(Response&lt;ResponseBody&gt;response,Retrofitretrofit){if(response.isSuccess()){try{cacheAndPlaySound(mActivity,entity.getResult().getEnMp3(),response.body().bytes());}catch(IOExceptione){e.printStackTrace();}}}@OverridepublicvoidonFailure(Throwablet){Logger.e(t.getMessage());t.printStackTrace();}});}});从表面看到的是，代码一下子公正了很多，再看逻辑，很清晰有木有！</li>
  <li>本文最后修改于：2019/12/05调整、删减部分语句前言最近在看廖祜秋的下拉刷新项目android-Ultra-Pull-To-Refresh，就在今天做了一些精简操作后，准备加入项目准备使用时，发现lib根目录下有一个checkstyle.xml文件，很好奇它是干什么的，后来Google后，原来这东西可以用来检查代码，随即查询了一些资料，把它用了起来，下面简单记录下。用途AndroidStudio支持在项目中通过指定CheckStyle规则去检查代码写的是不是规范，如果代码中有不合该规范的地方，可以在控制台看到对应的提示信息。这里比较好的一点是，你可以自定义checkstyle，所以可以根据自己的代码规范去一点点完善这个checkstyle，也可以使用一些大公司的checkstyle，并且这些checkstyle文件大都可以被搜到。效果下图中使用checkstyle检查我的MainActivity，其中我故意让一个成员变量的命名没有按照驼峰式去写，然后点击菜单列表中的CheckCurrentFile选项，具体如下。可以看到，显示提示viewpager命名不合规范，然后我改为mViewPager后，就不会再提示了。如下所示。配置已经看到了具体效果，是不是跃跃欲试了，这时你可能试着点击了菜单右键，却没有发现CheckCurrentFile这个选项，因为你还没有安装CheckStyle-IDEA插件，如何安装，具体如下：安装插件打开AndroidStudio的插件市场，便可通过在线安装的方式进行安装，也可以通过本地安装，插件地址配置checkstyle文件当安装好插件，打开AndroidStudio的设置页面settings-&gt;OtherSettings你会发现多了一个Checkstyle,点击打开,如下图。你会看到有一个+按钮，点击即可添加自己的checkstyle文件，你可能第一次不会写这个文件，没关系，这里提供一个华为的CheckstyleGist地址。其实AndroidStudio已经默认提供了一个，你也可以使用默认的。记得添加时，不要忘了填写description。这里关于checkstyle中的语法，有相应的文档，可以自己去搜索阅读具体语法，一般的，照猫画虎就够了。现成的CheckStyle华为CheckStyle地址thecheckstyleconfigurationusedforPicassobySquarefolksGoogle’sJavaStyleCheckstyleCoverage完毕到此，基本的配置就完毕了。现在AndroidStudio的控制面板会多一个CheckStyle，你可以在这里方便的进行代码检查。可以点击面板的左上角下拉框Rule去动态切换不同的checkstyle。总结其实代码检查还有很多方式，这只是一种，有兴趣可以看看其他几种，如Lint、Findbugs。有用的链接checkstyle项目地址CheckStyleAPI文档代码规范和Android项目中的一些可用工具StaticcodeanalysispluginforAndroidproject</li>
  <li>在上一篇文章Handler之源码解析中介绍Handler与Looper的关系时，半路出现了ThreadLocal这个类，他是什么呢，本想在Handler源码解析一文一起阐述了，但是觉得这样篇幅太长，不好，况且他又是一个相对独立的概念，这里就把它单独拿出来，结合任玉刚的Android的消息机制之ThreadLocal的工作原理博文，为自己总结归纳下ThreadLocal的用处，以及他在Handler和Looper中的巧妙用法。ThreadLocal其实在Handler之源码分析一文中，关于Handler有一点一直没说到。Handler在创建的时候必须使用当前线程的Looper来构造消息循环，而自己手动创建的子线程默认是没有Looper的，如果在一个子线程中创建Handler，就必须为这个子线程创建相应的消息轮训器，否则我们就会看到一个常见的异常Can'tcreatehandlerinsidethreadthathasnotcalledLooper.prepare()那我们如何在子线程中创建一个Looper呢？其实从上面的异常信息，我们已经知道了，在子线程中调用Looper.prepare()方法就可以为这个子线程创建一个Looper对象。是抛出一个观点的时候了。我们在主线程创建一个Handler，这个Handler就需要一个和主线程绑定的消息轮询器(Looper)，如果是在一个子线程创建一个Handler,那么我们就需要为这个Handler绑定一个与子线程绑定的消息轮询器(Looper).至于原因，应该是这样的，主线程的handler发送消息后，应该是主线程的Looper去轮询与主线程相关的那个MessageQueue，并且处理消息，子线程中创建的Handler对象在发送消息时，（不论他在什么地方发送），应该是通过子线程对应的消息轮询器去轮询相应的MessageQueue，然后处理消息。但是现在有一个问题，如何控制Looper的myLooper()方法返回的对象是当前线程对应的Looper呢?publicstatic@NullableLoopermyLooper(){returnsThreadLocal.get();}这就是ThreadLocal妙用之所在，ThreadLocal可以在不同的线程之中互不干扰地存储并提供数据，这句话的意思很清楚。就是说，在不同的线程中会存储不同的数据，他们互不干扰。下面这行，摘抄自任玉刚的博客ThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储以后，只有在指定线程中可以获取到存储的数据，对于其它线程来说无法获取到数据。这个特性正好满足Handler、Looper在线程方法的特性，可以确保在主线程中调用sThreadLocal.get();得到的是主线程对用的Looper对象，在子线程中调用得到的是子线程中对应的Looper。上面也说了，如果我们在子线程中去实例化Handler，必须先调用Looper.prepare()方法。通过这个方法，为所在的子线程绑定一个Looper,这个Lopper将会在子线程中newHandler()时自动绑定到这个Handler，解析来我们看看，这一切在子线程中是怎么发生的。首先分析出错的情形，也就是直接在子线程中newHandler()时报错，是怎么发生的。先在子线程中创建一个HandlernewThread(newRunnable(){@Overridepublicvoidrun(){HandlerinnerHandler=newHandler(){@OverridepublicvoidhandleMessage(Messagemsg){super.handleMessage(msg);}};}}).start();接着看Handler的构造方法。publicHandler(Callbackcallback,booleanasync){mLooper=Looper.myLooper();if(mLooper==null){thrownewRuntimeException("Can'tcreatehandlerinsidethreadthathasnotcalledLooper.prepare()");}mQueue=mLooper.mQueue;mCallback=callback;mAsynchronous=async;}当执行到myLooper()publicstatic@NullableLoopermyLooper(){returnsThreadLocal.get();}此时的sThreadLocal是一个线程数据存储类，但是因为是在子线程中访问，所以它对应者子线程中的资源。由于我们在这个子线程中没有事先对sThreadLocal做任何处理，没有设置任何Looper对象，所以此时的myLooper()返回值一定是null。接下来，我们就会看到那个一开始学Handler时经常看到的错误日志了。Can'tcreatehandlerinsidethreadthathasnotcalledLooper.prepare()"然后，此时出错了，按照以前的做法。根据提示，在创建handler之前，调用Looper.prepare()方法，这样错误就没有了，但是先在从代码的角度观察一遍为什么这里调用一次Looper.prepare()就不报错了。prepare()源码publicstaticvoidprepare(){prepare(true);}privatestaticvoidprepare(booleanquitAllowed){if(sThreadLocal.get()!=null){thrownewRuntimeException("OnlyoneLoopermaybecreatedperthread");}sThreadLocal.set(newLooper(quitAllowed));}此时在方法中，首先判断sThreadLocal.get()!=null，因为现在的调用发生在子线程，而且没有为sThreadLocal设置过Looper对象，所以此时sThreadLocal.get()一定是null的，所以会直接执行sThreadLocal.set(newLooper(quitAllowed));我们看到，最终通过prepare()方法设置了在子线程中sThreadLocal的值为一个新的Looper对象。那么只要设置过了Looper对象，下一次在sThreadLocal执行get操作时就会得到已经设置好的Looper,这个Looper最终会被绑定到子线程中创建的Handler上面。这里需要特别注意一点，仅仅在创建handler之前调用了Looper.prepare()并不能完事大吉，如果你想通过这个handler接受消息，你就一定需要在创建完毕Handler，执行Looper.loop()方法，让刚才创建的Looper工作起来。否则，后续你在子线程发送消息了，但是你却在子线程的handler中接受不到消息，就会出现这样的问题。所以补全上面的代码，如下所示。newThread(newRunnable(){@Overridepublicvoidrun(){Looper.prepare();HandlerinnerHandler=newHandler(){@OverridepublicvoidhandleMessage(Messagemsg){super.handleMessage(msg);Log.i("msg","contentis"+msg.what);}};Looper.loop();}}).start();这里不禁就要问了，在子线程中是这样创建Handler的，需要手动调用Looper.prepare();以及Looper.loop();那为什么在主线程中定义Handler不需要这些操作呢？因为主线程，也就是我们经常提到的主线程，也叫UI线程，其实就是ActivityThread，ActivityThread被创建时就已经初始化过Looper了，代码如下publicstaticvoidmain(String[]args){//.............无关代码...............Looper.prepareMainLooper();Looper.loop();thrownewRuntimeException("Mainthreadloopunexpectedlyexited");}所以在主线程中创建handler时，是不需要手动去创建Looper的，因为他们早已创建好了。</li>
  <li>上一篇博客Handler之初识及简单应用中介绍了Handler的作用，以及Handler的基本用法，同时也详细介绍了为什么子线程不能更新UI的原因，但是因为篇幅原因，所以对Handler的内部机制并没有展开叙述。这篇文章就从Handler开始解析与之相关的源码，从而更好的理解Handler以及LooperMessageQueue。Handler机制写完上一篇文章，下面我该再读一遍Handler的源码了，其实讲Handler内部机制的博客已经很多了，但是自己还是要在看一遍，源码是最好的资料。在具体看源码之前，有必要先理解一下Handler、Looper、MessageQueue以及Message他们的关系。关系Looper:是一个消息轮训器，他有一个叫loop()的方法，用于启动一个死循环，不停的去轮询消息池。MessageQueue:就是上面说到的消息池Handler:用于发送消息，和处理消息Message:一个消息对象现在要问了，他们是怎么关联起来的？一切都要从Handler的构造方法开始。如下所示finalMessageQueuemQueue;finalLoopermLooper;finalCallbackmCallback;finalbooleanmAsynchronous;publicHandler(Callbackcallback,booleanasync){mLooper=Looper.myLooper();if(mLooper==null){thrownewRuntimeException("Can'tcreatehandlerinsidethreadthathasnotcalledLooper.prepare()");}mQueue=mLooper.mQueue;mCallback=callback;mAsynchronous=async;}可以看到Handler本身定义了一个MessageQueue对象mQueue，和一个Looper的对象mLooper。不过，对Handler的这两个成员变量的初始化都是通过Looper来赋值的。mLooper=Looper.myLooper();mQueue=mLooper.mQueue;现在，我们新建的Handler就和Looper、MessageQueue关联了起来，而且他们是一对一的关系，一个Handler对应一个Looper，同时对应一个MessageQueue对象。这里给MessageQueue的赋值比较特殊，mQueue=mLooper.mQueue;这里直接使用looper的mQueue对象，将looper的mQueue赋值给了Handler自己，现在Looper和Handler持有着同一个MessageQueue。这里可以看到Looper的重要性，现在Handler中的Looper实例和MessageQueue实例都是通过Looper来完成设置的，那么下面我们具体看看Looper是怎么实例化的，以及他的mQueue是怎么来的。Looper从上面Handler的构造方法中可以看到，Handler的mLooper是这样被赋值的。mLooper=Looper.myLooper();接着看myLooper()的实现。staticfinalThreadLocal&lt;Looper&gt;sThreadLocal=newThreadLocal&lt;Looper&gt;();publicstatic@NullableLoopermyLooper(){returnsThreadLocal.get();}这里出现了一个平时不怎么看到的ThreadLocal类，关于这个类，推荐去阅读任玉刚的一篇文章-Android的消息机制之ThreadLocal的工作原理,讲的很不错。另外自己也写了一篇文章，用于讲解ThreadLocal的用法，以及他在Handler和Looper中的巧妙意义。任玉刚-Android的消息机制之ThreadLocal的工作原理咕咚-Handler之ThreadLocal相关这里他是通过ThreadLocal的get方法获得，很奇怪，之前我们没有在任何地方对sThreadLocal执行过set操作。这里却直接执行get操作，返回的结果必然为空啊！但是如果现在为空，我们在newHandler()时，程序就已经挂掉了啊，因为在Handler的构造方法中，如果执行Looper.myLooper()的返回结果为空。mLooper=Looper.myLooper();if(mLooper==null){thrownewRuntimeException("Can'tcreatehandlerinsidethreadthathasnotcalledLooper.prepare()");}但是，我们的程序没有挂掉，这意味着，我们在执行myLooper()方法时，他返回的结果不为空。为什么呢？那我们在Looper中看看，哪里有对应的set方法，如下所示,我们找到了一个全局静态方法preparepublicstaticvoidprepare(){prepare(true);}privatestaticvoidprepare(booleanquitAllowed){if(sThreadLocal.get()!=null){thrownewRuntimeException("OnlyoneLoopermaybecreatedperthread");}sThreadLocal.set(newLooper(quitAllowed));}我们看到，在最后一行这里，执行了对应的set操作，这里把一个new出来的Looper直接set到sThreadLocal中。但是我们不知道，到底什么时候，是谁调用了prepare()方法，从而给sThreadLocal设置了一个Looper对象。后来在网上经过搜索，找到了答案，我们的Android应用在启动时，会执行到ActivityThread类的main方法，就和我们以前写的java控制台程序一样，其实ActivityThread的main方法就是一个应用启动的入口。在这个入口里，会做很多初始化的操作。其中就有Looper相关的设置，代码如下publicstaticvoidmain(String[]args){//.............无关代码...............Looper.prepareMainLooper();Looper.loop();thrownewRuntimeException("Mainthreadloopunexpectedlyexited");}在这里，我们很清楚的看到，程序启动时，首先执行Looper.prepareMainLooper()方法，接着执行了loop()方法。先看看prepareMainLooper方法。publicstaticvoidprepareMainLooper(){prepare(false);synchronized(Looper.class){if(sMainLooper!=null){thrownewIllegalStateException("ThemainLooperhasalreadybeenprepared.");}sMainLooper=myLooper();}}publicstatic@NullableLoopermyLooper(){returnsThreadLocal.get();}privatestaticvoidprepare(booleanquitAllowed){if(sThreadLocal.get()!=null){thrownewRuntimeException("OnlyoneLoopermaybecreatedperthread");}sThreadLocal.set(newLooper(quitAllowed));}这里，首先调用了prepare()方法，执行完成后，sThreadLocal成功绑定了一个newLooper()对象，然后执行sMainLooper=myLooper();可以看看sMainLooper的定义，以及myLooper()方法；privatestaticLoopersMainLooper;//guardedbyLooper.classpublicstatic@NullableLoopermyLooper(){returnsThreadLocal.get();}现在的sMainLooper就有值了，也就是说，只要我们的App启动，sMainLooper中就已经设置了一个Looper对象。以后调用sMainLooper的get方法将返回在程序启动时设置的Looper，不会为空的。下面在看main方法中的调用的Looper.loop()方法。已经把一些无关代码删了，否则太长了，publicstaticvoidloop(){//获得一个Looper对象finalLooperme=myLooper();//拿到looper对应的mQueue对象finalMessageQueuequeue=me.mQueue;//死循环监听(如果没有消息变化，他不会工作的)不断轮训queue中的Messagefor(;;){//通过queue的next方法拿到一个MessageMessagemsg=queue.next();//mightblock//空判断if(msg==null)return;//消息分发msg.target.dispatchMessage(msg);//回收操作msg.recycleUnchecked();}}现在，想一个简单的过程，我们创建了一个App,什么也不做，就是一个HelloWorld的Android应用，此时，你启动程序，即使什么也不干，按照上面的代码，你应该知道的是，现在的程序中已经有一个Looper存在了。并且还启动了消息轮询。Looper.loop();但是，目前来看，他们好像没什么用，只是存在而已。此时你的项目如果使用了Handler,你在主线程new这个Handler时，执行构造方法publicHandler(Callbackcallback,booleanasync){mLooper=Looper.myLooper();if(mLooper==null){thrownewRuntimeException("Can'tcreatehandlerinsidethreadthathasnotcalledLooper.prepare()");}mQueue=mLooper.mQueue;mCallback=callback;mAsynchronous=async;}此时的myLooper()返回的Looper就是应用启动时的那个Looper对象，我们从Looper的构造方法得知，在newLooper时，会新建一个对应的消息池对象MessageQueueprivateLooper(booleanquitAllowed){mQueue=newMessageQueue(quitAllowed);mThread=Thread.currentThread();}那么在Handler的构造方法中，那个mQueue其实也是在应用启动时就已经创建好了。现在再来回顾一下Handler的构造方法，在构造方法中，他为自己的mQuery和mLooper分别赋值，而这两个值其实在应用启动时，就已经初始化好了。并且，现在已经启动了一个消息轮训，在监听mQuery中是不是有新的Message!现在这个轮训器已经好了，我们看发送消息的过程。SendMessage我们使用Handler发送消息mHandler.sendMessage(msg);Handler有好多相关的发送消息的方法。但是追踪源码，发现他们最终都来到了Handler的这个方法sendMessageAtTimepublicbooleansendMessageAtTime(Messagemsg,longuptimeMillis){MessageQueuequeue=mQueue;if(queue==null){RuntimeExceptione=newRuntimeException(this+"sendMessageAtTime()calledwithnomQueue");Log.w("Looper",e.getMessage(),e);returnfalse;}returnenqueueMessage(queue,msg,uptimeMillis);}接着看enqueueMessage()方法体privatebooleanenqueueMessage(MessageQueuequeue,Messagemsg,longuptimeMillis){msg.target=this;//使用默认的handler构造方法时，mAsynchronous为false。if(mAsynchronous){msg.setAsynchronous(true);}returnqueue.enqueueMessage(msg,uptimeMillis);}这里有一句至关重要的代码msg.target=this;我们看看msg的target是怎么声明的Handlertarget;意思就是每个Message都有一个类型为Handler的target对象，这里在handler发送消息的时候，最终执行到上面的方法enqueueMessage()时,会自动把当前执行sendMessage()的handler对象，赋值给Message的target。也就是说，Handler发送了Message，并且这个Message的target就是这个Handler。想想为什么要这么做？这里再说一下，Handler的作用，发送消息处理消息先不看代码，我们可以想想，handler发送了message,最终这个message会被发送到MessageQueue这个消息队列。那么最终，谁会去处理这个消息。在这里消息发送和处理遵循『谁发送，谁处理』的原则。现在问题来了，就按照上面说的，谁发送，谁处理，那现在应该是handler自己处理了，但是他在哪里处理呢？到现在我们也没看到啊。慢慢来，接下来继续看消息的传递。现在，我们只要发送了消息，那么消息池mQuery就会增加一个消息，Looper就会开始工作，之前已经说了，在应用启动的时候，已经启动了Looper的loop()方法，这个方法会不断的去轮训mQuery消息池，只要有消息，它就会取出消息，并处理，那他是怎么处理的呢？看一下loop()的代码再说。publicstaticvoidloop(){//获得一个Looper对象finalLooperme=myLooper();//拿到looper对应的mQueue对象finalMessageQueuequeue=me.mQueue;//死循环监听(如果没有消息变化，他不会工作的)不断轮训queue中的Messagefor(;;){//通过queue的next方法拿到一个MessageMessagemsg=queue.next();//mightblock//空判断if(msg==null)return;//消息分发msg.target.dispatchMessage(msg);//回收操作msg.recycleUnchecked();}}看for()循环，他在拿到消息后，发现msg不为空，接着就会执行下面这句非常重要的代码msg.target.dispatchMessage(msg);这里执行了msg.target的方法dispatchMessage，上面已经在sendMessage时看到了，我们在发送消息时，会把msg的target设置为handler本身，也就是说，handler发送了消息，最终自己处理了自己刚刚分发的消息。恩恩，答案就在这里，『谁发送，谁处理』的道理在这里终于得到了体现。那么他是怎么处理消息的？看看Handler的dispatchMessage()是怎么实现的。publicvoiddispatchMessage(Messagemsg){if(msg.callback!=null){handleCallback(msg);}else{if(mCallback!=null){if(mCallback.handleMessage(msg)){return;}}handleMessage(msg);}}我们看到，我们没有给msg设置callback也没有给handler的mCallback设置过值，所以此时，会执行handleMessage()方法；publicvoidhandleMessage(Messagemsg){}发现这是一个空方法，所以自己的新建Handler时，只要复写了这个方法，我们就可以接受到从子线程中发送过来的消息了。在看一遍自己定义Handler时，如何定义的，如何复写handlerMessageprivateHandlermHandler=newHandler(){@OverridepublicvoidhandleMessage(Messagemsg){super.handleMessage(msg);switch(msg.what){case1:Bitmapbitmap=(Bitmap)msg.obj;imageView.setImageBitmap(bitmap);break;case-1:Toast.makeText(MainActivity.this,"msg"+msg.obj.toString(),Toast.LENGTH_SHORT).show();break;}}};在这里，我们处理了自己发送的消息，到此Handler的内部机制大体就分析完了。但是从上面的dispatchMessage方法我们也能看出，Handler在处理消息时的顺序是什么？publicvoiddispatchMessage(Messagemsg){if(msg.callback!=null){handleCallback(msg);}else{if(mCallback!=null){if(mCallback.handleMessage(msg)){return;}}handleMessage(msg);}}他首先判断Message对象的callback对象是不是为空，如果不为空，就直接调用handleCallback方法，并把msg对象传递过去，这样消息就被处理了。如果在发送消息时，我们没有给Message设置callback对象，那么程序会执行到else语句块，此时首先判断Handler的mCallBack对象是不是空的，如果不为空，直接调用mCallback的handleMessage方法进行消息处理。最终，只有当Handler的mCallback对象为空，才会执行自己的handleMessage方法。这是整个处理消息的流程。现在就会想了，在处理消息时，什么时候才能执行到第一种情况呢，也就是通过Message的callback对象处理。其实简单，查看源码发现/*package*/Runnablecallback;callback是一个Runnable接口，那我们这怎么才能设置Message的callback的参数呢？最后观察发现，Handler发送消息时，除了使用sendMessage方法，还可以使用一个叫post的方法，而他的形参正好就是Runnable,我们赶紧拔出他的源码看看。publicfinalbooleanpost(Runnabler){returnsendMessageDelayed(getPostMessage(r),0);}接着看getPostMessage()这个方法。privatestaticMessagegetPostMessage(Runnabler){Messagem=Message.obtain();m.callback=r;returnm;}代码看到这里，已经很清楚了，getPostMessage()返回了一个Message对象，这个对象中设置了刚才传递过来的runnable对象。到这里，你应该明白了，在处理消息时，除了Handler自身的handlerMessage()方法设置处理，还可以直接在发消息时指定一个runnable对象用于处理消息。另外上面通过dispatchMessage()的代码已经看出来，处理消息有三种情形，第一种直接使用Message的running对象处理，如果不行使用第二种用Handler的mCallback对象处理，最后才考虑使用handlerMessage处理，关于第二种情形，这里就不分析了，自己试着看代码应该能找到。Goodluck~参考文章鸿洋_-Android异步消息处理机制让你深入理解Looper、Handler、Message三者关系</li>
  <li>这篇文章主要讲解和记录自己对Handler的理解。因为一开始接触Android就接触到了Handler，所以对handler的了解应该比较多，加上项目中在消息传递以及异步控制方面都要用到Handler。自己也不止一遍的看过Handler源码，不过每次看的时候都能明白，但是时间久了，就很容易忘记。所以这次就有了这个Handler系列。从Handler的使用场景，到具体使用再到源码解析，自己重新再走一遍，同时通过博客记录下来，方便以后查阅。我想，这也是写博客的意义所在。谈一个东西之前，首先说明白他为什么要存在。也就是它存在的意义。为什么要有Handler在Android中，默认所有的代码都执行在主线程，我们已经在Activity中happy的写了很久的代码，如设置一个Button的颜色、获取输入框内的文本、设置ImageView的图片属性等等，这些操作执行起来都很快，只要设置，我们可能就会马上看到效果，这就是我们常见的UI操作。完成他们几乎都是瞬时的。但是，在Android中有一些操作是很耗费时间的，比如从网络加载一个大图片。因为要建立连接，请求服务端，解析数据等等的操作，所以完成这样的操作，就不是一下两下能做到的。试想，这个操作发生在主线程，由于线程同一时间只能执行一个操作，所以在请求网络图片的过程中，主线程不能做一些其他的更新UI相关的操作，所以我们现在能看到的就是，界面被卡住了，原因已经很清楚，主线程被耗时操作阻塞了。这种卡住的状态直到请求成功。这里，卡主状态首先不是一种好的用户体验，与此同时，Android也有一个相关的规定，在主线程完成一个操作的时间不能超过5秒，否则Android系统就会给用户弹出一个ANR的奔溃对话框。下面是从官方文章中摘抄的一段InAndroid,applicationresponsivenessismonitoredbytheActivityManagerandWindowManagersystemservices.AndroidwilldisplaytheANRdialogforaparticularapplicationwhenitdetectsoneofthefollowingconditions:Noresponsetoaninputevent(suchaskeypressorscreentouchevents)within5seconds.ABroadcastReceiverhasn'tfinishedexecutingwithin10seconds.这里需要说明的一点，在Android4.0之后，系统已经不允许在UI线程访问网络了，以前只是ANR，4.0之后就直接FC了。所以，作为开发者，你一定不希望这样的事发生在你的App里，所以我们一定要避免把一个耗时可能超过5秒的操作放在主线程，那怎么才能做到呢？其实目前已经有很多方法可以做到这一点，用Thread+Handler的组合或者使用AsyncTask，当然如果你知道RxJava的话，用RxJava也是相当不错的选择。上述三种方式都可实现。官方也已经提供了一个指南，用于介绍如何避免这种问题，他用到了AsyncTask，原文KeepingYourAppResponsive，可以一看。作为自己今天的研究，我主要说Handler。使用由于主线程不能做耗时操作，所以可以在主线程中建立一个子线程，把耗时操作放在子线程完成，这样不就能避开Android系统的ANR规则了吗？是的，所以我们可以在主线程new一个子线程，让它开启工作，像下面这样privatevoidexecuteTask(){newThread(newRunnable(){@Overridepublicvoidrun(){try{Bitmapbitmap=loadImg("http://blog.happyhls.me/wp-content/uploads/2015/12/fresco-og-image-1024x362.png");}catch(IOExceptione){e.printStackTrace();mHandler.sendMessage(mHandler.obtainMessage(-1,e.getMessage()));}}}).start();}如上所示，loadImg()就是一个耗时操作，可以猜想的到，它里面都发生了什么。首先发送了网络请求，接着获取到对应的图片数据，然后还把数据解析成Bitmap，恩恩，这是一个标准的网络请求操作。代码不贴了。恩，回到正题，你不是很耗时吗？我把你放到一个子线程中去执行，随你怎么耗时，你都不会影响我主线程中的UI更新操作。但是问题来了，子线程跨过山河大海，飘过远洋高山，终于气喘吁吁的回来了，手里还拿着bitmap。此时，我们很容易的想到，赶紧把这个从服务端解析到的bitmap通过ImageView的setImageBitmap()方法设置到ImageView上啊，这样我们就可以看到图像了。此时当你调用上面的方法后，你的应用又崩了。因为此时的setImageBitmap()方法调用发生在子线程，同时，这个方法属于更新界面UI的操作，而Android系统不允许我们的代码在子线程中去更新UI，更新UI的操作只能发生在主线程，so~我们的代码执行到setImageResource这里的时候就崩溃了。Onlytheoriginalthreadthatcreatedaviewhierarchycantouchitsviews.atandroid.view.ViewRootImpl.checkThread(ViewRootImpl.java:6581)atandroid.view.ViewRootImpl.requestLayout(ViewRootImpl.java:924)奔溃提示如上所示，注意中间那句提示，说的很明白，简单翻译一下Onlytheoriginalthreadthatcreatedaviewhierarchycantouchitsviews.只有创建了这个view树的线程才可以去touch(泛指操作)这个View因为Activity的view层次树是在主线程完成初始化的，所以对所有依附于这个层次树的view,你要是后续想要touch它，就一定要在主线程中touch，不能挪到其他子线程中去touch。关于上面说到的，View层次树的创建以及初始化是在主线程中完成这一点，一些人可能怀疑。这里也不具体深挖代码，简单分析下。一般的，我们在onCreate中调用setContent()方法就可以完成布局的设置和加载，如下所示。setContentView(R.layout.activity_handler);很明显，setContent()是在主线程中调用完成的，这里如果深究setContent(),你会发现是PhoneWindow最终执行了相关的逻辑，而最终通过Window的一系列操作，这个Activity对应的View层次树也就创建成功。同时，这个Activity中的所有view都将依附于这个层次树。我们平时可能看过很多这样的结论，『Android中不允许在子线程中更新UI』,其实归根结底是这个原因。说道这里，你不禁想说，Android也太麻烦了，这么多规则，但是正所谓『无规矩，不成方圆』。有规矩总是好的，况且他也不是只定规矩，不给API。既然有问题，Android就提供了一整套的解决方案。既然子线程不能更新UI，那么就只能去主线程更新，但是现在的程序流正在子线程中，我们要怎么才可以把当前的代码逻辑切换到主线程中去?从而达到更新UI的目的。Handler来了~Handler用法既然要在主线程中处理UI，那么你应该先在主线程里去定义好你的Handler。此时只要在子线程中去调用handler的sendMessage(msg,obj)方法，你就可以把自己的逻辑，或者程序流给甩到主线程(暂且让我们这么形容吧~)。privatevoidexecuteTask(){newThread(newRunnable(){@Overridepublicvoidrun(){//子线程//.............耗时操作...................//Bitmapbitmap=loadImg("http://i.imgur.com/DvpvklR.png");//.............耗时操作...................//Messagemsg=newMessage();msg.what=1;msg.obj=bitmap;mHandler.sendMessage(msg);}}).start();}上面可以看到，在子线程里，在执行完耗时操作，得到bitmap后，我们简单封装了一个msg对象，我们就把这个msg通过mHandler的sendMessage方法，甩到了主线程，主线程中mHandler的handMessage()方法会处理被甩过来的msg对象；如下所示：privateHandlermHandler=newHandler(){@OverridepublicvoidhandleMessage(Messagemsg){super.handleMessage(msg);switch(msg.what){case1:Bitmapbitmap=(Bitmap)msg.obj;imageView.setImageBitmap(bitmap);break;case-1:Toast.makeText(MainActivity.this,"msg"+msg.obj.toString(),Toast.LENGTH_SHORT).show();break;}}};注意，这里我把它定义成了一个Activity的成员变量，它是在主线程中创建完成的。这里你可能就要问了，为什么在上面的子线程中调用了mHandler.sendMessage(msg);后，msg就能被甩到主线程中去呢，你说能就能吗？证据在哪里？其实通过运行代码，我们发现这样确实没问题了，我们在上面的handlerMessage方法中的case1中获得了对应bitmap,而且通过调用setImageBitmap()方法，我们确实也看到了实际的图片效果。这就是证据啊，有图有真相，msg就是被甩到主线程了，否则你怎么看到的图像。话虽这样说，现象也确实证明了上面说的，但是为什么简单调用了sendMessage()方法后，msg就到了主线程中呢？背后的具体逻辑到底是什么呢？下面具体带你进入Handler的背后。其实不是带你进入，同时也是带我进入，我虽然看过好多次，但是老是忘记，这次就通过博客的方式记录下。以备以后再次忘记，哈哈~具体可以看下一遍文章Handler之源码解析</li>
  <li>咕咚翻译是自己最近开发的一个实现『划词翻译』功能的Android应用，可能是目前Android市场上翻译效率最高的一款应用。示意图项目地址目前咕咚翻译已经开源到了Github,咕咚翻译,欢迎star,如果有bug或者更好的意见可以提issue.下载如果想第一时间体验，可通过以下方式下载。酷安市场Fir缘起自己经常在手机上会阅读一些英文的技术blog或者文档，经常会遇到陌生的单词，想必大家都有类似的经历，一般的，如果是上班期间，我可能会打开谷歌翻译，然后查词，但是当你不在电脑旁，就只能通过手机上的翻译软件来翻译生词，这里我们具体思考一下整个操作过程。通常遇到生词我们会这样操作，1、长按生词2、选择复制3、点击Home键4、找到翻译App,有道翻译或者谷歌翻译之类的5、长按输入框6、选择粘贴，7、翻译可以看到，经过上面漫长的7个步骤后，我们才可以查到一个单词的意思。试想，如果连续碰到几个不认识的单词，然后每次都想上面一样操作几次，呃呃~此刻的心情~其实整个过程是一个非常考验用户耐性的事，我曾经做过一次记录，记录自己完成上面一连串操作所花费的时间，我对手机的操作相对比较熟练，但是也花了15秒的时间，这15秒对于一个沉浸在阅读中的用户来讲是十分不友好的，因为他会很大几率的打断用户的阅读连贯性。所以，我就想，我能不能做一个稍微友好一点的翻译App,能不能让上面的步骤变得少点，因为自己一直有这个需求，所以自己就有了做这个App想法，而且我一直认为技术应该是用来解决问题的。咕咚来了最终,咕咚翻译仅仅只通过两步就实现了翻译的目的，长按单词、复制翻译。就是这么简单，此时单词的释义就会出现在手机屏幕，如下所示同时还支持收藏功能，既然是用户要翻译的词语，那应该很可能就是陌生单词，此时可以加入收藏到你的生词本。方便日后查阅。优点1、高效翻译，及时展现释义在手机界面。2、支持多个翻译引擎切换，目前支持百度、有道、金山。3、方便快捷加入生词本发布后续在发布后收到了各个渠道的一致好评，包括少数派就专门对咕咚翻译做过一次评测，Android上划词翻译该有的样子：咕咚翻译，与此同时，不断有人对咕咚翻译进行打赏支持，为表谢意这里有一个页面列出了所有打赏同学的打赏记录。咕咚翻译捐赠名单关于作者咕咚，爱折腾、爱新鲜…个人站点github微博</li>
  <li>最近在开发咕咚翻译时，在偏好设置的过程中，出现了一个莫名其妙的bug，在A进程中设置偏好设置后，B进程不能及时访问到A进程中设置的数据，今晚终于得到解决，随即做一次简单的记录。咕咚翻译这里先简单介绍下咕咚翻译这个App，如名字所言，它主要的功能是翻译，不过相比其他的翻译软件，他的翻译效率更高。因为它实现了手机端的”划词翻译”，只要你在手机上复制了任何英文内容，他都会监听粘贴板，然后给出翻译结果，展示在手机界面。效果如下图所示。当你选择复制Reactive这个单词后，屏幕最上方就会显示一个提示框，用于显示单词的意思。同时，还支持收藏陌生单词到单词本。在这个单词本的基础上，我又做了一个背单词的功能。手机会每间隔一段时间，在手机上显示一个提示框，用于显示添加到生词本的单词。这个功能具体就是通过启动后台服务，然后开启一个定时任务，每间隔一段时间，随机的显示出生词本中一个单词。更多关于咕咚翻译的介绍可参看前一篇文章，关于咕咚翻译问题上面已经简单介绍了咕咚翻译，如上所述，App中可以设置提示弹框的显示间隔时间，可以设置每隔1分钟、3分钟、5分钟或10分钟显示一次生词，这个设置是在MainActivity中完成，代码如下。SpUtils.setIntervalTipTime(this,EIntervalTipTime.ONE_MINUTE.name());其实就是简单的操作了SharePreference把偏好设置存储在本地,真实的存储代码如下。publicstaticvoidputStringPreference(Contextcontext,Stringkey,Stringvalue){SharedPreferencessp=PreferenceManager.getDefaultSharedPreferences(context);sp.edit().putString(key,value).apply();}按理说，上面完成了设置，重启service后，在onStartCommand()中再次执行一次设置定时任务的代码，那个定时时间间隔就会同时改变。//获取本地设置的间隔时间EIntervalTipTimetipTime=SpUtils.getIntervalTimeWay(this);inttime=tipTime.getIntervalTime();//通过RxJava的interval操作符设置定时任务Observable.interval(time,TimeUnit.MINUTES).observeOn(AndroidSchedulers.mainThread()).subscribe(newObserver&lt;Long&gt;(){@OverridepublicvoidonCompleted(){Logger.d("completed");}@OverridepublicvoidonError(Throwablee){Logger.e("error")；}@OverridepublicvoidonNext(Longnumber){Resultresult=getResult();if(result!=null){prepareResultContent(getResult());show(false);}}});但事实上，我试了不行，不论怎么设置，service中获取到的时间间隔值总是第一次的值，除非退出应用重新打开App，才可以。解决方案设置App的SharedPreferences属性为Context.MODE_MULTI_PROCESS。publicstaticvoidputStringPreference(Contextcontext,Stringkey,Stringvalue){SharedPreferencessp=context.getSharedPreferences(context.getPackageName()+"_preferences",Context.MODE_MULTI_PROCESS);sp.edit().putString(key,value).apply();}原因分析咕咚翻译中开启了一个监听粘贴板的服务，并且通过在Manifest文件中指定process属性，为这个service指定了另一个进程&lt;serviceandroid:name=".listener.ListenClipboardService"android:enabled="true"android:exported="true"android:process=":process"/&gt;这样Application所在的进程就和ListenClipboardService处在了不同的进程，此时问题显而易见，在Application对应的进程中设置了一个值，另一个进程就不能及时获取到对应的值。这个问题可以通过设置SharedPreferences的属性为Context.MODE_MULTI_PROCESS解决，关于这个数值SharedPreferenceloadingflag:whenset,thefileondiskwillbecheckedformodificationevenifthesharedpreferencesinstanceisalreadyloadedinthisprocess.Thisbehaviorissometimesdesiredincaseswheretheapplicationhasmultipleprocesses,allwritingtothesameSharedPreferencesfile.Generallytherearebetterformsofcommunicationbetweenprocesses,though.Thiswasthelegacy(butundocumented)behaviorinandbeforeGingerbread(Android2.3)andthisflagisimpliedwhentargettingsuchreleases.ForapplicationstargettingSDKversionsgreaterthanAndroid2.3,thisflagmustbeexplicitlysetifdesired.这个标志位表示允许多个进程可以访问同一个SharePreference对象，因为在Android2.3版本之前，这个是默认值，所以不存在问题，但是2.3之后就需要手动开启。参考链接DefaultSharedPreferencesgivemewrongvaluesinService</li>
  <li>作品展示画廊，有图有真相。链接关于个人项目从一开始工作，自己就是个比较爱动手的开发者，喜欢将自己的想法变(编)成(程)具体可以看见的东西，做东西的过程也是一个学习的过程。因为自己的作品可以随意加入各种最新的知识点，所以这也是一个很好的体验新技术的方法.并且自己做的东西，还可能帮助到别人，给别人带来便利，何乐而不为。尽管我知道，做一个好用的东西，其实还是挺不容易的，因为好用就不单单是代码好实现的问题，还要涉及交互体验等繁多的事情。有时做东西做的多了，会突然有种想去做产品经理的冲动，觉得其实做产品还挺好玩，不过目前也只是冲动，业余做点自己的东西过过瘾就好，哈哈！下面罗列了自己做过的一些东西，无一例外，都是很简单的App,页面可能不超过5个，但是每个应用都是自己用心用力做出来的。其中除了GankDaily是为学习之用，其余的App均是自己生活场景中需要，而市面上没有合适的，所以自己动手做的，比如咕咚翻译、AppPlus以及密码本。对个人做App来讲，简单永远是第一法则，能简单就不忘复杂里做。当然，一开始我并不是这样想的，自己做的第一个App密码本，因为自己的不克制，导致后续加了很多无用的交互，对核心的功能却没在意，导致后来代码写的很痛苦，界面做的也一般，后来因为很多用户向我反应密码本的诸多问题(他们的问题我都耐心的帮他们解决了)，最后只得下架应用。到后来，越来越觉得对于App而言,『简单就是生产力』，其实这话放在其他事情上也合理。总之，自己虽然是写代码的，但是对产品有自己的理解，努力做个懂产品的程序员，显然，目前对产品的理解还很肤浅。但我会坚守这份对产品的爱。我也希望，在以后的工作中能够遇到一些懂技术的产品经理，比如NovaDNG,听过他的一次公开演讲，就觉得这才是产品经理的范，因为一个懂技术的产品经理在做产品的时候，他甚至可以考虑到技术人员会用什么技术去实现等等诸如此类的细节(也许只是臆想~)。下面简单罗列项目的部分信息。1、咕咚翻译一个实现『划词翻译』功能的Android应用，可能是目前Android市场上翻译效率最高的一款应用。目前项目已经开源在Github[]项目地址](https://github.com/maoruibin/TranslateApp)一篇关于咕咚翻译的介绍文章关于咕咚翻译Github项目主页Fir主页2、GankDaily自己利用干货集中营对外开放的API为干货集中营开发的一个手机客户端软件，客户端主要用于展现网站技术干货。该App是自己在drakeet的妹纸基础上修改而来，但是不论在UI方面还是项目结构方面，自己都做了自己的修改。在UI上更加重视干货内容展现，在项目结构设计上使用MVP模式，项目更加清晰。Github项目主页Fir主页3、AppPlusApp+是一个MD风格的用于传送、提取APK文件的开源工具软件。Github项目主页Fir主页4、PowerKey模仿MIUI6长按电源键的关机AppGithub项目主页5、PassBook用于存储日常生活中用到的密码。目前已经在市场下架，不过自己仍然在使用。这个项目暂时没有展示链接了，等以后再补充吧！</li>
  <li>RxJava已经出来很长一段时间了，国内也已经有很多公司在使用，与此同时，有不少优秀的开发者也不断的在开源社区分享自己对RxJava的使用理解，而且这个过程中也产出了不少优秀的RxJava资料。自己通过这些资料以及一些开源项目也在不断的学习RxJava，从一开始的GankDaily项目中蹒跚学步，到AppPlus中的大量实战，自己对RxJava的应用也变得熟练了起来，这篇文章结合自己的实践，简单说说RxJava以及它在AppPlus这个项目中的应用。前言先说一些与技术无关的内容。其实关于RxJava的使用介绍文档，国内已经有很多非常优秀的文章，比如扔物线的给Android开发者的RxJava详解以及hi大头鬼hi的深入浅出RxJava(译文)系列文章，都是非常不错的文章，自己把上面的文章至少读了两遍以上，从中收获颇多，而且文章中已经把RxJava的很多要点写的很清楚了，尤其是扔物线的那篇。所以，如果想了解RxJava使用方法，推荐直接去看上面两位的博文，这篇文章主要是记录自己学习过程中的一些感悟、以及自己在AppPlus这个项目中的实践。关于自己为什么要写这篇，主要是因为在看了别人的文章后，觉得有必要记录一下自己的理解，毕竟，别人的文章是别人的理解，是人家自己的学习记录以及思考。很多知识点只有经过自己的思考、应用、再思考、再理解才会变成自己的知识，当然不排除那种只看一遍就能领会RxJava核心思想的牛人，反正自己不是，纸上得来终觉浅，所以自己在读完了上面的文章后把RxJava应用到了自己的项目AppPlus中，并且决定在这里记录一些自己对RxJava的一些理解，用于加深对RxJava的认识理解。为什么要有RxJavaRxJava的核心在于异步。他的出现主要方便简化原来复杂的异步逻辑处理，下面是扔物线举出的一个实例，一个数组中含有多个图片本地路径，现在要把他们显示在一ImageView上，这是一个典型的异步过程。用传统的方式newThread(){@Overridepublicvoidrun(){super.run();for(Filefolder:folders){File[]files=folder.listFiles();for(Filefile:files){if(file.getName().endsWith(".png")){finalBitmapbitmap=getBitmapFromFile(file);getActivity().runOnUiThread(newRunnable(){@Overridepublicvoidrun(){imageCollectorView.addImage(bitmap);}});}}}}}.start();使用RxJava的方式Observable.from(folders).flatMap(newFunc1&lt;File,Observable&lt;File&gt;&gt;(){@OverridepublicObservable&lt;File&gt;call(Filefile){returnObservable.from(file.listFiles());}}).filter(newFunc1&lt;File,Boolean&gt;(){@OverridepublicBooleancall(Filefile){returnfile.getName().endsWith(".png");}}).map(newFunc1&lt;File,Bitmap&gt;(){@OverridepublicBitmapcall(Filefile){returngetBitmapFromFile(file);}}).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(newAction1&lt;Bitmap&gt;(){@Overridepublicvoidcall(Bitmapbitmap){imageCollectorView.addImage(bitmap);}});使用RxJava后的好处是程序结构变的清晰了，整个实现逻辑是流式风格，特别适合阅读，可以显著的提升代码的阅读性。如果整个团队都使用RxJava,那么后续维护成本就会降低写，因为代码的阅读性得到了提高。有种面向过程编程的感觉啊~RxJava原理介绍RxJava的异步实现主要是通过一种可扩展的观察者模式得到的。RxJava有四个基本概念：Observable(可观察者，即被观察者)、Observer(观察者)、subscribe(订阅)、事件。被观察者(Observable)发出事件(Event)观察者(Observer)订阅(Subscribe)事件，当被观察者发出事件，观察者则会接受消息事件。简单使用这里忽略如何引入RxJava的方式，具体可去RxJava开源站点去获取。首先来看AppPlus中的一个应用场景，在首页，我们需要查询最近运行的程序列表，这很明显一个异步过程，符合RxJava的应用场景，我们在工作线程去获取数据，获取数据完毕后，回到主线程完成界面更新。整个过程中，被观察者是一个抽象的数据获取过程，而观察者则是界面更新这个操作，在实际应用中，大多数情况下被观察者和观察者都是这种抽象的概念。下面首先定义一个观察者，这段代码在AppListFragment中。Subscriber&lt;List&lt;AppEntity&gt;&gt;subscriber=newSubscriber&lt;List&lt;AppEntity&gt;&gt;(){@OverridepublicvoidonNext(List&lt;AppEntity&gt;appEntities){setData(appEntities,mType);}@OverridepublicvoidonCompleted(){loadingFinish();}@OverridepublicvoidonError(Throwablethrowable){Log.d(tag,"Error!");}};这个观察者等待被观察者获取数据，被观察者获取到数据后就会自动发布事件，然后自动调用到观察者中已经定义好的回调方法，如上所示，调用setData()方法去更新界面，很简单的逻辑。那被观察者如何定义，如下所示Observable&lt;List&lt;AppEntity&gt;&gt;observable=DataHelper.getRunningAppEntity(getActivity());/***gettherunningapplistinfo*@paramctx*@return*/publicstaticObservable&lt;List&lt;AppEntity&gt;&gt;getRunningAppEntity(finalContextctx){returnRxUtil.makeObservable(newCallable&lt;List&lt;AppEntity&gt;&gt;(){@OverridepublicList&lt;AppEntity&gt;call()throwsException{List&lt;ActivityManager.RunningAppProcessInfo&gt;runningList=ProcessManager.getRunningAppProcessInfo(ctx);List&lt;AppEntity&gt;list=newArrayList&lt;&gt;();for(ActivityManager.RunningAppProcessInfoprocessInfo:runningList){StringpackageName=processInfo.processName;if(isNotShowSelf(ctx,packageName))continue;AppEntityentity=DataHelper.getAppByPackageName(packageName);if(entity==null)continue;list.add(entity);}returnlist;}});}这里牵扯到另一个问题，如何让自己的异步方法返回一个Observable对象，具体查看另一篇不错的译文将数据库操作RxJava化的方法现在观察者与被观察者都已经建立好了，按照之前的说法，现在只需要要通过observable的subscribe方法就可以将两者关联起来，observable.subscribe(subscriber);但是这里还有一个问题，我们写惯了Android的异步代码，都知道这样一个道理，获取数据等耗时操作要写在工作线程中，以防止应用ANR，但是数据获取成功后，要更新界面，就需要到把这个操作放到主线程中去完成，通常我们使用Handler就可以方便的做到上述这点，但是使用RxJava后我们怎么办，现在在被观察者和观察者中都没有看到任何和线程切换的操作，默认他们都应该是在主线程中运行。不出意外的话，执行上面的代码，程序应该会奔溃，因为获取最近运行的程序列表是一个耗时操作，把它刚在主线程明显是有问题的，那怎么办？这里不妨设想下，如果RxJava可以提供两个方法，一个用来控制被观察者中逻辑代码的执行线程，另一个用来控制观察者执行的线程该多好，那对我们程序员来说不非常方便吗，写惯了以前的Android代码，我们对那些代码应该放在主线程、那些代码应该放在子线程已经非常清楚，所以如果RxJava可以提供这样的线程控制API那一定是极好的。既然都这样设想了，RxJava必然已经提供了这样的方法，否则我也不会设想，哈哈~下面就说说RxJava中的线程控制###线程控制RXJava使用subscribeOn()和observeOn()两个方法来对线程进行控制subscribeOn():指定subscribe()所发生的线程，即Observable.OnSubscribe被激活时所处的线程。或者叫做事件产生的线程。observeOn():指定Subscriber所运行在的线程。或者叫做事件消费的线程。一般的我们用到的这里应该是主线程经过这个分析，修改上面的代码，如下所示observable//指定了获取数据的操作（被观察者）发生在io线程.subscribeOn(Schedulers.io())//指定了界面更新的操作(观察者)发生在mainThread.observeOn(AndroidSchedulers.mainThread())//观察者订阅数据获取这一事件.subscribe(subscriber);关于Schedulers内置的那几个线程可选项可查看扔物线博客线程控制——Scheduler(一)那一章节。到此为止，使用RxJava完成一个异步事件订阅就完成了。</li>
  <li>Android中的过度绘制是指同一个像素被绘制多次，从绘制性能角度讲，同一像素点被绘制的次数当然越少越好，这样有利于减轻GPU的工作压力，事实上，在具体开发过程中，不可避免的可能会出现过度绘制，这里，Android系统本身在开发者选项里已经提供了一个选项开关DebugGPUoverdraw(调试GPU过度绘制)，用于检测App的过度绘制，只要打开这个开关，App界面就会在不同的界面区域根据像素的绘制次数显示出不同的颜色，下面说说这几种颜色。关于过度绘制，也可以去查看官方的相关说明DebugGPUOverdrawWalkthrough颜色说明如果同一个像素点被绘制了两次，意味着过度绘制了一次，此时显示蓝色，大片的蓝色是一种比较理想的状态。如果同一个像素点被了绘制三次，意味着过度绘制了二次，此时显示绿色，如果界面中中等部分的绿色是可以接受的。如果同一个像素点被绘制了四次，意味着过度绘制了三次，此时显示浅红色，如果界面中有小范围的红色也是可以接受的。如果同一个像素点被了绘制五次或者更多（这个绘制的有点过分了啊！），意味着过度绘制了四次，此时显示暗红(GPU发烫时的颜色)，Thisiswrong.Fixit.下面是一副官方关于颜色说明的图片。Note:如果只被绘制了一次，那么不显示任何指示颜色，即透明。实例上面说了几种不同状态对应的颜色，下面结合代码，我们看看在App中过度绘制具体如何表现。新建应用OverdrawDemo，没有任何逻辑代码，直接看Layout文件，如下所示&lt;?xmlversion="1.0"encoding="utf-8"?&gt;&lt;LinearLayoutxmlns:android="http://schemas.android.com/apk/res/android"xmlns:tools="http://schemas.android.com/tools"android:layout_width="match_parent"android:layout_height="match_parent"android:orientation="vertical"tools:context="me.gudong.overdrawdemo.MainActivity"&gt;&lt;/LinearLayout&gt;然后打开开发者选项的过度绘制选项，效果如下，请先忽略Toolbar相关的颜色。这里可以看到在内容区域，是没有过度绘制的指示颜色，因为这片区域确实只被绘制了一次。此时试想一下，如果为根布局的LinearLayout设置背景色，android:background=“#f4f4f4"此时的界面会是怎样因为这个Activity默认已经用主题指定背景绘制了一次内容区域(DecorView)，此时在绘制LinearLayout时，因为指定android:background=“#f4f4f4"的缘故，这片区域的像素点必然会被绘制两次，所以此时的内容区域就会显示为蓝色。同样的道理，绿色、浅红色、暗红色都是根据同一像素点绘制次数的不同，而显示出来。为什么要研究过度绘制对一个App来说，它运行时要不停的根据用户的操作去绘制不同的界面，绘制界面主要由GPU控制，如果一个界面过度绘制比较严重，大部分界面区域都被绘制了3、4次甚至更多，那么就会浪费掉GPU的很多性能，这对于一个追求有良好体验App的开发者肯定是不允许的。尽管大部分情况下，App的过度绘制不可避免，但是在开发中，我们还是应该尽可能去减少过度绘制。从一定程度上，减少过度绘制会有利于提高App的流畅度。目前我们用到的主流App都有过度绘制的优化，包括微博微信，他们的首页在过度绘制方面做的都很不错，但是，也有很多App在这方面不够重视亦或者是优化力度不大，如下图对比了一些优化的比较好的App和一些没有优化的或者优化不够出色的App。微信VS回家吃饭微博VSKeep避免过度绘制的Tips既然过度绘制是不好的，那么我们在开发中就应该尽量去减少过渡绘制，这里结合自己网上看到的一些优化tip,整理一下。1、对于我们开发中的用到的View，如果对他设置背景颜色没有意义的，那么我们就应该不要随便去给他设置背景色。待补充…参考文章DebugGPUOverdrawWalkthroughAndroid性能优化之如何避免Overdraw</li>
  <li>该文章是自己在阅读Android性能优化典范-第一季时的读书笔记，Android性能优化典范主要讲了Android的渲染机制、内存和GC以及电量优化方面相关的内容，因为内容比较庞杂，加上一些知识点需要花心思去理解，所以在阅读的时候，顺便记录一下自己的阅读理解。原文Android性能优化典范-第一季笔记条目1、Android系统每隔16ms发出VSYNC信号，触发硬件对UI的渲染。2、1秒=1000ms所以基于上面的规则，每一秒UI应该渲染1000/16=60(次)，也就是我们经常看到的60hz这个值，表示一秒内刷新屏幕的次数，用术语讲这叫刷新率(RefreshRate)。3、刷新率这个值取决于硬件的固定参数，一般的这个值为60fps,原因在于人眼与大脑无法感知超过60fps的界面更新。4、帧率是区别于刷新率的另一个概念，他代表每一秒GPU绘制操作的帧数Note:两者的区别在于刷新率表示屏幕会按照这个频率去不停的刷新屏幕，至于屏幕上显示什么他控制不了，帧率表示GPU(图形处理器)一秒内绘制的次数，他俩前者负责按刷新率不停刷新界面，后者负责按帧率去不停绘制界面。5、刷新率和帧率需要结合在一起工作，才能让视图内容呈现在屏幕。6、GPU获取图形数据并绘制，硬件负责把GPU生成的视图数据拿出来显示在屏幕上，这个过程一遍遍的在我们的手机中发生着。如果屏幕刷新率和GPU帧率一致，那肯定是极好的，GPU每隔特定时间准备好视图数据。然后相应的，因为屏幕刷新率跟帧率一致，所以，此时此刻屏幕正好也刷新界面，视图正常显示。但是大多数情况下，他俩的步调可能不一致，所以会出现错位的情况此时，GPU那边准备了数据，但是屏幕这边缺不能及时的显示出来。7、界面渲染双缓冲技术一般我们在绘制UI的时候，都会采用一种称为“双缓冲”的技术。双缓冲意味着要使用两个缓冲区（SharedBufferStack中），其中一个称为FrontBuffer，另外一个称为BackBuffer。UI总是先在BackBuffer中绘制，然后再和FrontBuffer交换，渲染到显示设备中。理想情况下，这样一个刷新会在16ms内完成（60FPS）更多详情可参考http://djt.qq.com/article/view/987?ADTAG=email.InnerAD.weekly.201312168、任何时候，只要View中的绘制内容发生变化，都会重新执行创建DisplayList、渲染DisplayList9、Android中的内存模型分三级（这里的内存应该指的是堆内存）分别为YoungGeneration、OldGeneration、Permanent(常驻)Generation，也就是说Android虚拟机中的堆内存假如有125M,那么这125M会被指定为不同的类型，具体怎么指定，不用细究，他可以对每一块区域设置一个变量，用于指示这个区域是属于哪一级，这个纯属个人臆想，但说这么多，就是为了说明一个事实，Android堆内存那块空间会被划分为三种不同的类型，Young、Old、Permanent。这里每个区域肯定一个具体的大小值，具体大小的分配就是JVM的事了，Old区、Permanent区的大小要大于Young区。10、对内存区域分级的意义，先不看官方介绍，个人推测一下也不难知道，这样做就是为了更好的利用内存空间这么如此宝贵的地方。被划分成不同的区域后，我们每次new一个新对象时，毫无疑问，新对象分配的空间应该在YoungGeneration内存区域内。11、该说说垃圾回收了。当我们的程序不断的运行、不断的创建对象，Young区的空间肯定有被用完的时候，此时JVM检测到内存空间不够用，就会启动GC，执行垃圾回收，此时他很可能会对Young区的一些值做一些判断，看他们是不是被频繁的使用，如果是，他应该会把这部分内存空间标记为Old。同样的道理，Old区的对象也可能被转移到Permanent去，总之JVM这样做就是为了提高对象创建的效率。垃圾回收会把Young区中无用的对象给清理掉。12、关于上述的推测，这里是胡凯博文中的原话，对照理解下：Android里面是一个三级Generation的内存模型，最近分配的对象会存放在YoungGeneration区域，当这个对象在这个区域停留的时间达到一定程度，它会被移动到OldGeneration，最后到PermanentGeneration区域。每一个级别的内存区域都有固定的大小，此后不断有新的对象被分配到此区域，当这些对象总的大小快达到这一级别内存区域的阀值时，会触发GC的操作，以便腾出空间来存放其他新的对象。13、内存泄露问题。胡凯博文写的很清楚明白，直接引用胡凯的原文内存泄漏指的是那些程序不再使用的对象无法被GC识别，这样就导致这个对象一直留在内存当中，占用了宝贵的内存空间。显然，这还使得每级Generation的内存区域可用空间变小，GC就会更容易被触发，从而引起性能问题。内存泄露为什么会导致性能问题，上面的这段话很精辟的指出来了。就是因为泄露的对象会沉积在内存区，随着泄露的对象越来越多，JVM周期性的GC后发现内存空间依旧满满的，此时就会发生大家常说的内存溢出问题了。其实垃圾回收器(GC)在很努力的回收内存区中的无用对象，但是每次扫描却发现那些泄露的对象一直被一些或者的对象所持有，所以内存泄露问题，一定在开发中需要重视。14、每次GC的时候，其他所有线程都是暂停状态，也就是说GC操作会暂停其他任务。开发Tip以上是自己在阅读《Android性能优化典范》时的笔记，感谢作者可以把视频内容转化为更加容易理解的文章。但是任何好文章，阅读完应该可以给读者一些指导，这篇文章中讲了很多概念以及原理，下面就针对文章，总结一些开发过程中应该遵循的一些建议，以期让自己的App具有更好的性能。1、避免在for循环中给对象分配内存，直白一点就是说不要在for循环中new对象，最好可以移动到for之前。2、避免在自定义View时，在onDraw方法中执行太复杂的逻辑操作。3、避免在onDraw方法中创建对象，因为在界面绘制时，该方法可能会被大量的重复执行，这样会导致一瞬间产生大量的对象，从而导致堆空间中瞬间产生大量无用对象，从而触发JVM的GC操作。Note：一些情况下，无法避免在onDraw方法中创建对象，那么此时为了优化性能，可以采取对象池的策略，手动缓存已创建的对象，并加以复用，从而降低性能损失。但是使用此方法，需要注意一点，应该及时的手动清理对象池，否则可能会引起更加严重的内存问题。4、开发app的性能目标就是保持60fps，这意味着每一帧你只有16ms=1000/60的时间来处理所有的任务。所以我们的布局能简单则简单。5、考虑到过渡绘制，我们在写布局layout时，不应该随意的去为一些View设置background，例如，当我们的根布局已经设置过一次背景色，那么子view默认的背景色就是它了，所以对于一些子View，如果它跟根布局背景颜色一致，那么该View就无需再设置背景色了，另外一些情况可能需要设置selector，此时默认背景可以设置为透明色。6、对于电量优化，我们应该减少唤醒屏幕的次数以及持续时间，使用WeakLock处理唤醒问题。7、对一些非必须马上执行的操作，可以等待手机处于充电状态或者电量充足时再执行。8、对一些零散的网络请求，可以打包一次操作，避免过多的无线信号引起的电量消耗。</li>
  <li>忙里偷闲，在Acfun这个网站看了一部电影-火星救援，看之前，对这个电影没什么特别大的期待，不过因为主演是马特达蒙，所以今天就选择了这部电影。第一次看他的电影是谍影重重，自己也是从这部电影开始，喜欢上他。依旧记得大学时，连续三个周末，看完了谍影重重系列，每周一部，不敢贪多，当时只觉得两个小时太短了！当时因为太喜欢，特意还裁剪下其中的剧照（恩，当时应该用的是QQ影音自带的截图工具截的图），不过当时自己还没有的博客，所以现在我觉得，有必要把当时的截屏都放在这里了。谍影重重截下的每个画面，都是自己觉得特别有意义的镜头。很喜欢这种大场景拍摄，法国凯旋门跟女主角被迫分开离别总是那么纠结超喜欢大场景，应该是谍影2了好美俄罗斯火车站忘了，这是什么场景了"踩石"老巢女主角被追杀了，伯恩好难过容我稍许回味下当时的感觉，恩，那年我大二，那年我记得看了好多电影。《未知死亡》《窃听风暴》都挺不错的。那是一个美好的一年。关于火星救援，一开始看了剧照，只看到主演一个人穿着宇航服，行走在火星表面。觉得电影应该比较平淡无常，但事实上，这部电影好几次都戳中泪点，让人为之动容。剧情一场风暴和一个意外让Mark(电影主演)被迫留在火影，因此Mark也负伤在身，昏迷醒来后，进入自己的工作驻地后，开始为自己疗伤。忍着剧痛为自己封伤口，但为了生存，他咬牙完成了一切。于此同时，另一端的地球正在为他举行葬礼，Mark身体恢复后开始清点自己的食物、水，因为等到下次NASA来火星只能是4年后，所以他必须解决食物的问题，然后他自己开始种土豆，找土壤、找水，他一刻也没闲着，用自己的双手在不断的为延续自己的生命做着拼搏。Mark在火星种土豆电影中他为自己多了很多事，所有一切都是为了生命，看着他不停的奔波劳作，让我想到，一个深陷如此孤独的世界中的人，在没有丧失自己存活的希望后，还能如此的为自己明天而不断折腾，是多么不容易的一件事。恩，Mark是一个很乐观的人，能在这样一个与世隔绝的地方还能不断折腾的人，如果对自己不乐观、为未来不乐观，很难想象他能存活这么久。每个人每天每月每年都会面对很多事，需要自己处理，总归都要面对，我觉得保持乐观是一个良好的习惯。向Mark一样，即使有时会遇到一些很糟糕的情况，Mark后来的辛苦种植的土豆因为一个意外原因，全部被冻死，这对于他来说，就像农民伯伯辛苦一年后庄稼颗粒无收，这会是一种怎么样的绝望。他跟大多数人一样，Shit!爆了一句粗口，但是并没有陷入当前的糟糕状态，而是更加积极努力的去思考解决方式。人生总是这样，人生不如意十之八九，对待如意的时候，我们应该人生得意须尽欢,但是对待不如意的时候，我们不能今宵有酒今宵醉。我相信，保持乐观会让我们得到的更多，同时遇到问题不抱怨，及时找原因，总结教训，这才是最正确的做法。电影中有几个地方很让我感动。当他跟地面取得联系的时候,他要离开他的火星车的时候，以及他们他队长在太空中拥抱的时候。患难中的希望更加让人觉得来之不易，所以让他跟地面可以联系时，他很兴奋，因为自己再也不是一个人了。陪伴了他500多天的火星车，最终自己要离开它，就像《荒岛漂流》中鲁滨逊跟自己的排球告别时一样，火星车之与Mark，就像排球之于鲁滨逊。Mark在思考对火星车说点什么在描述告别的这段剧情时，导演特意用了整部电影中少有的比较抒情的音乐作为背景音乐，很感人的情景，突然觉得在火星呆了这么久，居然对这里的一切有点恋恋不舍了。Mark跟自己的火星车告别Mark离开火星车当他拥抱到队长时，这是他经过了所有的努力后，得到的应有的回报。一些人看上去总是很幸运的背后，往往是常人看不到的努力与付出。</li>
  <li>这篇文章是我的2015年终总结。去年就曾想过写一篇自己的2014年终总结，后来想过几天再写，然后一晃已经是2015年末了，时间就是这么快。我觉得今年一定要抽时间总结下，在梳理得与失的同时，也是对自己一年里，做的所有事的一个回忆和反思。这一年这一年发生了很多事，不论生活方面，还是工作方面，都经历了比去年更多的事。生活方面其实，这一年应该从媳妇跟我一起坐上来北京的列车开始。到北京后媳妇用了一个多月的时间找工作，在这一个多月里，我过了到北京后，迄今为止应该算是最舒适的一段日子。每天下班后回家，都会觉得是一件很特别让人期待的事，因为我不知道她又给我准备了什么好吃的，尽管一开始房间挺小挺拥挤，但却很温暖。后来因为经常一起做饭的缘故，自己炒菜水平在今年也大有长进，这也算是2015的一个收获。工作方面公司在年初时，内部就有了一些比较大的变动，裁员，高管离职(说的好像公司很大的样子)…好在我们移动开发团队比较稳定。老大一直都是自己很钦佩的那种技术人员，热衷技术，属于那种在技术上很执着的人，他一直说，他的主要任务就是让我们更happy的写代码，我们的开发的基础一直都是在他写的框架之上。关于这个框架，这里简单说下，是一种MVP+AOP模式的架构，项目做到了充分的解耦，对异步请求做了巧妙的控制。要知道这是他14年年初写的，那时MVP开发模式远没有现在这样被大家所熟知，我知道MVP这个模式一开始也是从这里得知。关于这个框架未来的发展，我们在组内会议时也讨论过，打算在15年开源，这是个美好的愿望。但是后来因为这样那样的原因最终未能如愿以偿。算是一个遗憾。自己是从去年14年加入公司，加入公司后，老大一直帮助自己理解和使用框架，自己也深深被这种高效率的开发模式所吸引，后来很长一段时间内，都是不停的做公司项目的功能迭代开发。相比去年，今年我开始着手一些模块的开发，开始自己一个人去负责开发优化模块，这段时间里，自己分别优化了项目中比较大的几个模块，其中的筛选模块是一个比较复杂的模块，最终经过自己三次版本迭代达到了自己心目中的理想状态。但后来被证明，自己因为大量使用枚举，以至于在后续维护时，出现了一些问题，而且在Android中大量使用枚举，也不是Android所推崇的，甚至Android的技术文档有这样的建议Enumsoftenrequiremorethantwiceasmuchmemoryasstaticconstants.YoushouldstrictlyavoidusingenumsonAndroid.到后来，年中的时候，老大离职了，尽管不舍，但是这却也是互联网公司中最普遍的现象。同时，这个时间段，随着公司业务的变化，我们的项目变得多了起来，新项目是在老项目基础上修改开发，但还要加入各种新功能，并且由于老项目是14年初的项目，加上新业务的一些变化，同时定了交付时间，那段时间(9-10月份)各种问题频出，其实是很煎熬的。同时那段时间，公司又经历了一次人员流动潮。那段时间真叫动荡。后来顶着压力，硬是把项目按时交接了，记得很清楚，有一天加了一个通宵的班，加到自己流鼻血！！！然后第二天早晨回到家，当我喝到媳妇给熬得粥的时候，突然觉得好感动~这次的人员变动，涉及到了我们Android团队，有两个同事相继离职，同时Android团队的负责人被也调去负责服务端，因为服务端负责人也已经离职（好混乱的局面），所以自己被提为Android负责人，因为Android团队人员偏少，所以接下来的一段时间，需要自己面试招聘新同学。面试持续了大概一个月时间。面试了10多人，水平层次不齐，在面试的同时我感受到了一些技术人员的浮躁，和一些泡沫的存在，个人水平、工作经历和期望薪资不匹配的有很多，这种现象也许这存在于整个互联网公司。但自己作为一个技术人员，如果为技术圈长远健康的发展考虑的话，我还是希望泡沫早点破灭的好，希望更多的人去重视个人技术的成长积累，而不要好高骛远的盲目追求高工资。最终经过内推，团队终于招到一个比较合适的同学。再后来，公司决定使用Web+Native的方式进行开发，算是一个比较大的调整，经过一个多月的时间，经过两个版本的迭代，最终搞定了最新的开发模式对应的框架。稍作感悟自己写之前也没有细想，写了之后，发现工作中具体而微的事挺多的，一年真是可以发生好多事，人走人来，项目变化，等等…一些有意义的事尽管工作中遇到的事挺多的，但是公司有一点一直特别好，不加班(严格点说是极少加班)，所以使得自己的业余时间还是比较多的，周末从来都是双休。自己在业余的时间也确实做了不少事(相比去年)。我一直是个闲不住的人，喜欢倒腾，对新东西总是充满好奇心，庆幸的是，自己的好奇心到现在也没减。一般的，工作之余的娱乐活动，除了我会去打球其余的时候，我更愿意自己倒腾点东西玩玩，相比往年，很明显今年做了跟多的有意思的事，下面简单罗列下。买了MAC这算是今年买过的最贵的一个物品，当时花了12000多，硬是找朋友从香港代购了一个15寸的低配MAC，其实我想买高配，但是当时正好没货，但现在到手的后来发现也没差到哪里。当时也是看到圈里好多同学都建议买买买，我也就没忍住，现在想想，这也算是2015年做得最正确的选择之一啊，否则此时此刻，我也不可能在飞机上听着音乐写博客！现在也是越来越喜欢它啦~哈哈！去了泰山一场说走就走的旅行，这是自己想了很久的一件事，但是从大学到现在，自己也没有真真的迈出过哪一步。今年11月初，终于，利用一个周末的时间，去了一次济南，自己选择济南，一是因为离北京比较近，二是因为我一个小学同学在济南读研，去济南顺便也是看他！青梅竹马的好基友周五晚上的火车，周六早晨就到济南，简单跟天哥（小学同学）吃过早饭，自己就迫不及待去了千佛山，自己一直很喜欢山川，千佛山不怎么高，没多久自己就到了山顶，后来自己一个人听着音乐穿梭在密林中，真真切切的感受到自由的存在，一种久违的感觉。行走在小路上后来接着去了趵突泉、大明湖，最让我影响深刻的还是周日去的泰山。我喜欢山，泰山作为五岳之首，我对它更是向往有加，从自己开始登泰山之前，就按奈不住自己激动的心情。仿佛自己像是实现了一个伟大的梦想一样。那种开心，不知怎么解释，也许是自己太久没有迈出这一步。后来到山顶后，我们尽情拍照纪念，毫不保留的把自己知道的pos摆个够。那就是最终的泰山顶会当凌绝顶，一览众山小故作眺望，哈哈~总之这是一个特别有意义的开始，也许以后去旅行，再也不会像这次这么激动，但我希望自己可以保持这种去旅游的冲动以及激情。使用Jekyll+Github搭建自己的个人博客以前经常在网上搜所一些技术信息时，经常能看非常精美的个人blog站点，以前只知道有WordPress，但是今年偶然看到某篇博客的评论里提到了Jekyll这个博客工具，然后自己一搜，发现还真是个好东西，然后自己马上动工做了自己的博客站点，就是现在这个。博客主要用于记录自己工作中遇到的问题，以及一些技术思考或者介绍，另外还可能有一些个人感悟等日志记录。总之不想把它定义为纯粹的技术博客，首先自己技术好没有到达那种传道授业的境界，另外还是想随意一点，不想太拘束了。说道博客，其实，一开始自己选择的模板并不是现在看到的样子，对那个老模板，自己曾花了不少时间去优化，但是最终的结果还是不够让人满意，直到10月24（程序员节）那天，偶然发现一个很不错的Jekyll主题，也就是现在这套，当时一看到首页那种大气，简单的设计，就认定它了。然后自己花了一个下午，给博客换主题，最终的结果让我很满意。关于换主题的过程，其实不是那么的顺利，那天（10月24）自己写了一篇日志用于记录我的一天，其中就有换主题的一部分介绍！我的1024这天后来自己在博客里写过几篇不错的文章，其中文章《在Android6.0设备上动态获取权限》曾被Android开发技术周报收录过一次。挺开心。开源了AppPlusAppPlus是自己做的一个手机App管理软件，为什么开发了AppPlus，按照我一直以来的习惯，这个App力争简单易用，一开始为了学习主题切换，曾加入过换肤等功能，后来觉得臃肿，最终还是去掉了。后来App被发布到四个主流的Android市场，其中在小米商店，目前已经有10万+的下载量，我始终相信，简单就是生产力！对产品对代码都是如此。开源地址小米市场下载参与干货集中营干货的收集年中的时候，偶然注意到了一个干货集中营这个技术站点，每个工作日更新技术干货信息，并对信息进行了分类，后来我觉得可以增加一个APP分类模块，每天推荐一些比较有意思、好玩的项目，最好开源，不分AndroidiOS,后来跟网站主编@代码家联系并说明自己想法，家家爽快的答应(merge)，然后自己也成了干货集中营的小编，每天为所有订阅读者挑选优质开源App项目。参与干货搜集中过程中，同时也认识了很多朋友，大家都热爱开源，喜欢交流，很开心能认识这么多人。为干货集中营开发客户端GankDaily在我为干货集中营开发这个客户端之前，干货集中营已经有三个Android客户端，用于展示干货信息，其实drakeet同学妹纸是一个非常有逼格的项目，自己在看了项目代码后，也是受益匪浅，项目使用很多新潮的技术。后来自己抱着学习的目的，开始模仿妹纸项目试图打造一个自己的干货客户端。尽管原项目代码已经很精简，但是视图层跟业务逻辑没分开，加上自己正好想实践下那段时间研究的MVP模式，所以自己开始重构项目。后来自己不仅在代码层面上进行大量的修改，将原有的项目结构完全使用MVP模式实现，在界面排版上也做了相应的改动。最中界面如下所示。后来项目发布后，因为自己的疏忽大意，跟drakeet同学造成了一点小误会。因为自己对开源协议的不重视和不够了解，导致自己侵犯了原作者的权利，不过后来经过交流，小风波就过去了，于此同时，自己也对开源协议有了一定的了解。开源协议小风波相关链接开源地址MVP模式在GankDaily中的应用涨了很多粉丝不论Github还是微博都涨了不少粉丝。记得年初Github只有7个粉丝，都是认识的同事，但截止现在已经120个粉丝，尽管这不是自己一直以来参与开源社区的动力，但是看到这么多人的认可，自己还是挺开心的。同时通过在开源社区的活动，让我更加认识到自己的渺小，在这里领域里，有太多牛人，自己要做的就是脚踏实地，朝着自己的方向，不停的前进，保持一个初学者心态。坚持打球从大学毕业开始，自己保持了最久的习惯莫过于此。自己是一个标准的篮球粉丝，特爱打球，工作后，即使工作再忙，周末的时间自己总会抽空去附近的球场打球。北理工的球场~今年亦如此，因为租住房间的附近有一个公园，公园中有一个球场，所以每周末，自己总会抽空去打球。每次打的大汗淋淋，出汗的感觉真好。结婚生子今年，我终于跟自己的高中同学完成了爱情长跑的升华。我们结婚了，一路走来，峰回路转，柳暗花明，终于，我们还是没有输给时间和距离。并且，最让人开心的算是我们有了爱情的结晶，我们的儿子顺利出生。对于这个可爱的小生命，我和媳妇都无比疼爱，有了他，我们的生活变得不一样。同时，也让我知道了自己的父母，在养育我们长大的这段旅程上，有多么不易。生命就像一场回溯。2015不足遗憾对一些技术了解不够深入，在能基本使用的基础上，没有去深入理解一些知识点。算法数据结构,待补技术类书籍看的比较多，但综合书籍看的少执行力欠缺还是太年轻了，容易轻信别人。2016希望计划有自己的房子（加油啊~）凡事预则立，不预则废，继续用好Wunderlist。翻译自己认为不错的国外文章（要求不高，明年必须翻译一篇）练字(练完一个本子)小心驶得万年船看书（不多，16年能看两本课外书就是成功）在GooglePlay上架应用(一个就行)学会Node.js(给自己的App搭建一个后台)继续学习PS(可以做ICON)坚持写博客(每月至少一篇)拍照记事，每天一记。保持好奇心。愿激情常在…更新于2016/02/14</li>
  <li>AppPlus是自己2015年七月份开始做的一个小产品，它是一个主要用Android用户间传送Apk文件、管理手机应用的工具软件。目前已开源，开源地址为什么要做这个软件一、我想用最少的步骤打开最近运行的应用详情界面因为是开发者的缘故，我经常需要清理应用缓存数据，一般的做法时，找到系统设置-&gt;应用管理-&gt;找到对应的应用-&gt;打开应用详情界面，然后清理数据，而且手机应用那么多，找应用也是个很麻烦的事，这个过程至少需要30秒左右的时间不止。不过在这一点上，MIUI做的不错，点击桌面菜单，显示出最近运行的应用列表，长按即可打开应用详情，在其他ROM上你只能去系统设置中找，好麻烦。当然在使用AndroidStudio进行开发的过程中，AS插件库里也已经有插件(adb-idea)可以做到一键清数据，但是他只能针对调试中的应用，如果我想清理其他APP的缓存，他就不行了。所以我需要一个APP能帮助我显示出最近打开的应用，并且提供一个按钮可以打开应用详情界面。Update:最近刚看到一个有用的Api可以方便的清除应用的缓存数据/***Permitsanapplicationtoeraseitsowndatafromdisk.*Thisisequivalenttotheuserchoosingtocleartheapp's*datafromwithinthedevicesettingsUI.Iterasesalldynamic*dataassociatedwiththeapp--itsprivatedataanddatainits*privateareaonexternalstorage--butdoesnotremovethe*installedapplicationitself,noranyOBBfiles.*/ActivityManager.clearApplicationUserData()这个方法由ActivityManager提供，可一键清理app产生的用户数据。二、我想方便快捷的导出手机中已安装应用的安装包一些情况下，开发者需要一些应用的安装包，比如自己以前因为做手机卫士没有合适的图标，所以只好找到360手机卫士的安装包，然后解压缩，从而使用现成的素材，谁叫自己不会PS呢，很多时候下载软件好办，Android市场那么多，只要自己想找，下载软件还是不难的，但是拿到对应的软件安装包好像不是那么容易。但事实上，只要在Android手机中安装了应用，这个应用的安装包就已经存在于手机了。这里说明一个事实，安装在我们手机中的每一个的APP，在手机中都存在他对应的安装包文件，不像Windows程序，当你下载好QQ的安装包QQ.exe,点击安装后，除非你人为保存安装包，系统是不会给你把安装包存下来的，Android不一样，他会把应用的安装包都存在本地。所以在Android手机上，只要知道了应用的安装包路径，导出还是挺容易的，不就是复制到一个自己指定的目录吗。这也不是什么高深的技术。另外，尽管市场上已经有很多可以提供导出安装包功能的软件，我为什么还要自己做一个?因为，他们都做得太low了。糟点太多。举个例子说明下。自己曾经用过一个安装包导出软件，首页用一个列表展示所有已安装的应用，然后只要点击一个item，安装包就会导出。导出成功后会『友好』的弹出一个Toast，提示安装包已导出，顺便在Toast中指明导出的路径，如下所示但是因为Toast的弹出时间太短了，以至于我一次很难记住安装包到底被导出到那个路径下了，所以一般你需要再次导出一次，然后特意去注意Toast上提示的路径，你才可以记住导出的路径。It’stoobad!当然，我在AppPlus中在实现导出Apk这一功能时，这个问题肯定得到了很好的解决。具体怎么解决，可以自己体验下试试。立即下载三、不喜欢广告。用户体验这么差，怎么好意思加广告！四、学习一方面学习GoogleIO2015大会新放出的最新的一些组件，另一方方面是学习实践MaterialDesign，因为自己太喜欢MD的设计风格了，没办法，尽管目前国内MD的设计风格还没有流行开，但是自己就是这么喜欢。综上所述，就是自己开发这个App的所有原因。</li>
  <li>这篇文章主要分享一个主题，如何在AndroidStudio中利用gradle查看自己项目中引入的三方依赖库的本地缓存路径。相信一些同学会对这个话题感兴趣的。问题自从使用AndroidStudio+Gradle开始项目开发，我们已经用到了很多gradle带来的特性，比如要在项目中使用三方Lib，我们再也不需要像eclipse时代，需要我们手动下载对应的jar包，从gradle开始，我们只要在build.gradle加入三方lib的dependencies路径，然后同步，lib就自动下载到本地了。例如，我们要在自己的项目中引用square公司的网络框架OkHttp，只需要在build.gradle文件中加一行依赖路径即可，如下所示compile'com.squareup.okhttp:okhttp:2.5.0'加入之后，同步，我们就可以使用okhttp提供的各种API，很简单的导入方式。但是时间久了，我就愈发想知道，gradle到底把lib给存到什么地方了，今天搜了一圈，找到一个靠谱的方法，特意分享下，也不是什么技术点，只是解决我心中的一个疑问而已。答案dependencies{.....}//显示依赖包的存储路径taskshowMeCache&lt;&lt;{configurations.compile.each{printlnit}}如上所示，只需要在build.gradle文件中，增加如上所示的一个task,然后打开AndroidStudio自带的Terminal窗口，执行gradleshowMeCache即可看到所有依赖的对应路径，Note:因为gradle文件顺序执行的特点，这个任务应该定义在dependencies节点之下。结果:app:showMeCache/Users/mao/workpace/person/AppPlus/app/libs/lite-orm-1.7.0.jar/Users/mao/workpace/person/AppPlus/app/libs/umeng-update-v2.6.0.1.jar/Users/mao/Downloads/android/sdk/extras/android/m2repository/com/android/support/appcompat-v7/23.1.1/appcompat-v7-23.1.1.aar/Users/mao/Downloads/android/sdk/extras/android/m2repository/com/android/support/design/23.1.1/design-23.1.1.aar/Users/mao/.gradle/caches/modules-2/files-2.1/com.jenzz/materialpreference/1.3/def38f1784f5f789b10ed388e385f7857e765405/materialpreference-1.3.aar/Users/mao/.gradle/caches/modules-2/files-2.1/com.readystatesoftware.systembartint/systembartint/1.0.3/de4f7404e2f58d8f6e83cb1e85d0c2d6c2987287/systembartint-1.0.3.jar/Users/mao/Downloads/android/sdk/extras/android/m2repository/com/android/support/gridlayout-v7/22.2.0/gridlayout-v7-22.2.0.aar/Users/mao/.gradle/caches/modules-2/files-2.1/com.umeng.analytics/analytics/5.6.4/76fed6d2233b958f0c1d589aa366785e0ab5c8f1/analytics-5.6.4.jar/Users/mao/Downloads/android/sdk/extras/android/m2repository/com/android/support/percent/23.1.0/percent-23.1.0.aar/Users/mao/.gradle/caches/modules-2/files-2.1/com.jaredrummler/android-processes/1.0.2/704bbcb3f6d25c5da24b3e0199b178520ad7ca7e/android-processes-1.0.2.aar/Users/mao/Downloads/android/sdk/extras/android/m2repository/com/android/support/support-v4/23.1.1/support-v4-23.1.1.aar/Users/mao/Downloads/android/sdk/extras/android/m2repository/com/android/support/recyclerview-v7/23.1.1/recyclerview-v7-23.1.1.aar/Users/mao/Downloads/android/sdk/extras/android/m2repository/com/android/support/support-annotations/23.1.1/support-annotations-23.1.1.jarEnjoyit.</li>
  <li>今天无意间在做项目的过程中，因为没有遵守开源协议，导致了一个小误会，尽管已经跟drakeet同学致歉，但后来还是觉得有必要把事情再梳理一遍，让更多的开发者注重一下开源协议。一开始在微博看到了@drakeet同学开源了一个项目，叫MeiZhi，一个干货集中营的unofficial客户端，客户端用于在手机端更好的显示技术干货信息，因为自己平时也比较关注技术干货，自己也就开始使用。整个客户端一开始都是drakeet一个人设计开发完成，其实对于程序员来说，写代码、开发往往是最轻松的事，最难的往往是设计，最终drakeet的干货客户端给人的视觉操作体验整体还是非常不错的，其中有很多细节，完成的很不错。后来自己阅读了源码，更是对代码钦佩不已。项目中使用了RxJavaRetrofit以及JAVA8新特性lambda，整个项目代码很简洁，很优雅。因为自己之前没有接触RxJava等知识，所以自己想仿照项目，自己动手实践一边RxJava的语法内容，以及lambda，因为我相信实践出真知，后来自己就new了一个项目，开始使用干货集中营的api进行开发，开始动手练习后来在写页面的时候，觉得把所有的数据获取逻辑写在Activity中其实不好，这样Activity会显得臃肿，正巧那段时间，大家在讨论MVP，所以自己就干脆使用MVP来做项目，毕竟是小项目，重构起来还是挺方便，重构很顺利。在重构完成后，我觉得自己已经不是在单纯的练习一些语法知识了，发现自己其实在做一个客户端。因为我想突出干货内容，所以后来就把干货首页改为了当天的干货信息，也就是下面的样子。同时为了突出时间，还对图片做了亮度的调节，所以图片看上去暗点，这样时间也就显得更清楚一点。后来代码被自己review了好几次，然后尝试发beta版，在一些开发者朋友的反馈下，自己又改了一些细节，然后就把应用发布了，同时代码也公布在github。其实一开始，我是知道原项目是基于一个开源协议发布的，因为自己在看代码的过程中也多次看到drakeet在代码中的协议内容，包括在MeiZhi的Readme文件中也有这样的字样但是自己没有花精力去像思考代码结构那样思考开源协议，然后就把代码公布，这也许是很多开发者不注意的问题。对于我们而言很多时候都会把精力集中在具体的代码，而对于代码之外的一些东西往往会很容易忽略。通过这件事提醒我们，作为开发者应该了解一些开源协议的问题，开源协议有很多，但是常用的就那些。自己事后也开始找一些开源协议相关的资料,聊聊Apache开源协议@kymjs张涛此外，drakeet同学也提供一张有用的图片，如下所示，关于开源协议如果有更好的资料欢迎补充，自己最近也会多多学习并了解这方面！再次感谢drakeet同学的及时指正，我的项目GankDaily也会尽快按照协议进行修正！不过最近因为自己的时间问题可能无法及时更新代码，可能需要过段时间才可以，不过开源协议这块，以后自己一定会注意到！当然说这么多，也希望大家可以在以后的工作开发中，注意到这个问题的存在，让我们一起对开源协议保持敬畏并了解学习使用它。附：文中出现的一些链接干货集中营http://gank.io/妹纸https://github.com/drakeet/MeizhiGankDailyhttps://github.com/maoruibin/GankDaily聊聊Apache开源协议http://kymjs.com/manager/2015/11/21/01/</li>
  <li>最近完成了一个干货客户端GankDaily，一个基于干货集中营的手机客户端，整个客户端借鉴drakeet的妹纸应用。但是在原项目的基础上，自己使用MVP模式对项目进行重构，让代码结构进一步解耦，使业务逻辑和视图表现层相分离，从而让代码逻辑变得更简单，以下就整理了自己在重构项目过程中对MVP这种模式的理解以及项目中如何实施MVP的模式。关于MVPMVP是Model-Presenter-View的缩写，翻译过来就是模型-控制器-视图，是一种流行的开发架构模式。他主张让Presenter控制所有的业务逻辑，让View层做具体的界面更新，Model专门负责数据获取等操作。通常我们写惯了Android项目，一般一个Activity中可能对应很多数据交互，比如这个干货客户端首页，只要一进入首页，它需要获取当天的干货数据。滑动到底部需要加载更多数据，除此之外还可能有一些其他的业务逻辑比如检查版本信息等。一般的，这些操作全部放在Activity中没有任何问题的，这样做一点不妨碍你完成所有的功能。而且市面上确实有不少项目真是这么做的，最近跟一些朋友聊天，也说过他负责的项目就是这么干的，一个Activity6000多行代码，简直是灾难~不过自己一开始写代码时，确实也是这样写的（囧~），记得曾经写过一个详情展示页，代码写了2000多行，当时觉得还挺自豪(呵呵~)，一个类2000多行呢，现在想想也是觉得TooYoungTooSimple.按照MVP的定义，我们应该把所有的业务逻辑操作都写在Presenter层，而View层(View层一般由Activity、Fragment充当)他们主要做一些更新界面、向Presenter层发送请求的操作。Model层则主要负责具体的数据获取操作。他们的具体关系可以看下面这张图。由图可以清楚的看到，Presenter处在一个中心位置，View层向Presenter发送请求，Presenter自己接受请求，但是自己不具体执行请求，而是将具体的事情交给Model去处理，利用Model层请求完毕后，Presenter再把具体的结果通过某种方式响应在View层。一个例子上面说的有点抽象，其实这个过程可以理解的更加形象一点。打个比喻，把P理解为自己的脑袋，V理解为右手M理解为左手,然后你就站在那里，假设左右手是不能直接沟通，左右手分别通过左胳膊和右胳膊与脑袋联系。现在V(右手)需要100块钱进行消费，但是钱却存储在M(左手)里，这时V(右手)通过右胳膊告诉P(脑袋)，”脑袋，我需要100块钱，快给我。”，脑袋得到这个命令后，因为自己不管钱，所以只得去请求M(左手),P（脑袋）通过左胳膊告诉M(左手),说自己需要100块钱，M(左手)知道P需要钱，所以就慷慨的给钱,谁叫他是老大呢，此时P顺利拿到钱后，自己对钱稍微做一些验证操作，发现钱没问题，然后就把钱给了V（右手），此时为了安全起见，P(脑袋)需要调用一下V(右手)提供的一个握拳方法，以便及时的攥住钱，防止遗失，假设这个方法就叫hold吧，P调用V(右手)的hold方法后，右手在拿到钱的同时，就立即攥紧了钱，这样钱就不容易被别人拿走了。到这里，整个一次完整的数据交互(左手取钱)、界面更新(右手攥钱)过程就结束了，M自始至终也没有跟V发生任何直接关系，它甚至不知道V的存在。P则在最中央的位置负责协调数据、操作View。他从左手拿钱，然后交给右手。当然还可以更多复杂的操作，但是整个MVP的大体结构就是这样。如果这个比喻觉得不清楚，那么你可以直接去看鸿洋之前写的一篇博客，用一个登录示例讲解MVP，讲的很清楚。浅谈MVPinAndroid几个疑问到这里可能会有几个疑问，在View(Activity、Fragment)层中怎么去调用Presenter中的方法？这个简单，在View初始化时，new一个Presenter实例不就对了吗，确实可行，我目前也是这样做的。Presenter怎么去控制View中的界面逻辑？具体点就是，上面的头部最后怎么调用右手的hold()方法？这里需要通过让View层通过实现特定View接口，每一个View类，也就是每一个Activity对应实现一个抽象的接口，也就是说在写每个Activity时，首先把具体的View操作动作提取为一个接口，让View实现，让后想办法把这个接口的实例传递到Presenter实例中即可，这里可能稍微有点模糊，但是通过下面具体的代码，你可能就更清楚了。MVP实践可以先看看主界面。如下图，主界面MainActivity显示的是当天的干货信息，下拉可刷新，滑动到底部可以加载更多，进入主界面还需要去检查版本信息，如果发现是新版本，好需要弹出一个Dialog显示更新日志。大概的业务也就这些，然后我们把所有的业务逻辑都写在MainPresenter中，代码如下，部分代码省略，如果想看全部代码，点击源码publicvoidgetData(finalDatedate){mCurrentDate=date;mGuDong.getGankData(year,month,day).observeOn(AndroidSchedulers.mainThread()).subscribe(newSubscriber&lt;List&lt;Gank&gt;&gt;(){@OverridepublicvoidonCompleted(){//aftergetdatacomplete,needputofftimeonedaymCurrentDate=newDate(date.getTime()-DAY_OF_MILLISECOND);}@OverridepublicvoidonError(Throwablee){}@OverridepublicvoidonNext(List&lt;Gank&gt;list){//somedaythedatawillbereturnemptylikesunday,soweneedgetafterdaydataif(list.isEmpty()){getData(newDate(date.getTime()-DAY_OF_MILLISECOND));}else{mCountOfGetMoreDataEmpty=0;mView.fillData(list);}mView.getDataFinish();}});}publicvoidcheckAutoUpdateByUmeng(){if(mContext.getIntent().getSerializableExtra("BUNDLE_GANK")==null){UmengUpdateAgent.setUpdateCheckConfig(BuildConfig.DEBUG);//checkupdateevenin2g/3g/4gconditionUmengUpdateAgent.setUpdateOnlyWifi(false);UmengUpdateAgent.update(mContext);}}//checkversioninfo,iftheversioninfohaschanged,weneedpopadialogtoshowchangeloginfopublicvoidcheckVersionInfo(){StringcurrentVersion=AndroidUtils.getAppVersion(mContext);StringlocalVersionName=AndroidUtils.getLocalVersion(mContext);if(!localVersionName.equals(currentVersion)){mView.showChangeLogInfo("changelog.html");AndroidUtils.setCurrentVersion(mContext,currentVersion);}}/***@return*/publicbooleanshouldRefillData(){return!hasLoadMoreData;}从上面可以看到，获取数据的方法getData(Datedate)接受一个date参数，调用者MainActivity只需要在某个地方调用这个方法，并传递当前的日期，就可以获取到当前所有的干货数据。到这，View请求Presenter完成。下面具体执行数据请求就是另外的模块了。这里从具体代码看，可以发现，数据请求是通过Rxjava+Retrofit实现，如下所示publicvoidgetData(finalDatedate){mCurrentDate=date;Calendarcalendar=Calendar.getInstance();calendar.setTime(date);intyear=calendar.get(Calendar.YEAR);intmonth=calendar.get(Calendar.MONTH)+1;intday=calendar.get(Calendar.DAY_OF_MONTH);//获取到年月日三个参数，准备传递给具体的方法。mGuDong.getGankData(year,month,day).observeOn(AndroidSchedulers.mainThread()).map(newFunc1&lt;GankData,GankData.Result&gt;(){@OverridepublicGankData.Resultcall(GankDatagankData){returngankData.results;}}).map(newFunc1&lt;GankData.Result,List&lt;Gank&gt;&gt;(){@OverridepublicList&lt;Gank&gt;call(GankData.Resultresult){returnaddAllResults(result);}}).subscribe(newSubscriber&lt;List&lt;Gank&gt;&gt;(){@OverridepublicvoidonCompleted(){//获取数据完毕，将日期推迟到下一天为获取更多数据做准备mCurrentDate=newDate(date.getTime()-DAY_OF_MILLISECOND);}@OverridepublicvoidonError(Throwablee){}@OverridepublicvoidonNext(List&lt;Gank&gt;list){//如果有一天数据为空，则继续获取下一天的数据if(list.isEmpty()){getData(newDate(date.getTime()-DAY_OF_MILLISECOND));}else{//更新主界面数据mCountOfGetMoreDataEmpty=0;mView.fillData(list);}mView.getDataFinish();}});}在onNext方法中，我们获取到了最终的数据，此时Presenter需要通知View更新界面，所以这里有了如下的调用@OverridepublicvoidonNext(List&lt;Gank&gt;list){//如果有一天数据为空，则继续获取下一天的数据if(list.isEmpty()){getData(newDate(date.getTime()-DAY_OF_MILLISECOND));}else{//更新主界面数据mCountOfGetMoreDataEmpty=0;mView.fillData(list);}mView.getDataFinish();}这里通过mView这个实例的fillData方法去更新主界面。那么mView是一个什么变量呢，最终你会发现，他是一个IMainView接口的实例，可以看看这个接口是怎么定义的。publicinterfaceIMainView&lt;TextendsSoul&gt;extendsISwipeRefreshView{/***loaddatasuccessfully*@paramdata*/voidfillData(List&lt;T&gt;data);/***appenddatatohistorylist(loadmore)*@paramdata*/voidappendMoreDataToView(List&lt;T&gt;data);/***nomoredataforshowandthisconditionishardtoappear,itneedyouscrollmainviewlongtime*Ithinkithasnobodydoitlikethis,eventhough，Idealthisconditionalso,Incasesomeonedoesit.*/voidhasNoMoreData();/***showchangeloginfoinadialog*@paramassetFileNamethenameoflocalhtmlfilelike"changelog.html"*/voidshowChangeLogInfo(StringassetFileName);}发现这个接口中确实存在一个fillData方法，所以上面使用mView调用fillData是可行的。那如果MainPresenter都可以调用IMainView的fillData()方法来更新MainActivity,哪MainActivity就和IMainView有必然的关系，一个是类一个是接口，还能会有什么关系呢，这里MainActivity实现了IMainView这个接口。publicclassMainActivityextendsBaseSwipeRefreshActivity&lt;MainPresenter&gt;implementsIMainView&lt;Gank&gt;,MainListAdapter.IClickMainItem{既然MainActivity实现了IMainView接口，那他必然实现对应的方法fillData(),如下所示@OverridepublicvoidfillData(List&lt;Gank&gt;data){mAdapter.updateWithClear(data);}可以看到，实现很简单，就是更新一下Adapter就OK，Activity中再也看不到任务获取数据的代码。到这里，让我们看看MainPresenter是在MainActivity的什么地方实例化的。这里因为每个Activity都是继承自BaseActivity，而且每个Activity必须有一个Presenter,所以我在BaseActivity中已经事先定义了一个BasePresenter的实例mPresenter，同时给BaseActivity设置一个抽象方法initPresenter()。这个方法将会在BaseActivityonCreate时执行到。代码如下所示publicabstractclassBaseActivity&lt;PextendsBasePresenter&gt;extendsAppCompatActivity{@Bind(R.id.toolbar)protectedToolbarmToolbar;/***thepresenterofthisActivity*/protectedPmPresenter;/***TODOuseDagger2instancePresenter*/protectedabstractvoidinitPresenter();@OverrideprotectedvoidonCreate(BundlesavedInstanceState){super.onCreate(savedInstanceState);setContentView(getLayout());ButterKnife.bind(this);initPresenter();checkPresenterIsNull();initToolBar();}privatevoidcheckPresenterIsNull(){if(mPresenter==null){thrownewIllegalStateException("pleaseinitmPresenterininitPresenter()method");}}}设置抽象方法的目的就是强制每个继承自BaseActivity的Activity类都必须实现这个方法，并实例化BasePresenter；如果不实例化mPresenter，可以看到在onCreate中对mPresenter是否已经设置值做了checkPresenterIsNull()处理,只要发现mPresenter为null这里就会报错。MainActivity继承自BaseActivity，所以它实现了initPresenter()方法。MainActivity中initPresenter@OverrideprotectedvoidinitPresenter(){mPresenter=newMainPresenter(this,this);}这里可以到MainPresenter的构造函数传递了两个参数。可以查看MainPresenter的构造方法publicMainPresenter(Activitycontext,IMainViewview){super(context,view);}它直接调用自己父类BasePresenter的构造方法，这里可以看看BasePresenter类，很简单。publicclassBasePresenter&lt;GVextendsIBaseView&gt;{protectedGVmView;protectedActivitymContext;publicstaticfinalGuDongmGuDong=MainFactory.getGuDongInstance();publicBasePresenter(Activitycontext,GVview){mContext=context;mView=view;}}可以看到这里的两个参数分别是Activity和IBaseView的实例，IBaseView是所有抽象View接口的父接口(目前是一个空接口)，IMainView继承自IBaseView。这里就可以看到其实每个Presenter中都有一个IBaseView的实例，只要在Activity实例化了Presenter实例，那么对应的IBaseView实例其实也已经传递到了Presenter中，这样只要是界面更新的操作，我们就可以方便的调用IBaseView中的接口了。再看一下MainPresenter中的onNext方法。@OverridepublicvoidonNext(List&lt;Gank&gt;list){//如果有一天数据为空，则继续获取下一天的数据if(list.isEmpty()){getData(newDate(date.getTime()-DAY_OF_MILLISECOND));}else{//更新主界面数据mCountOfGetMoreDataEmpty=0;mView.fillData(list);}mView.getDataFinish();}此时mView调用fillData()方法，应该已经清楚了吧。总结至此，MVP大概就说完了，可以看看项目接口，也许会看到更清楚一点。此外，还用到了一些泛型的知识点，用来约束Base类的类型，大家有看着不明白的地方，可以留言。</li>
  <li>从Android5.0开始，系统提供一个很好看的Activity间的转场动画，具体就是共享两个界面中一些共有的View，让前后两个界面的跳转变得很流畅好看。具体效果一图胜千语,下面就是Android5.0设备上使用转场动画后示意图，这样的交互在Google自家的App里已经司空见惯。比如GooglePlay中，从应用列表界面跳转到应用详情页，就使用了类似的转场动画。下面的示意gif来自Android官方Demo。看上去确实很好看,使用后让原本硬生生的界面跳转变得特别自然。那怎么实现呢,简单分析下。现在有两个Activity分别为MainActivity和DetailActivity。MainActivity中是一些动物的列表展示，每个Item包含一个动物图片和动物名称。点击Item需要跳转到对应动物的详情介绍页。详情介绍页，会显示动物的大图，名称以及这个动物的详细介绍。因为两个界面中动物的图片和名称是一致的,也就是说这两个界面有共有的View元素,所以这种场景就比较适合用转场动画来优化交互逻辑，现在点击MainActivity的Item，需要产生一个转场动画来到达详情页。下面就是具体实现方式。实现方法1、在DetailActivity中为指定的View设置一个字符串的标记//Viewnameoftheheaderimage.UsedforactivityscenetransitionspublicstaticfinalStringVIEW_NAME_HEADER_IMAGE="detail:header:image";//Viewnameoftheheadertitle.UsedforactivityscenetransitionspublicstaticfinalStringVIEW_NAME_HEADER_TITLE="detail:header:title";2、使用ActivityCompat启动目标ActivityIntentintent=newIntent(this,DetailActivity.class);intent.putExtra(DetailActivity.EXTRA_PARAM_ID,item.getId());/***通过ActivityOptionsCompat的工厂方法创建一个ActivityOptions实例*/ActivityOptionsCompatactivityOptions=ActivityOptionsCompat.makeSceneTransitionAnimation(this,//关联两个界面中的共有View元素newPair&lt;View,String&gt;(itemView.findViewById(R.id.imageview_item),DetailActivity.VIEW_NAME_HEADER_IMAGE),newPair&lt;View,String&gt;(itemView.findViewById(R.id.textview_name),DetailActivity.VIEW_NAME_HEADER_TITLE));//启动目标ActivityActivityCompat.startActivity(this,intent,activityOptions.toBundle());3、在DetailActivity的onCreate方法中接受并处理//找到detail界面中的View元素mHeaderImageView=(ImageView)findViewById(R.id.imageview_header);mHeaderTitle=(TextView)findViewById(R.id.textview_title);//关联ViewCompat.setTransitionName(mHeaderImageView,VIEW_NAME_HEADER_IMAGE);ViewCompat.setTransitionName(mHeaderTitle,VIEW_NAME_HEADER_TITLE);总结总体说来使用还是挺简单的,这个效果尤其对图片类应用特别棒,不过目前只有5.0以上设备才能支持这个效果,如果想要兼容5.0以下的设备,你可能需要去Github搜搜有没有合适库。</li>
  <li>众所周知，Android6.0相比之前的Android版本有一个很大的不同点，就是动态获取权限。今天自己在做拨号功能时，正巧遇到这个问题，顺手记录下在Android6.0上如何动态获取权限。下面从自己一开始的问题入手实现拨号功能说到拨号，一个Intent就搞定，代码如下，privatevoidcallDirectly(Stringmobile){Intentintent=newIntent();intent.setAction("android.intent.action.CALL");intent.setData(Uri.parse("tel:"+mobile));mContext.startActivity(intent);}当然你可别忘了在Manifest文件中去声明拨号的权限&lt;uses-permissionandroid:name="android.permission.CALL_PHONE"/&gt;问题如果在Android6.0以前的设备上，上面的代码都是没有问题的，但是如果是在Android6.0设备上，并且项目的targetSdkVersion你设置的是23，那么当你执行上面的拨号代码时，程序将会奔溃掉。此时你肯定想到了如果targetSdkVersion值设置的小于23是不是就不会奔溃了，恩，确实如此，此时即使使用Android6.0的设备，程序也不会奔溃，原因显而易见，Android的权限机制是AndroidM后才加入的。从AndroidM开始应用程序申请的权限是在运行时动态赋给用户的。关于动态分配权限，一些同学可能不是很清楚。这里稍稍提一下Android6.0的权限动态分配。如果你只对最终的解决方案感兴趣，可以跳过下面这节，直接去看解决方案权限动态分配在Android6.0之前，下载好一个应用程序，点击安装我们看到的大都是像这样的界面。上图分别是Nexus6和小米手机在安装软件时的界面。在安装时你会发现，手机操作系统会提示，这个软件会索要了你手机的那些权限，并且给用一个列表进行展示，但是这些提示只是在安装是提示，只要你点击接受或者安装，表示你允许这个应用在可以获取它申明的所有权限。一般很少有人在安装时，会因为看到某个应用因为申请了某一个敏感权限而放弃安装应用。因为这个权限虽然敏感，但是对于当前的用户是不可感知的，因为他现在并没有立即去查看你的最近通话、短信记录…说到这里，我们自然而然的会想到，其实最好的方式是，当这个应用在用户使用过程中，正准备使用某个权限时，比如说读取短信列表，系统能及时的弹出一个提示框，说这个应用要读取您的短信内容，您是否允许。然后用户结合当前应用的执行动作，依据当前条件判断，是不是应该授予应用读取短信记录的权限。这绝对的最完美的。因为在具体的使用过程中，用户可以结合当前应用的使用场景，去思考、判断是不是应该给这个应用相应的权限。不给能怎样，给了会怎样，这样对用户而言，完全是主动的，相比安装时那种选择，这样的做法无疑是对用户莫大的尊重，同时这也保证了用户的个人隐私。说到这里，不得不插一句，其实MIUI早就实现了这个系统特性，在这一点上MIUI确实走到了Android团队的前面，恩，给MIUI点个赞。然而直到Android6.0这个版本开始，上面的假设终于得到了谷歌的实践，除了在应用安装时，操作系统会提示应用会获取那些权限，在运行过程中，当应用去真的获取一些敏感权限时，系统还会弹出一个提示框，询问用户是不是授予应用相应的权限。如下图所示。这就是Android6.0的运行时权限检查机制。下面是Google官方对此的解释，只截取介绍部分BeginninginAndroid6.0(APIlevel23),usersgrantpermissionstoappswhiletheappisrunning,notwhentheyinstalltheapp.Thisapproachstreamlinestheappinstallprocess,sincetheuserdoesnotneedtograntpermissionswhentheyinstallorupdatetheapp.Italsogivestheusermorecontrolovertheapp'sfunctionality;forexample,ausercouldchoosetogiveacameraappaccesstothecamerabutnottothedevicelocation.Theusercanrevokethepermissionsatanytime,bygoingtotheapp'sSettingsscreen.解决方案其实上面已经说了一种取巧的方案，将targetSdkVersion设为小于23的值，程序将不会奔溃，但是在Android6.0上你的应用程序依旧拨不了电话，这是真的。所以要想兼容6.0版本，必须通过下面的方式进行代码层面的兼容。对Android版本做判断，然后对Android6.0做特殊处理，代码如下finalpublicstaticintREQUEST_CODE_ASK_CALL_PHONE=123;publicvoidonCall(Stringmobile){this.mMobile=mobile;if(Build.VERSION.SDK_INT&gt;=23){intcheckCallPhonePermission=ContextCompat.checkSelfPermission(mContext,Manifest.permission.CALL_PHONE);if(checkCallPhonePermission!=PackageManager.PERMISSION_GRANTED){ActivityCompat.requestPermissions(mContext,newString[]{Manifest.permission.CALL_PHONE},REQUEST_CODE_ASK_CALL_PHONE);return;}else{//上面已经写好的拨号方法callDirectly(mobile);}}else{//上面已经写好的拨号方法callDirectly(mobile);}}此时，如果一个Android6.0的用户触发拨号动作，执行上面的代码，那么他将会看到一个很好看的MaterialDialog，如下图所示。那么用户点击拒绝或者允许，我们怎么才能拿到回调呢，如果能拿到回调，我们就可以根据用户的选择来执行不同的操作了。这里应该会看到在ActivityCompat的requestPermissions方法中，最后一个参数是一个requestCode，看到它自然而然想到了经常用到的onActivityResult，这里当执行ActivityCompat的requestPermissions方法后有一个回调机制，需要我们在当前Activity中实现onRequestPermissionsResult这个方法，具体如下@OverridepublicvoidonRequestPermissionsResult(intrequestCode,String[]permissions,int[]grantResults){switch(requestCode){caseREQUEST_CODE_ASK_CALL_PHONE:if(grantResults[0]==PackageManager.PERMISSION_GRANTED){//PermissionGrantedcallDirectly(mobile);}else{//PermissionDeniedToast.makeText(MainActivity.this,"CALL_PHONEDenied",Toast.LENGTH_SHORT).show();}break;default:super.onRequestPermissionsResult(requestCode,permissions,grantResults);}}这里会对提供了一个对用户点击做判断的入口，开发者可以根据grantResults[0]的类型，来判断用户点击的是允许还是拒绝，接着就可以执行相应的逻辑了。有用的链接关于AndroidM上权限的动态获取，这里只给出了一个最简单的示例，如果你还没有尽兴，那么下面这篇国外的博文，一定会让你满足。EverythingeveryAndroidDevelopermustknowaboutnewAndroid’sRuntimePermission这篇英文博文内容很长、内容也比较多，十足的干货。您慢用~后记：偶然发现已经有哥们把上面的这篇文章做了翻译，真是极好的，附上翻译链接，给翻译者同学点赞，辛苦！另外，最近看到一个Github上的开源项目PermissionHelper，专门用于处理Android6.0的权限兼容问题。</li>
  <li>图片是Android应用常见的资源，在Android中，图片数据用Bitmap这个类封装。这篇文章整理跟他相关的一些知识点。1、Bitmap.Config这是Bitmap的一个内部类(枚举)，是Bitmap关于色彩显示的配置，不同的配置对应不同的加载效果，下面是相应的文档介绍Possiblebitmapconfigurations.Abitmapconfigurationdescribeshowpixelsarestored.Thisaffectsthequality(colordepth)aswellastheabilitytodisplaytransparent/translucentcolors.它包含四个枚举值，分别如下Bitmap.Config{ALPHA_8ARGB_4444ARGB_8888RGB_565}具体这四个值分别代表了色彩的不同存储方式。这四个值指定了每一个像素的所占数据的大小，每个像素点都是1byte整数倍的数据。ALPHA_8代表每个像素点只占一个字节的大小，这个字节仅仅存储跟透明度相关的数据。ARGB_4444代表16位ARGB位图ARGB_8888代表32位ARGB位图，Android默认加载图片使用此种配置，所以每个像素占4字节。RGB_565代表8位RGB位图当然像素点占用的字节越多，他所存储的信息也就越多，图像也就越逼真，同时占用的内存也就越大。2、大图缩放处理设想一下自己手机拍了一张图片大小为3120*4204，默认使用ARGB_8888的色彩存储方式，当把它加载到内存时，他的大小会是3120*4204*4=52465920字节除以1024*1024等于50兆，通常的手机给每一个应用分配的内存大小，小点的也就16、32兆左右，大点的64、96M左右的样子。这样的情况下，如果加载两张图片后，内存就不够了，此时虚拟机自动执行垃圾回收，因为图片很可能正在使用中，属于强引用，此时是很难把图片占用的这部分内存回收掉，所以如果按照原尺寸加载图片，很容易出现OOM。加上我们实际需要显示的尺寸比真实图片尺寸小很多，所以，通常我们都会在图片显示时，对图片进行压缩处理，方法大都一样1、计算图片实际宽高BitmapFactory.Optionsoptions=newBitmapFactory.Options();//只加载图片边界信息到内存options.inJustDecodeBounds=true;BitmapFactory.decodeResource(getResources(),R.id.myimage,options);//获取图片的真实宽高intimageHeight=options.outHeight;intimageWidth=options.outWidth;2、根据给定尺寸，计算缩放比publicstaticintcalculateInSampleSize(BitmapFactory.Optionsoptions,intreqWidth,intreqHeight){//Rawheightandwidthofimagefinalintheight=options.outHeight;finalintwidth=options.outWidth;intinSampleSize=1;if(height&gt;reqHeight||width&gt;reqWidth){finalinthalfHeight=height/2;finalinthalfWidth=width/2;//CalculatethelargestinSampleSizevaluethatisapowerof2andkeepsboth//heightandwidthlargerthantherequestedheightandwidth.while((halfHeight/inSampleSize)&gt;reqHeight&amp;&amp;(halfWidth/inSampleSize)&gt;reqWidth){inSampleSize*=2;}}returninSampleSize;}3、根据计算出的缩放比，对图片执行缩放处理publicstaticBitmapdecodeSampledBitmapFromResource(Resourcesres,intresId,intreqWidth,intreqHeight){//FirstdecodewithinJustDecodeBounds=truetocheckdimensionsfinalBitmapFactory.Optionsoptions=newBitmapFactory.Options();options.inJustDecodeBounds=true;BitmapFactory.decodeResource(res,resId,options);//CalculateinSampleSizeoptions.inSampleSize=calculateInSampleSize(options,reqWidth,reqHeight);//DecodebitmapwithinSampleSizesetoptions.inJustDecodeBounds=false;returnBitmapFactory.decodeResource(res,resId,options);}上述方法只针对一般意义上的大图，对于像长微博这种超大图片加载，仅仅依靠上述的方法是不能达到目的的，此时需要借助其他的方法工具进行特殊处理,如局部加载等机制，这里不展开讨论，具体可参考下面的两个链接。Android高清加载巨图方案拒绝压缩图片WorldMap参考资料Bitmap那些事之内存占用计算和加载注意事项高效加载大图</li>
  <li>“生活不止眼前的苟且，还有诗和远方”今天是10月24，也就是所谓的程序员节，很多程序员朋友今天都是关上电脑，挂着免战牌，或游戏、或聚会玩耍…恩，我是个例外。以下纯粹以流水账的形式记录了我的一天。如有雷同，纯属巧合。早晨9点起床，在洗漱的同时给自己做了个荷包蛋，因为上周买的老北京糖火烧还有三个没吃，所以2个荷包蛋+1个糖火烧就做了我的早餐，这配置还不错，哦，不对，应该是搭配。吃完早餐，是时候去早市买点蔬菜水果了，上周买下的水果都已经吃光了，蔬菜只剩下两个大白萝卜还有一些小胡萝卜以及若干西红柿。拿起钥匙骑上我的自行车，很快就到了每周必去的早市。今天也没买什么特别的，买了点新鲜的蔬菜如芹菜、大葱，买芹菜主要是想炒猪肉吃，哈哈，然后买了些水果，香蕉、橘子之类的。很快双手已经满满得了，其实早市的鱼也相当不错，一斤大小的鲫鱼8块多钱，价格真的很惠民。但是自己懒得做鱼，况且做的也不好，想想还是算了。撤~中午回来后，房间还不算很乱，也没什么好收拾的，然后跟媳妇在微信上汇报了一下今天的早市战绩，一切OK，然后坐在阳台的沙发上，享受下阳光的温暖，顺便给自己老妈打了个电话。恩，远在北京，父母看不到你，还是很挂念儿女的，每周一个电话不能少！！不知不觉一点了，也该吃饭了。想了想，一定要把刚买的芹菜吃了，新鲜，炒肉吃一定很香。接着洗了芹菜、摘了菜叶，然后切了段大葱和生姜，从冰箱中取出上周才买的猪肉，将猪肉切成小块状准备好下锅，当锅里的油烧开后，噼里啪啦一阵子，恩，厨房已经香气逼人啦，不久后，芹菜炒肉出锅，感觉炒的还不错，就拍了张照片，顺便给媳妇秀下，哈哈！下面是今天的作品，你们随便感受下，味道还是很不错的。平淡的生活Tip:最近程序员圈子中有一种文体很火——一张食物图片配一句“平淡的生活”,以此试图低调的彰显自己高生活水准(我猜)，最近在一些微信群很火的样子。赶快get起来吧！接着煮了点面条，就当主食吃了，吃饭时总是爱思考，饭快要吃完的时候，突然对之前的博客主题有了新的想法，然后等不及吃完就来到电脑旁，开始倒腾博客主题，好吧，这已经是下午的事了…下午找博客主题我向来比较喜欢简洁、高大上、绚丽、有意思、好看的东西，没办法，一直这样，也许是由于这个属性才导致我一直入行程序员到现在（恩，这点待考究，不严谨）。之前自己就已经有一个自己的个人博客了，当时几乎是仿照Google大神ChrisBanes的个人博客做的，如下图。曾经那个我最爱的主题其实从开始到之前的一段时间，我都很喜欢这个主题，但是无奈，你不能拒绝一个可以选择更好的机会，再说看久了总觉得太单一了，而且原来的主题在一些配置方面确实很麻烦，我之前曾花了大力气在上面，改CSS添加新元素…那是还在6、7月份的时候，还是花了很多精力的，其实放弃这些劳动成果还是有点不忍心的。然后浏览Jekyll主题库中的主题，发现有一个主题不错，看上去像是我的菜，而且看demo就很不错的样子，配置文档写的也很详细，恩，就是你了。安装主题犹豫再三，我还是决定放弃之前的那套主题，尽管为她已经付出很多了，但我觉得，有更好的就值得尝试。即使失败了，不还有备份吗，嘿嘿~~后路已经有了，就更加坚定了！下载主题文件、解压缩、覆盖原主题….一切看起来还不错的样子…接着根据新主题文档的安装教程，开始正式的安装。#cdintoprojectdirectorycdcentrarium#installBundlerifyoudon'thaveitalreadygeminstallbundler#installjekyll,jekyll-archives,andjekyll-sitemapbundleinstall结果在就在安装bundler的时候哗~~~一大堆错误，跪了，谁然你喜新厌旧，这课上的。不过不着急，做开发久了谁还不会遇到点问题呢，常在河边走，哪能不湿鞋。相比那种从产品设计之初就可能存在的业务逻辑问题（最近遇到太多了），这种安装阶段的异常问题，简直都不是事，所以这种问题，不用慌，很快就发现控制台有一行特别醒目的提示cannotfindhttp://ruby.taobao.org/....404.........恩~以前第一次安装博客的本地开发环境的时候，我记得特别清楚，因为rubygems.org上的好多资源在国内都无法正常访问，所以淘宝的同学特意在国内搭了一个中间的镜像下载源，方便国内的同学下载具体介绍可在这里查看RubyGems镜像恩，说道这里，一定要为淘宝的同学们点个赞。你们棒棒的~所以当时把rubygems的下载源设置为了淘宝的，当时是这么设置的$gemsources--addhttp://ruby.taobao.org/--removehttps://rubygems.org/但是现在报错找不到http://ruby.taobao.org/这个地址，后来搜了一下，答案揭晓：淘宝的同学吧该镜像地址的协议改了，说的明白点就是原来那个地址不能下载了，需要修改。好吧既然知道问题了，那解决方案也是很简单的，删除原有的无效源新增有效源如下$gemsources--addhttps://ruby.taobao.org/--removehttp://ruby.taobao.org/接着一些ok,成功安装bundler,接着最重要的一步到来了，启动jekyll,一个命令敲下去，$jekyllserver又是一堆错，不过根据错误日志找问题还是很快的，无非就是一些文件格式或者其他的问题。最终我的jekyll服务还是正常的启动了，然后去浏览器看效果，$http://localhost:4000/但是网页上只有一个大大的NotFound，那个很高大上的主页迟迟不肯见我。我能看到就是下面的这个页面受不了了，我看了看配置信息好像也没有问题啊，后来不想折腾，然后就找到主题制作者的github项目主页，然后提了一个issue,并附上截图。然后已经4点多了，透过阳台看到外面天气还不错，我想，为什么要跟自己过意不去呢，好端端的周末搞毛啊~小区附近有个公园，我很喜欢，公园很大，最重要的是有一个篮球场，博客可以辜负我，但我不能辜负还算不错的天气啊，这么好的天，打球多好。然后换上鞋子，出发~去公园打球北京的秋天真热闹。当我骑车子到公园时，公园人好多，很多家长带着小孩拍照、嬉戏，好生热闹。不过秋天的公园真的很漂亮，记得去年这个时候，老爹老妈应该已经到北京了。当时只能周末陪他们在北京玩，第一个周末我就带他们来了公园，放上一张去年拍的老照片。(想了想，还是放张背影吧，可能这样更有意义。)拍自2014年11月9日很快就到了球场，诺大的公园只有两个篮板，加上周六休息的人多，所以我去得时候球场已经爆满，只好站在旁边傻等。不过还不错，很快一认识的大哥也来打球，然后缺一人，因为之前我跟他打过很多次，我的水平他是知道的（嘻嘻~），他走过来让我跟他一起打，我说好啊，然后很快就开始上场打球。也许是被今天的博客给影响了，今天在球场上，始终没有发挥出我以往的水平（打脸了~），除了有一个不错的勾手打板是亮点，其余纯粹是打酱油。5点多的时候，想想还是回去吧，今天的舞台不属于我啊~我还会回来的~晚上回来后，发现热水器正巧被隔壁哥们开着，嘿，真好，然后冲了个热水澡。恩~感觉不错，而且还有梨解渴，其实还是蛮好的。然后继续看我的博客，问题还是存在，结合网页中的报错，左思右想，这问题肯定出在路径上，因为以前学JavaWeb的时候也经常出现这样的问题。终于，当我把配置文件中的一个baseurl属性更改为/后，对，就是这个东西，/只要把baseurl改为它，博客就一切正常了,其实是个小问题。#thesubpathofyoursite,e.g./blog/baseurl:/#thebasehostname&amp;protocolforyoursiteurl:"http://maoruibin.github.io"真是千淘万漉虽辛苦,吹尽狂沙始到金在浏览器页面点击刷新，久违的主页终于出现了，十分happy，吃个香蕉庆祝下。哈哈等了好久终于等到今天在博客主题成功运行起来后，我开始马不停蹄的设置博客的一些属性，比如主题颜色等，到这时，我觉得我所有为这个新主题付出的都是值得的。因为相比之前那个主题，这个主题提供了诸多设置方面的便利。它有一个主配置文件，所有博客相关的全局配置都可以在一个地方进行配置。而且可配置的属性还不少，而且都有说明，如下所示......#Example:##social:#-name:Twitter#Nameoftheservice#icon:twitter#FontAwesomeicontouse(minusfa-prefix)#username:"@TheBenCentra"#(User)Nametodisplayinthefooterlink#url:https://twitter.com/TheBenCentra#URLofyourprofile(leaveblanktonotdisplayinfooter)#desc:FollowmeonTwitter#Descriptiontodisplayaslinktitle,etc#share:false#Includeinthe"Share"sectionofpostssocial:-name:Weiboicon:weibousername:大侠咕咚url:http://weibo.com/u/1874136301desc:FollowmeonWeiboshare:true......对于主题的颜色的修改也异常简单，只需要在一个地方修改，所有地方都会改变，后来在MaterialDesigner的Color中挑选了一个比较暗淡的颜色作为主题色，也就是现在看到的这个颜色。接着继续对以前的技术文章也做了一些调整。最终经过一晚上的线下环境测试，没什么大问题后，把新主题的博客推到到github上，然后完全告别以前的主题，开启博客新纪元。对了，在十二点之前，继续延续我的Keep(一个帮助你每天完成指定运动动作的健身App)记录，已经连续第8天啦！附上今天Keep中的鸡汤文（每天Keep在指导你做动作时，手机屏幕都会有一句鸡汤语）来结束我的1024。</li>
  <li>作为一个Java程序员，我们写过很多Java类，那他们具体是怎么运行起来的呢？一开始，我也没有去关心过这个问题，或者说是自己没有在这方面思考过，但是后来觉得，既然每天都在做这些事，为什么不深入了解下具体的原理逻辑呢。知其然还应该知其所以然，作为一个有追求程序员，我们应该对自己有更高的要求。博文是自己对Java类加载的一些认识，如有错误欠缺，欢迎指正补充。这里，我们在开始主题之前，先梳理一下上面提出的这个问题。首先举个简单的例子，来引出我们的问题比如，现在需要我们编写一个Java类Person，他有一个包名比如说com.gudong.demo,然后这个类会有一个修饰符public，具体代码就应该是下面的样子，packagecom.gudong.demopublicclassPerson{}接着类里面我们会定义一些成员变量，比方说，定义一个int型的age来表示Person的年龄privateintage;也有可能定义一个类属性，比如说人的最大年龄publicstaticfinalintMAX_AGR=122;//fromwiki接着我们还会定义一些方法，比如main方法publicstaticvoidmain(String[]args){System.out.println("helloworld!");}还有可能定义一些内部类staticclassArea{privateStringname;}在一个类里，我们还可以定义除上面所说的很多种数据。当我们写完一个类，我们可能做的就是运行了，点击运行按钮，我们的程序就可以按照我们预期的方式执行了，这里一定要明白一点，因为我们大多数时候用的是IDE，所以这里省去了自己编译的步骤，如果你使用命令行进行编写代码，那么你一定知道，在执行Java代码前，一定要先执行javac命令，也就是编译命令。javac全称应该叫做javacompile如果没猜错的话。所以我们写完代码，首先要进行应该是编译，那么编译会做什么事呢？编译会把我们用java写的代码转化成我们经常听说的字节码，字节码是什么鬼？说到这里，是时候搬出Java的一大特性了-跨平台。想必很多人都知道这个特性，你会发现工作中，你同事用的是Mac在写Java代码，而你用着windows在开发，最终你们写完的代码，不论在MAC上打包还是windows上打包，最终打包出来的apk，运行起来都是一个样式，根本没有任何差异，其原因就在于不论是MAC上的源码还是Window上的源码，在运行之前都要经过Java虚拟机进行编译，不同的开发平台，Oracle公司都有一个对应的Java虚拟机实现，但是经过虚拟机编译后的源码都会变成遵循同样规范的一个文件，这就是我上面说的字节码。字节码是一个和平台无关的文件，不论任何平台，任何Java虚拟机，编译Java源码后生成的字节码文件，都应该是一致的，字节码文件具体就是经常在build目录下看到的以.class结尾的文件所以说到这里，如果你够牛B,你也可以按照Java虚拟机规范（这个规范是公布于众的，市面也有相关的中文书籍），实现自己的Java虚拟机，然后自己公司的代码，用自己的编译器进行编译，这个听上去，确实刁刁的，不过要能做到，呵呵，我就不遐想了，目前的层次还差好多，而且也没什么意义，至少目前是，国内据说腾讯自己有搞，不知道具体如何。到这里，关于字节码，应该有点概念了，我们写完的代码，经过编译，会变成已.class结尾的java字节码文件。具体的字节码，是一组以8位字节为基础的二进制流，它包含以下几个部分，具体字节码的数据存储格式都是按照Java虚拟机的规范来的，任何Java虚拟机必须严格安装规范来，以确保不同的，Java虚拟机编译出的字节码是格式、内容相同的文件。关于字节码文件的结构，如下所述，下面这部分来自摘抄魔数和class文件版本：类文件开头的四个字节被定义为CAFEBABE，只有开头为CAFEBABE的文件才可以被虚拟机接受，接下来四个字节为class文件的版本号，高版本JDK可以兼容以前版本的class文件，但不能运行以后版本的class文件。常量池：可以理解为class文件中的资源仓库，它包含两大类常量：字面量和符号引用，字面量包含文本字符串，声明为final的常量值等，符号引用包含类和接口的全限定名，字段的名称和描述符，方法的名称和描述符。访问标志：常量池结束后，紧接着两个字节表示访问标志，用于识别一些类或接口层次的访问信息，例如是否是public，是否是static等。类索引，父类索引，和接口索引集合：类索引用来确定这个类的全限定名，父类为父类的全限定名，接口索引集合为接口的全限定名。字段表集合：用于描述接口或者类中声明的变量，但不包含方法中的变量。方法表集合：用于表述接口或者类中的方法。属性表集合：class文件，字段表，方法表中的属性都源自这里。经过编译，一个.java文件已经变成了一个.class字节码文件，下面要真真使用这个.class时，虚拟机对这个文件又会做什么，这就是接下来的类加载。类加载首先从一个简单的实例开始。比如说，现在我们已经写好了自己Person类，并且编译成功，现在是Person类以Person.class的形式存在于计算机的一个地方（必然是自己的项目编译目录下）。现在自己写一个Test类，通过使用Person来实例化一个对象，从而分析Person类的加载过程，如下publicclassTest{//主方法publicstaticvoidmain(String[]args){Personp1=newPerson();p1.name=“大虾”;System.out.println(“p1nameis“+p1.name);Personp2=newPerson();p2.name=“咕咚”;System.out.println(“p2nameis“+p2.name);System.out.println(“p1maxage“+Person.MAX_AGE);}}可以看到，上面我们定义了两个Person对象p1和p2。对于Test类，他经过编译，然后运行，在第一次运行时，虚拟机也会先加载Test.class文件到内存，然后执行方法，暂且不细究Test的加载。当执行Main方法，执行到第一条代码语句时，他看到这里需要new一个Person，此时他会查看内存中是不是已经存在Person.class类对象，如果没有，就会根据Person的包路径，也就是具体的本地存储路径，然后找到Person.class的存储位置，然后虚拟机就会把这个字节码的二进制流加载到内存，具体类加载分为以下几个过程加载加载是类加载的第一个阶段，虚拟机要完成以下三个过程：1）通过类的全限定名获取定义此类的二进制字节流。2）将字节流的存储结构转化为方法区的运行时结构。3）在内存中生成一个代表该类的Class对象，作为方法区各种数据的访问入口。验证目的是确保class文件字节流信息符合虚拟机的要求。准备为static修饰的变量赋初值，例如int型默认为0，boolean默认为false。解析虚拟机将常量池内的符号引用替换成直接引用。初始化初始化是类加载的最后一个阶段，将执行类构造器()方法，注意这里的方法不是构造方法。该方法将会显式调用父类构造器，接下来按照java语句顺序为类变量和静态语句块赋值。在执行完成类加载的第一步初时，会在内存中(具体是在堆内存)中生存一个代表该类的Class对象，针对Person类，此时虚拟机会在堆内存空间，开辟一块空间用于存储Person.class这个对象，如下图所示接着如果这个类有类属性，如我们定义在Person中的MAX_AGE，那么他在类准备阶段，虚拟机也会在在类对象所在的内存块，给她分配一段空间，最终在类初始化完成时，类对象的状态如下。此时类加载完毕，现在需要去实例化Personp1,此时虚拟机会利用已经加载到内存中的Person.class,来生成一个p1的实例，此时p1这边变量处于栈空间，具体的对象位于堆空间，继续向下执行，需要实例化p2了，因为虚拟机检查到Person.class已存在于内从，此时直接执行实例化过程，最终的内存分配情况如下图所示到这里就可以看到为什么有类加载这个过程了。通过上面分析会发现，如果为一个类设置了类属性，也就是用static去修饰的成员变量，他会在类加载完成后，就一直存在于内存，当然如果发生GC，他有可能被回收，一般情况下，可以直接通过类名去访问这块空间，因为他是在类对象的空间内，相比类属性，对成员属性来说，如Person的age、name属性，都是在具体实例化类时才会去单独分配内从。关于类加载，这是只说了一部分，具体成员变量的内存分配，以及临时变量的内存分配还有方法的执行过程，还有很多内存操作相关的知识点，自己可以去搜索更多的博客去学习，这里只是把自己的理解说了出来，如有错误，欢迎指正。最后，了解类加载还有内存分配有什么意义？其实我们平时的开发过程中，好像用不到这些知识，但是这些都是最根本的基础，不了解好像对日常的开发也没什么大碍，但是如果你了解了这些细节的东西，那么你在编写每一个类，定义每一个变量时，你就可以更加清楚的知道，它在内存中的状态。有利于对代码有更深刻的认识和了解。这些如果你细究，都是有很多的学问，这里只是说出了一点点的东西，做个记录！参考文档Java虚拟机类加载机制和字节码执行引擎Java虚拟机类加载和执行机制</li>
  <li>代码永远写不完，但是写的时间久了，就应该形成自己的代码规范或者自己团队的规范，尽管一些规范已经形成于脑海，但是还是有必要记录下来。从现在开始，一点点积累开发规范。这里积累开发过程中所有的规范细节，尽可能详细。类文件项目目录结构接口文件命名规范id命名采用右侧格式{view缩写}{module_name}{view的逻辑名称}空间缩写LinearLayoutllRelativeLayoutrlFrameLayoutflTextViewtvEditTextetButtonbtnImageViewivProgressBarpbSpinnerspnListViewlvRecycleViewrcvRadioButtonrbCheckBoxcb接口命名规范命名规则与类一样采用大驼峰命名法，多以able或ible结尾。例如：interfaceRunable|interfaceAccessible自己定义的接口最好以I开头接口中定义的方法以on开头，如onInit();成员变量命名规范采用小驼峰命名法，以m开头。临时变量命名使用标准的Java命名方法，不推荐使用Google的m命名法。例如：privateStringuserName;而不推荐使用privateStringmUserName;常量命名常量使用全大写字母加下划线的方式命名。例如：publicstaticfinalStringTAG=“tag”;控件实例命名类中控件名称必须与xml布局id保持一致(可以去掉{module_name})。例如:在布局文件中Button的id为:android:id=”@+id/btn_pay”privateButtonmBtnPay;方法命名规范动词或动名词，采用小驼峰命名法。例如：run();onCreate();syncProducts();布局文件(Layout)命名规范全部小写，采用下划线命名法。其中{module_name}为业务模块或是功能模块等模块化的名称或简称。对于小项目，可以不用使用module_name作为前缀。activitylayout：{module_name}activity{名称}例如：user_activity_main.xmluser_activity_shopping.xmlfragmentlayout:{module_name}fragment{名称}例如：user_fragment_main.xmluser_fragment_shopping.xmlDialoglayout:{module_name}dialog{名称}例如：user_dialog_loading.xml列表项布局命名：{module_name}list_item{名称}例如：user_listitem_customer.xml包含项布局命名：include_{名称}例如：include_head.xmladapter的子布局：{module_name}item{名称}例如：user_item_order.xmlwidgetlayout：{module_name}widget{名称}例如：user_widget_shopping_detail.xml</li>
  <li>使用AndroidStudio进行开发，其中很重要的一个文件就是build.gradle，它是整个项目编译打包的控制中心，这里收集一些日常会用到的语法或者使用技巧，以备后用。排除依赖包中的support依赖implementation('com.github.anzewei:parallaxbacklayout:1.1.9'){excludegroup:"com.android.support"}通过exclude排除掉依赖包中的support依赖，这样可以解决跟主工程的冲突问题，其他的重复也可通过类似的方式解决。指定签名信息签名信息比较隐私，不应该直接出现在项目中，可以把密钥文件、密码、账号，存储在本地的文件夹，然后把这个信息定义在lcoal.properties文件中，并且让该文件不受git版本控制，通过.gitignore文件过滤。如下是具体的签名信息指定方式在主app的build.gradle文件中这样配置defaultConfig{signingConfigs{//指定名叫release的一个签名对象，下面会动态根据配置文件设置属性releaseConfig}buildTypes{release{if(signingConfigs.releaseConfig!=null){signingConfigsigningConfigs.releaseConfig}}}在gradle文件android同级配置下设置releaseConfig信息Propertiesprops=newProperties()defpropFile=file('../local.properties')if(propFile.exists()){props.load(newFileInputStream(propFile))if(props!=null&amp;&amp;props.containsKey('SIGN_FILE')&amp;&amp;props.containsKey('SIGN_KEYSTORE_PASS')&amp;&amp;props.containsKey('SIGN_KEYSTORE_ALIAS')&amp;&amp;props.containsKey('SIGN_KEYSTORE_ALIAS_PASS')){android.signingConfigs.releaseConfig.storeFile=file(props['SIGN_FILE'])android.signingConfigs.releaseConfig.storePassword=props['SIGN_KEYSTORE_PASS']android.signingConfigs.releaseConfig.keyAlias=props['SIGN_KEYSTORE_ALIAS']android.signingConfigs.releaseConfig.keyPassword=props['SIGN_KEYSTORE_ALIAS_PASS']}else{android.buildTypes.release.signingConfig=null}}else{android.buildTypes.release.signingConfig=null}local.properties文件内容SIGN_KEYSTORE_PASS=******SIGN_FILE=/Users/ruibin1/Downloads/work/key/****.jksSIGN_KEYSTORE_ALIAS_PASS=******SIGN_KEYSTORE_ALIAS=******定义清单文件占位变量以下为一个清单文件占位符号&lt;intent-filter...&gt;&lt;dataandroid:scheme="http"android:host="${hostName}".../&gt;&lt;/intent-filter&gt;只需要在gradle文件中这样定义，即可使用：android{defaultConfig{manifestPlaceholders=[hostName:"www.example.com"]}}默认情况下，编译工具还会在${applicationId}占位符中提供应用的应用ID。该值始终与当前编译的最终应用ID（包括编译变体的应用ID更改）一致。更多查看将编译变量注入清单|AndroidDevelopers定义BuildConfig常量//定义int常量buildConfigField("int","LimitCount","12")//定义bool常量buildConfigField'boolean','isPro','true'定义Res资源//string资源resValue"string","app_name","云图debug"定义包名、版本号后缀//包名后缀applicationIdSuffix".debug"//版本号后缀versionNameSuffix"-full"</li>
  <li>如果自己做个人App项目，很可能在一些情况下用到Dialog,Android自己也提供了系统Dialog,但是在MaterialDesigner出现之前，样子确实很丑，这篇博客讲解如何使用Support包中的API来实现MD风格的Dialog。SupportV7包在22.1.0之前的任何一个版本，AlertDialog一直都是Android4.0风格，直到Support-V7:22.1.0，在这之前，如果我们的项目中要使用Material样式的Dialog，对不起，Android5.0以下的设备根本不支持，但是还好，开源界的大神从来都不缺乏无私的奉献精神，在support-v7包更新到V22.1.0之前，Github上已经出现了几个非常不错的MaterialDialog开源库，如下https://github.com/afollestad/material-dialogshttps://github.com/drakeet/MaterialDialog使用上面的开源库，就可以很轻松的在Android5.0以下的设备上实现MaterialDialog的效果。但是，如开始所说，support-v7更新到22.1.0之后，我们就再也不需要使用上面的开源库来获得MaterialDiaolg了。直接使用Support中的AlertDialog就可以实现MD风格的Dialog了。####准备工作1、将项目targetSdkVersion设为22或者以上2、加入对应的support依赖支持targetSdkVersion22compile'com.android.support:appcompat-v7:22.1.0'####使用直接上代码newAlertDialog.Builder(getActivity()).setTitle(R.string.title_export).setMessage(contentInfo).setPositiveButton(R.string.dialog_confirm_yes,newDialogInterface.OnClickListener(){@OverridepublicvoidonClick(DialogInterfacedialogInterface,inti){copyFile(srcFile,exportFile);}}).setNegativeButton(R.string.dialog_now_watch,newDialogInterface.OnClickListener(){@OverridepublicvoidonClick(DialogInterfacedialogInterface,inti){browseFile(exportFile.getParentFile());}}).show();注意：在导包时一定要选择android.support.v7.app.AlertDialog。否则Dialog将不会是Material样式。最终使用support包得AlertDialog显示的Dialog效果如下图所示：小发现：support-v7:22.1.0版本的Dialog显示的拐角是直角，其实这不符合真正规范，并且Dialog的默认背景颜色也不是白色，但是如果使用support-v7:23.1.0，这个问题就没了。####主题适配其实通过上面的操作，我们已经可以得到一个非常好看的MaterialDialog了，但是仔细看，发现按钮的文字颜色并不是项目的主色调colorPrimary,所以这里需要对Dialog进行主题设置，这里先把最终的成功方案给出来，一睹为快.&lt;!--应用主题--&gt;&lt;stylename="AppTheme"parent="Theme.AppCompat.Light.NoActionBar"&gt;&lt;itemname="theme_color"&gt;@color/colorPrimary&lt;/item&gt;&lt;itemname="theme_color_dark"&gt;@color/colorPrimaryDark&lt;/item&gt;&lt;itemname="theme_accent_color"&gt;@color/colorAccent&lt;/item&gt;&lt;!--自定义的Dialog主题--&gt;&lt;itemname="alertDialogTheme"&gt;@style/AlertDialogCustom&lt;/item&gt;&lt;/style&gt;&lt;!--自定义Dialog显示风格--&gt;&lt;stylename="AlertDialogCustom"parent="Theme.AppCompat.Light.Dialog.Alert"&gt;&lt;itemname="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt;&lt;itemname="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt;&lt;!--NeutralButtonStyle--&gt;&lt;itemname="buttonBarNeutralButtonStyle"&gt;@style/buttonBarNeutral&lt;/item&gt;&lt;!--NegativeButtonStyle--&gt;&lt;itemname="buttonBarNegativeButtonStyle"&gt;@style/buttonBarNegative&lt;/item&gt;&lt;!--PositiveButtonStyle--&gt;&lt;itemname="colorAccent"&gt;@color/colorAccent&lt;/item&gt;&lt;/style&gt;&lt;stylename="buttonBarNegative"parent="@style/Widget.AppCompat.Button.ButtonBar.AlertDialog"&gt;&lt;itemname="android:textColor"&gt;@color/md_grey_700&lt;/item&gt;&lt;/style&gt;&lt;stylename="buttonBarNeutral"parent="@style/Widget.AppCompat.Button.ButtonBar.AlertDialog"&gt;&lt;itemname="android:textColor"&gt;@color/md_grey_700&lt;/item&gt;&lt;/style&gt;上面通过在自定义Dialog主题的方式，最终得到了一个比较Material的Dialog。其中要改变按钮文本的样式，需要设置不同Button的上style,如最右边的positiveButton的样式就是通过buttonBarNeutral来设置，为什么是这个属性呢，其实扒一扒源码就可以找到。其实MaterialDialog的通过一个布局文件控制布局，下面是源码（appcompat-v7-22.1.0/res/layout/abc_alert_dialog_material.xml）中的布局代码，如下所示&lt;LinearLayoutandroid:id="@+id/buttonPanel"style="?attr/buttonBarStyle"android:layout_width="match_parent"android:layout_height="wrap_content"android:layoutDirection="locale"android:orientation="horizontal"android:paddingLeft="12dp"android:paddingRight="12dp"android:paddingTop="8dp"android:paddingBottom="8dp"android:gravity="bottom"&gt;&lt;Buttonandroid:id="@android:id/button3"style="?attr/buttonBarNeutralButtonStyle"android:layout_width="wrap_content"android:layout_height="wrap_content"/&gt;&lt;android.support.v4.widget.Spaceandroid:layout_width="0dp"android:layout_height="0dp"android:layout_weight="1"android:visibility="invisible"/&gt;&lt;Buttonandroid:id="@android:id/button2"style="?attr/buttonBarNegativeButtonStyle"android:layout_width="wrap_content"android:layout_height="wrap_content"/&gt;&lt;Buttonandroid:id="@android:id/button1"style="?attr/buttonBarPositiveButtonStyle"android:layout_width="wrap_content"android:layout_height="wrap_content"/&gt;&lt;/LinearLayout&gt;可以发现不同的Button具有不同的stylename，这里如果想要改变那个按钮的颜色样式，只要修改对应的style即可。不过注意的是，不论是修改Dialog的样式还是按钮的样式，一定要主要对应的parent不能出错。否则你可能达不到自己的目的，从而修改主题失败。不过他们的parent通过源码都可以找到，这里细心点就好。####总结使用MaterialDialog很容易，但是要控制Dialog的显示样式(按钮文本颜色，Dialog背景颜色等等)，需要去自定义主题。</li>
  <li>Java有众多关键字，volatile作为一个和同步相关的关键字，很少在自己的项目中使用，今天在看Handler源码时无意看到，顺便便了解了下。记录以备后用。做了一个实验更新于：2020/03/28在主线程创建一个int变量，然后开启两个线程A、BA线程负责打印intB线程负责更改int预期：B更改完int，A应该显示正确的值updateis1585353251102------&gt;1585353251102------&gt;1585353251607updateis1585353251607------&gt;1585353251607实际两个存在不同步的情况，这里当然可以用线程同步的方式的去处理这个问题，但是这里分析原因，为什么现在会存在不同步？因为int值的存在工作内存跟主内存，两者存在时间差，B线程更新完int并没有及时同步，所以A就不能及时打印出正确的值。这时如果使用volatile来修饰int值，int值每次的改变都会从工作内存更新到主内存，这样的更改是内存中彻底的更改。要解决共享对象可见性这个问题，我们可以使用javavolatile关键字。Java’svolatilekeyword.volatile关键字可以保证变量会直接从主存读取，而对变量的更新也会直接写到主存。volatile原理是基于CPU内存屏障指令实现的全面理解Java内存模型_Java_HeavenWang的专栏-CSDN博客volatile关键字可以被看作是一种“程度较轻的synchronized”；与synchronized块相比，volatile变量所需的编码较少，并且运行时开销也较少，但是它所能实现的功能也仅是synchronized的一部分。一般的，Java中设置变量的操作，除了long和double类型的变量，其余都是原子操作，也就是说，对于基本的变量设置操作没必要使用同步。在JVM1.2之前，Java的内存模型，总是从主内存读取变量，就是说，变量只存在于内存的一个地方，但是随着JVM的成熟，读取内存的过程也做了相应的更改。在当前的内存模型下，线程可以把变量在本地内存（比如机器的寄存器），而不是直接在内存读取，这个变化的原因，我猜测可能是下面的原因：如果频繁的修改读取内存中的一个变量，可能效率比较低，在JVM1.2之后，做了优化，发现如果一个变量被频繁的读取修改，那么就把这个变量先放到本地寄存器，这个读取效率更高。每次直接去读寄存器中的数据。但是，现在就出现一个问题，一个线程在主内存修改了变量的值，另一个线程在寄存器修改了这个变量的值，此时就出现了变量值不同步的问题，最终数据不一致。这时，volatile关键字就出现了。只要把变量声明为volatile，这就指示JVM，这个变量是不稳定的，只要成员变量发生变化，强迫线程将变化同步到主内存，一般说来，多任务环境下各任务间共享的标志都应该加volatile修饰。Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。坑（来自摘抄）其实volatile这个关键字有两层语义。第一层语义相信大家都比较熟悉，就是可见性。可见性指的是在一个线程中对该变量的修改会马上由工作内存（WorkMemory）写回主内存（MainMemory），所以会马上反应在其它线程的读取操作中。顺便一提，工作内存和主内存可以近似理解为实际电脑中的高速缓存和主存，工作内存是线程独享的，主存是线程共享的。volatile的第二层语义是禁止指令重排序优化。大家知道我们写的代码（尤其是多线程代码），由于编译器优化，在实际执行的时候可能与我们编写的顺序不同。编译器只保证程序执行结果与源代码相同，却不保证实际指令的顺序与源代码相同。这在单线程看起来没什么问题，然而一旦引入多线程，这种乱序就可能导致严重问题。volatile关键字就可以从语义上解决这个问题。注意，前面反复提到“从语义上讲是没有问题的”，但是很不幸，禁止指令重排优化这条语义直到jdk1.5以后才能正确工作。此前的JDK中即使将变量声明为volatile也无法完全避免重排序所导致的问题。所以，在jdk1.5版本前，双重检查锁形式的单例模式是无法保证线程安全的。from你真的会写单例模式吗——Java实现总结：volatile关键字就是提示VM：对于这个成员变量不能保存它的私有拷贝，而应直接与共享成员变量交互使用volatile关键字，就表示着将屏蔽掉JVM对变量访问的优化，所以在效率上比较低，因此一定在必要时才使用此关键字。摘抄point1:Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存重新读取该成员的值，而且，当成员变量值发生变化时，强迫将变化的值重新写入共享内存，这样两个不同的线程在访问同一个共享变量的值时，始终看到的是同一个值。point2:java语言规范指出：为了获取最佳的运行速度，允许线程保留共享变量的副本，当这个线程进入或者离开同步代码块时，才与共享成员变量进行比对，如果有变化再更新共享成员变量。这样当多个线程同时访问一个共享变量时，可能会存在值不同步的现象。</li>
  <li>这个类是用于执行低级别、不安全操作的方法集合。尽管这个类和所有的方法都是公开的（public），但是这个类的使用仍然受限，你无法在自己的java程序中直接使用该类，因为只有授信的代码才能获得该类的实例。从上面的描述，可以了解到该类是用来执行较低级别的操作的，比如获取某个属性在内存中的位置，(在AtomicInteger中就用到了)不过一般人很少会有这样的需求。今天在看AsynTask源码时，发现AsynTask中，他利用自己的ThreadFactory生成Thread时，用了AtomicInteger来生成对应的线程ID，如下：privatestaticfinalThreadFactorysThreadFactory=newThreadFactory(){privatefinalAtomicIntegermCount=newAtomicInteger(1);publicThreadnewThread(Runnabler){returnnewThread(r,"AsyncTask#"+mCount.getAndIncrement());}};然后看AtomicInteger的方法getAndIncrement（）/***Atomicallyincrementsbyonethecurrentvalue.**@returnthepreviousvalue*/publicfinalintgetAndIncrement(){for(;;){intcurrent=get();intnext=current+1;if(compareAndSet(current,next))returncurrent;}}/***Atomicallysetsthevaluetothegivenupdatedvalue*ifthecurrentvalue{@code==}theexpectedvalue.**@paramexpecttheexpectedvalue*@paramupdatethenewvalue*@returntrueifsuccessful.Falsereturnindicatesthat*theactualvaluewasnotequaltotheexpectedvalue.*/publicfinalbooleancompareAndSet(intexpect,intupdate){returnunsafe.compareAndSwapInt(this,valueOffset,expect,update);}关于AtomicInteger类的介绍可以看这篇文章。这里我们看到最重要的一个类叫UnsafeUnsafe的源码//setuptouseUnsafe.compareAndSwapIntforupdatesprivatestaticfinalUnsafeunsafe=Unsafe.getUnsafe();上面这行代码是获取Unsafe实例的。一般情况下，我们是拿不到该类的实例的，当然jdk库里面是可以随意使用的。static{try{valueOffset=unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField("value"));}catch(Exceptionex){thrownewError(ex);}}上面这几行代码，是用来获取AtomicInteger实例中的value属性在内存中的位置。这里使用了Unsafe的objectFieldOffset方法。这个方法是一个本地方法，该方法用来获取一个给定的静态属性的位置。publicnativelongobjectFieldOffset(Fieldf);这里有个疑问，为什么需要获取属性在内存中的位置？通过查看AtomicInteger源码发现，在这样几个地方使用到了这个valueOffset值：publicfinalvoidlazySet(intnewValue){unsafe.putOrderedInt(this,valueOffset,newValue);}publicfinalvoidlazySet(intnewValue){unsafe.putOrderedInt(this,valueOffset,newValue);}publicfinalbooleanweakCompareAndSet(intexpect,intupdate){returnunsafe.compareAndSwapInt(this,valueOffset,expect,update);}查找资料后，发现lazySet方法大多用在并发的数据结构中，用于低级别的优化。compareAndSet这个方法多见于并发控制中，简称CAS(CompareAndSwap)，意思是如果valueOffset位置包含的值与expect值相同，则更新valueOffset位置的值为update，并返回true，否则不更新，返回false。这里可以举个例子来说明compareAndSet的作用，如支持并发的计数器，在进行计数的时候，首先读取当前的值，假设值为a，对当前值+1得到b，但是+1操作完以后，并不能直接修改原值为b，因为在进行+1操作的过程中，可能会有其它线程已经对原值进行了修改，所以在更新之前需要判断原值是不是等于a，如果不等于a，说明有其它线程修改了，需要重新读取原值进行操作，如果等于a，说明在+1的操作过程中，没有其它线程来修改值，我们就可以放心的更新原值了。Unsafe只有jdk库里的类才可以随意使用。对于我们一般是没法拿到实例的，但是要真要想拿到，也不是没有办法，比如用反射，至于他能做什么，看自己怎么用了Fieldf=Unsafe.class.getDeclaredField("theUnsafe");//Internalreferencef.setAccessible(true);Unsafeunsafe=(Unsafe)f.get(null);</li>
  <li>AtomicInteger，一个提供原子操作的Integer的类。在Java语言中，++i和i++操作并不是线程安全的，在使用的时候，不可避免的会用到synchronized关键字。而AtomicInteger则通过一种线程安全的加减操作接口。使用AtomicInteger是非常的安全的那么为什么不使用记数器自加呢，例如count++这样的，因为这种计数是线程不安全的，高并发访问时统计会有误，而AtomicInteger为什么能够达到多而不乱，处理高并发应付自如呢？这是由硬件提供原子操作指令实现的。在非激烈竞争的情况下，开销更小，速度更快。Java.util.concurrent中实现的原子操作类包括：AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference。</li>
  <li>在做App+这个项目时，使用了WebView来展示更新日志，但是在加载本地Html文件的时候，出现了乱码问题。这篇博客记录自己错误出现的原因、以及解决方法。由于本地Html文件日志文件中包含中文，在加载时就出现了乱码，加载方式如下StringformatLodString=buf.toString();webView.loadData(formatLodString,"text/html","UTF-8");解决方案：使用webView的方法loadDataWithBaseURL。StringformatLodString=buf.toString();webView.loadDataWithBaseURL(null,formatLodString,"text/html","UTF-8",null);有用的链接AndroidwebviewloadData中文乱码</li>
  <li>在众多Android应用中，尤其是阅读类App，为了给用户提供更好的使用体验，App设计者一般都会提供两套主题，最常见的就是LightTheme和DarkTheme,分别对应了日间模式和夜间模式。比如第三方微博客户端Smooth,知乎等等他们都有这样的实现。因为自己对这块一直也比较感兴趣，所以自己就先尝试着做了一次，目前只是简单的尝试了下，下面记录一下这个过程，如果能帮助到更多的人，再好不过啦！关于主题，我分两步走，第一步主体使用，第二部主题切换1、主题使用其实，Android已经为我们提供了一套成型的主题，我们要做的就是在他的基础上个性化自己的主题样式，首先在项目目录的values/styles.xml建立一个Light主题，如下&lt;stylename="Theme_AppTheme"parent="Theme.AppCompat.Light.NoActionBar"&gt;&lt;!--主题对应主色调--&gt;&lt;itemname="colorPrimary"&gt;#673AB7&lt;/item&gt;&lt;!--主题对应深色调在Android5.0上主要表现在StatusBar上--&gt;&lt;itemname="colorPrimaryDark"&gt;#512DA8&lt;/item&gt;&lt;!--主题中的强调色--&gt;&lt;!--比如你的App使用了FloatActionBar，那么他的颜色默认就是他了--&gt;&lt;itemname="colorAccent"&gt;#FF4081&lt;/item&gt;&lt;!--下面这三个属性比较有意思，也是后面切换主题的关键单独拿出来说--&gt;&lt;itemname="title_text"&gt;@android:color/black&lt;/item&gt;&lt;itemname="body_text"&gt;#303030&lt;/item&gt;&lt;/style&gt;很明显，上面的两个属性“title_text”和“body_text”是Android没有提供的。但其实这里才是后面切换主题的关键点。说道这里，先让我们先想想，如果让我们自己做主题切换，我们怎么才能做到点击一个主题切换按钮，就能让全局的样式都改变呢？比方说，我们的布局中有一个TextView如下&lt;TextViewandroid:layout_width="match_parent"android:layout_height="wrap_content"android:textColor="@android:color/black"/&gt;现在他的颜色是black，此时如果我们的用户选择了另一个主题，我们怎么才能让他的颜色变成white,最常见的方法就是通过代码的方式设置颜色（textView.setTextColor(**)），但是对于全局那么多的View，很明显，这样做事做不可能的，此刻联想一下App的国际化我们是怎么做到的，无非是在需要显示文本内容的地方，不使用具体的文字，而是用一个string的资源标识符去占位！如下values/layout.xml文件&lt;Buttonandroid:text="@string/hello_world"android:layout_width="wrap_content"android:layout_height="wrap_content"/&gt;values/strings.xml文件&lt;stringname="hello_world"&gt;Helloworld!&lt;/string&gt;对应的中文values-zh-rCN/strings.xml&lt;stringname="hello_world"&gt;你好世界！&lt;/string&gt;其实就是一个占位思想，试想一下，如果所有textView的color也使用此种方式，那么主题切换不就变得很简单了，事实上，Android就是可以采用这种方式！只是这里需要自定义一个颜色属性，如下所示values/attrs.xml&lt;attrname="title_text"format="color"/&gt;然后再使用到color的地方使用title_text进行占位，如下&lt;TextViewandroid:layout_width="match_parent"android:layout_height="wrap_content"android:textColor="?title_text"/&gt;此时只要在不同的主题中，指定不同的title_text颜色值，就可以做到view颜色的改变，如下&lt;!--亮色主题--&gt;&lt;stylename="Theme_AppTheme"parent="Theme.AppCompat.Light.NoActionBar"&gt;&lt;itemname="title_text"&gt;@android:color/black&lt;/item&gt;&lt;/style&gt;&lt;!--暗色主题--&gt;&lt;stylename="Theme_AppTheme_Dark"parent="Theme.AppCompat.NoActionBar"&gt;&lt;itemname="title_text"&gt;@android:color/white&lt;/item&gt;&lt;/style&gt;这里只是拿TextView的color来举例子，其实view的各种属性都可以通过这样方式来主题化，你可以更具自己的需求，举一反三。如ImageView的Icon在不同的主题下需要显示不同的图片，都是可以做到的。如果现在想试试效果，可以直接在MainFest文件中指定App的主题，看看是否起作用。先说到着，打会球去具体设计到用代码切换主题时，可以使用Activity的一个方法reload方法；也可以使用下面的方式publicvoidreload(){Intentintent=getIntent();overridePendingTransition(0,0);intent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);finish();overridePendingTransition(0,0);startActivity(intent);}</li>
  <li>在做AppPlus项目的过程中，因为每个Item上面都有一个PopupMenu，但是当时在xml文件中设置icon后，却发现icon不生效，下面是这个问题的解决方案。#Android问题自从MaterialDesigner出现后，像下图所示的设置流式布局随处可见。其中每个Item上都有一个OverFlow(更多)的icon，点击会弹出一个菜单，实现方式很简单，首先在meun文件中，新建一个menu文件，如下所示src/main/res/menu/item_pop_menu.xml&lt;?xmlversion="1.0"encoding="utf-8"?&gt;&lt;menuxmlns:android="http://schemas.android.com/apk/res/android"xmlns:app="http://schemas.android.com/apk/res-auto"&gt;&lt;itemandroid:title="@string/menu_pop_item_file"android:icon="@drawable/ic_launcher"android:id="@+id/pop_file"/&gt;&lt;itemandroid:title="@string/menu_pop_item_share"android:icon="@drawable/ic_launcher"android:id="@+id/pop_share"/&gt;&lt;/menu&gt;然后在对应List的Adapter中处理那个OverFlow(更多)按钮的点击事件，如下所示/***在ancho旁边显示菜单*@paramancho触发PopupMenu的View*/privatevoidshowPopMenu(Viewancho){PopupMenupopupMenu=newPopupMenu(mContext,ancho);popupMenu.getMenuInflater().inflate(R.menu.item_pop_menu,popupMenu.getMenu());//menuitem的点击事件监听popupMenu.setOnMenuItemClickListener(newPopupMenu.OnMenuItemClickListener(){@OverridepublicbooleanonMenuItemClick(MenuItemitem){//switch判断}});}//显示弹出式菜单popupMenu.show();程序运行后，点击OverFlow确实会弹出菜单，但是却发现，没有显示出设置好的icon,如下图其中不显示的原因在于，popupMenu本身是不能设置显示icon的，控制icon的显示是MenuPopupHelper这个类要做的事，但是又不能直接通过popupMenu得到MenuPopupHelper的实例。解决方案这种场景下，我们自然而然的想到了用反射，如下所示，最终问题完美解决/***在ancho旁边显示菜单*@paramancho触发PopupMenu的View*/privatevoidshowPopMenu(Viewancho){PopupMenupopupMenu=newPopupMenu(mContext,ancho);popupMenu.getMenuInflater().inflate(R.menu.item_pop_menu,popupMenu.getMenu());//menuitem的点击事件监听popupMenu.setOnMenuItemClickListener(newPopupMenu.OnMenuItemClickListener(){@OverridepublicbooleanonMenuItemClick(MenuItemitem){//switch判断}});}//通过反射获取MenuPopupHelper实例，然后设置setForceShowIcon为truetry{FieldmFieldPopup=popupMenu.getClass().getDeclaredField("mPopup");mFieldPopup.setAccessible(true);MenuPopupHelpermPopup=(MenuPopupHelper)mFieldPopup.get(popupMenu);mPopup.setForceShowIcon(true);}catch(Exceptione){}//显示弹出式菜单popupMenu.show();参考链接stackOverFlowpage</li>
  <li>在Mac下使用Sublime时，如果要编译java文件，直接使用command+B命令就可以达到编译的效果，此时会在java源文件的目录下生成对应的.class文件，但这显然不能够满足我们的需求。如何才能直接编译并运行java代码呢？我最终通过如下解决方案，达到了command+B在Sublime控制台显示运行结果的效果第一步打开Finder应用程序-&gt;SublimeText-&gt;右击显示包内容-&gt;/Contents/MacOS/Packages/Java.sublime-package第二步替换这个压缩文件夹下面JavaC.sublime-build的文件内容为{"cmd":["java","$file_base_name"],"file_regex":"^*\\[javac\\](.+):([0-9]+):()(.*)$","selector":"source.java"}ps:这个地方小费了点功夫，在mac上没有合适的软件可以编辑Java.sublime-package这个文件里面的内容，后来我是这么做的，把文件发送到windows电脑上，然后用360压缩解决。第三步重新打开Sublime，使用快捷键command+B进行编译然后直接运行，然后控制台打印出HelloWorld字符串，如下所示，妥妥的。</li>
  <li>在使用优化博客时，经常会去一些其他的博客学习别人的经验，或者一些技巧，这篇文章主要收集有用的和Jekyll相关的博文。jekyll官网文档部分翻译Jekyll语法简单笔记</li>
  <li>在开发过程中，经常需要把一个View的背景设置为某个颜色的半透明状态。通常我们可以通过设置颜色值的前两位而达到效果，一般情况下也能满足基本需求，比如白色色值为#ffffff,那么他的半透明颜色值可以写成#88ffffff，这样设置背景后也可以出现半透明效果。其实颜色值的前两位就是控制颜色的半透明状态的。但是有时设计师可能会跟你提这样的要求，他需要你设置一个0.56等等很参数化的半透明颜色，这时就很难用经验值去设置了，今天看到一个很不错的Util方法，可以动态根据半透明值，生成对应的颜色值。如下，这个方法可以给指定的颜色指定具体值的alpha值，只要传一个Color的字符串形式，如#f5f5f5,然后传递一个0到1的double值即可得到对应的半透明颜色，亲测有效。/***Addsalphatoahexcolor**@paramoriginalColorcolor,withoutalpha*@paramalphafrom0.0to1.0*@returntheoriginalcolorwithalpha*/publicstaticStringaddAlpha(StringoriginalColor,doublealpha){longalphaFixed=Math.round(alpha*255);StringalphaHex=Long.toHexString(alphaFixed);if(alphaHex.length()==1){alphaHex="0"+alphaHex;}originalColor=originalColor.replace("#","#"+alphaHex);returnoriginalColor;}代码原地址半透明对应的value·Issue#34·maoruibin/maoruibin.github.com</li>
  <li>在Android设备上实现锁屏功能。最终结果点击主界面的锁屏按钮，实现立即锁屏准备阶段新建一个空的Android项目，并在主界面上拖放一个按钮。并在Button的布局文件中声明onClick事件。如下&lt;Buttonandroid:text="锁屏"android:layout_width="match_parent"android:layout_height="wrap_content"android:onClick="lockScreen"/&gt;在MainActivity.java文件中实现lockScreen方法。实现步骤1、创建一个空的广播接受者AdminManageReceiver.javaimportandroid.app.admin.DeviceAdminReceiver;publicclassAdminManageReceiverextendsDeviceAdminReceiver{}2、配置Manifest文件&lt;receiverandroid:name=".AdminManageReceiver"android:label="@string/app_name"android:permission="android.permission.BIND_DEVICE_ADMIN"&gt;&lt;meta-dataandroid:name="android.app.device_admin"android:resource="@xml/device_admin"/&gt;&lt;intent-filter&gt;&lt;actionandroid:name="android.app.action.DEVICE_ADMIN_ENABLED"/&gt;&lt;/intent-filter&gt;&lt;/receiver&gt;3、新建文件device_admin.xmlAdminManageReceiver需要一个资源文件的支持，我们在res目录下面创建名为xml的文件夹，接着创建device_admin.xml文件，内容如下&lt;device-adminxmlns:android="http://schemas.android.com/apk/res/android"&gt;&lt;uses-policies&gt;&lt;force-lock/&gt;&lt;/uses-policies&gt;&lt;/device-admin&gt;4、主逻辑的实现直接上MainActivity.java代码如下publicclassMainActivityextendsActionBarActivity{ComponentNamemAdminName;DevicePolicyManagermDPM;@OverrideprotectedvoidonCreate(BundlesavedInstanceState){super.onCreate(savedInstanceState);setContentView(R.layout.activity_main);mAdminName=newComponentName(this,AdminManageReceiver.class);mDPM=(DevicePolicyManager)getSystemService(Context.DEVICE_POLICY_SERVICE);//如果设备管理器尚未激活，这里会启动一个激活设备管理器的Intent,具体的表现就是第一次打开程序时，手机会弹出激活设备管理器的提示，激活即可。if(!mDPM.isAdminActive(mAdminName)){showAdminManagement(mAdminName);}}//执行锁屏publicvoidlockScreen(Viewview){if(mDPM.isAdminActive(mAdminName)){mDPM.lockNow();}}//激活设备管理器privatevoidshowAdminManagement(ComponentNamemAdminName){Intentintent=newIntent(DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN);intent.putExtra(DevicePolicyManager.EXTRA_DEVICE_ADMIN,mAdminName);intent.putExtra(DevicePolicyManager.EXTRA_ADD_EXPLANATION,"activitydevice");startActivityForResult(intent,1);}}Note:如果正常运行这个程序，并且按照要求激活了设备，那么在你要准备卸载程序时，需要去设备管理器先移除这个程序，才可以正常执行卸载。</li>
  <li>一个圆形饼状View的实现过程。CakeView是一个通过自定义做的饼状图，如下图所示，会根据比例显示不同的占比。这个view会根据传入的两个数字参数生成不同的占比大小。实现原理###画出一个背景为红色的大圆圈，然后再画一个圆心跟红色圆圈一致的扇形。最后在中央画一个白色小圆，然后大概的样式就出来了，最后在中央写上文字内容即可。如下演示上面已经很清楚的看到了具体的实现过程。核心操作均在onDraw方法，如下@OverrideprotectedvoidonDraw(Canvascanvas){super.onDraw(canvas);RectFrPrimary=newRectF(0,0,mWidth,mWidth);RectFrSecond=newRectF(mBorderWidth,mBorderWidth,mWidth-mBorderWidth,mWidth-mBorderWidth);//绘制主色圆圈canvas.drawOval(rPrimary,mPrimaryPaint);//绘制副色圆圈这里绘制一个指定角度的扇形canvas.drawArc(rPrimary,mStartAngle,mSweepAngle,true,mSecondaryPaint);//绘制中心圆圈白色中心canvas.drawOval(rSecond,mCenterPaint);//绘制标题文本if(!TextUtils.isEmpty(mTitle)){PathtitlePath=newPath();titlePath.moveTo(mHalf*(1f/4f),mHalf*(7f/8f));titlePath.lineTo(mHalf*(7f/4f),mHalf*(7f/8f));mTitlePaint.setTextSize(sp2px(getContext(),14f));mTitlePaint.setTextAlign(Paint.Align.CENTER);canvas.drawTextOnPath(mTitle,titlePath,0,0,mTitlePaint);}//绘制内容文本if(!TextUtils.isEmpty(mContent)){PathcontentPath=newPath();contentPath.moveTo(mHalf*(1f/4f),mHalf*(7f/6f));contentPath.lineTo(mHalf*(7f/4f),mHalf*(7f/6f));mContentPaint.setTextSize(sp2px(getContext(),24f));mContentPaint.setTypeface(Typeface.defaultFromStyle(Typeface.BOLD));mContentPaint.setTextAlign(Paint.Align.CENTER);canvas.drawTextOnPath(mContent,contentPath,0,0,mContentPaint);}}关于画扇形，这里推荐一篇国外的博客，写的很好，对carvas的drawArc方法解释的很详细。UnderstandingSweepangleindrawArcmethodofandroid此外。整个实现过程中，还发现canvas有一个特别好的方法drawTextOnPath()利用这个方法可以方便的文字的显示位置。update:上述的画饼状图的方式会存在过度绘制的问题，尽管问题看上去不大，其实如果只是画一个圆圈，没必要这么麻烦，可以直接画一个指定宽度的圆线就对了，自己的实现其实有点麻烦了。更新于2016/01/1600:30</li>
  <li>对于自己做开发工作到现在，有时想想，也许是命运的安排。高中填报志愿，我选择的是当时比较热门的机械设计制造，但是因为成绩没够着，并且服从调配，所以被调到了计算机科学与技术专业，从此我便和软件、程序挂起了钩。大一开始学习C语言，却发现对这个东西一点都没感觉，持续到大二，还是没感觉，后来就觉得不对啊，即使是被选择到了计算机专业，但也不能荒废时间啊，后来自己开始上网找教程，自学一些比较有意思的项目，我记得很清楚，当时看了一个视频教程《C语言也能干大事》，才发现原来编程是可以让我产生兴趣的。从此便开始了自己的程序员之旅。后来开始不停的学习新东西，乐此不疲，从一开始的MFC到后来的Java，再开始学习JavaScript、Css、JavaWeb、三大框架，数据库。后来发现自学其实是个特别有意思的事情，你可以学习任何你想学习的东西。后来甚至翘课去听一些网络教程，说到这里，我觉得对于在校大学生，如果你现在还在大学，同时对编程有兴趣，建议除了专业相关的重要课程，翘课学习自己喜欢的东西，未尝不可。后来大四第一学期，一所北京培训机构去学校宣讲，招收学生去北京培训移动开发，而且培训费有优惠，所以就来到了北京，开始参加Android开发培训…培训时间是四个月，第三个月试着去面试，顺利的拿到Offer,然后开始自己的开发生涯。第一份工作是在一家创业公司做Android开发，一开始公司只有五个人，CEO，前端、市场、移动客户端。老板是华为出生，懂技术懂销售。到公司后服务端老板负责，我负责客户端，至于产品设计，无，当时在我的建议下，用腾讯的一个原型工具，花了一周时间，自己做了一个简单的产品原型，然后就开始开发客户端。用了三个月时间，在13年5月份产品上线，产品功能很简单，帮助用户查询周边的农场，数据全部来自老板之前做的web网站。后来，微信公众号比较火，老板说能不能做个公众号，研究了段时间，没过多久，用PHP写的后台做了公司公众号，不知不觉也算是PHP入门了。再后来公司要转型（恩，这是典型的创业公司），要做农产品电商，需要做一个电商网站，但是老板公务繁忙，没时间搞，只能让我负责，还好有一家公司提供整个一套电商解决方案。后来还算顺利的利用三方提供的方案，搭起了网站的雏形，至此Android已经和我没有关系了。尽管网站已经可以跑起来了，但是问题很多，界面丑，后台管理缺功能等等问题接踵而至。从此开始有做起了网页前端，不时的开始去改后台逻辑。14年3月网站总算能见人了，这时的网站首页，已经被我改的面目全非（褒义），因为我比较喜欢小米（我是一个代码层面的米粉），后来整个主页被我改的颇有几分小米官网的感觉，现在想想也是醉了。我改版后的商城主页地址  http://www.ubive.com一个农产品电商主页，其实不该走简洁路线，这是一个产品定位问题，但当时确实任性了，完全按照个人主观喜好去做，目前网页现在还是这个风格。优倍商城不知道网站现在运营如何，但是老板确实挺牛，没有融资，坚持了三年，也是蛮拼的，祝福老板。网站上线的几个月后，继续负责网站优化，但是隐隐觉得我还是爱Android多一点，后来14年六月份辞职，继续开始自己的Android开发之路。</li>
  <li>日拱一卒\专注做事靠系统，不是靠感觉。05/16昨晚、今天学习gradle、打包收获不少打算去古北水镇，没去成孩子的周计划执行媳妇早起计划实施05/15看钓鱼陪孩子去打球教育问题，最后发现是自己的问题05/09做完了四月总结，五月计划，Notion很好用今天母亲节，买了一些海鲜。PicPlus觉得还有很多想法，但是目前还是应该多花时间在工作上，对，就是投入产出比。05/01带老爹老妈去旅游，天津市中心很不错。04/15入职字节的第一周，感触比较多，对字节也有了更多的认识。好好学习04/05昨天去录播课，三个人第一次面基今天在自习室整理东西腾讯vs头条即将决定，目前腾讯更占上风上次带老爹老妈去王府井，一起吃饭，看到老妈开心的笑容，很开心。03/22上周五面试完腾讯的最后一轮，这一次的面试彻底结束，这真是最忙碌的一次面试，一直想写一个面试总结，但感觉现在还没有确定去哪，所以就想先等着。最近一周找完工作，状态极其差，最近的情绪也是，昨晚继续听《人性的弱点》，每每这种时候，它总能给自己一些力量，关于焦炉，书中这样说，”过好每一个独立的今天“。孩子今年变得很叛逆，顽皮，不免让人生气，也会思考是不是陪伴他太少了。02/10最后一天，后天过年，今年的年不一样。跟老爹去外面溜达了一大圈，聊了聊。面试了三个同学，只要问技术，很容易把面试者卡着，自己其实也是。01/23没有状态，睡了一觉头疼难受抱孩子抱了一路，胳膊酸痛明天一起商议播客准备算法学习，但从早晨起就没有状态，差后面使用Notion进行输出01/17听《原则》这本书，作者是桥水创始人，目前在听他自己的历程，他把儿子送到中国，让我听惊讶的。但是但我知道他这么做的决定时，有可以理解了。这两天研究RecycleView，终于对它有了更深的理解。01/13中午发现一号院球场恢复了，还在球场投了一中午篮，感觉不错。全屏方案确定了，还不错。发现主题作者更新主题了，把最新的暗黑开关考皮过来。01/09上周持续了一周的牛市，赚钱感觉很刺激，建立每天的数据记录。今晚适配了暗黑模式，方便自己看01/03要想得到什么，总的付出些什么电影《》01/02今天更换了博客主题，主要就是因为快，访问速度嗖嗖的。之前的主题也很简洁，但是访问还是太慢了，现在对速度很敏感，那天搜了搜，找到了这个主题，今晚便顺手换了。另外，好快，2020的日志页已经过去了，今晚新开了页面记录2021。2021，还没想好具体的计划坚持学习，补充计算机底层知识，比如操作系统、计算机原理。汇编语言学习听书、看书，最好能不断输出，看书不求多，但求让自己更好的思考，让自己内心能够安静下来。认真工作，做好分内事。</li>
  <li>日拱一卒\专注12/19周日，带娃去做公交车，他很喜欢坐公交车，去没去过的地方。从十一回来后一直在做俯卧撑，坚持的很好。从11.11到上周，现在很确定接下来要做的事，很好，全力以赴。12/16这段时间发生了很多事。出了一个故障，不知说什么，总之还是要小心。工作开始1096，很忙，周末只休息一天，疲惫。上周买了新手机，红米Note9Pro，这是自己第二次买红米，上一次买还买的是红米Note一代，那是2014年，好久远了。积极学习播放器相关的技术，SurfaceView、TextureView。10/24今天是1024，周六，早晨带孩子去外面玩。下午打算去看《金刚川》，期待吴京跟张译的表演，还比较期待魏晨。昨天看完了《人类简史》，一部很震撼的书，相当值得看。10/13中午去了西北旺的一个公园打球，找到公园时已经快一点了，打的还不错，挺好，下次再去。博客加了Twitter链接09/22今天收到了咕咚云图涨价后的第一个订单，开心~涨价已经两周了，但是一直没有订单，昨晚有一个学生购买，应该是有人推荐了。下周回家，这周很忙，想着把工作都做好了，回去安闲一点。昨晚的球鞋早晨被我退了。感觉还是不满意。思考相比人类整体的进化过程，最近几个世纪的发展太过迅速，尤其是这个物质世界，这个快速的进化过程中，人的大脑可能并没有跟上脚步。最简单的例子，以前的人没书读，整体社会的知识量也比较小，所以大家处理信息都可以比较轻松。但是现在，海量的知识充斥在周围，大脑可能就未必应付的过来。所以我的想法就是，这时我们需要借助外设也就是其他工具来更好的辅助大脑。具体需要一点点去挖掘。09/17好久不在这里写东西了。今年主要在自己的APP中写，这里很少来了，但是博客中有一个地方可以写一点东西，感觉挺好。2020注定是一个让所有人铭记的一年，对于自己更是如此。从没有那一年像今年这么丰富。不论工作生活，都面临了不少问题，整体感觉灰头土脸的，很失败。03/27头条面试延迟到周一开发PicPlus感觉越来越复杂，要挣脱出来，开发完今天的2344版本最近没有重要问题就休息然后练习算法，不折腾了。今天周五，很想去打球玩玩。03/25明天要头条远程面试了，加油PicPlus下载量异常日活过千，纳闷发布2342想到了一个不错的上传交互，忙完这阵子准备改正03/16准备一下简历，更新了微博的工作经历，准备给头条投一下简历PicPlus我觉得要缓缓最近准备一下头条刚收到了两笔支持，开兴今天在客厅陪儿子办公03/07这个月的weeklyreview延误了今天发了三个alpha，对了日志被我写到了OnlyWrite中，这里就可以不用写了，后续还会优化我的写作软件，而且回事另一个付费应用。加油吧~02/02这段时间真是一段特殊的时间，肺炎全国混混烈烈，比非典严重，这是一次刻骨铭心的经历。这个年在家里过，孩子已经10天没出去了，好在对此他没什么异议，也是为他好。买了很多药，有点焦虑，努力提升自己的安全边界。01/20疫情带老妈体检ABbug</li>
  <li>Lessismore11/26发博成功率过滤条件排查反垃圾50%测试case补充今天是儿子的生日，四岁了。“今天是我真正的生日”11/25测试case代码提交vip付费代码提交编辑微博开发提测发博成功率：97：63下载成功率：97.67下载成功率：99.8711\25补充草稿箱日志打点VIP付费问题build2提测11/22我战胜了自己。同时叫我晚上去打球，其实我的第一感觉是答应，反正晚上也没事，但是一想，这周的两次打球机会已经用完了，再者，这并不是自己计划内的，如果临时变计划，会对自己的稳定的节奏有很大的印象，最后我还是拒绝了。这次我赢了~了解了一下明治维新，这对日本很重要明治维新是指19世纪60年代日本在受到西方资本主义工业文明冲击的背景下所进行的由上而下、具有资本主义性质的全面西化与现代化改革运动。这次改革始于1868年明治天皇建立新政府，日本政府进行近代化政治改革，建立君主立宪政体；经济上推行“殖产兴业”，学习欧美技术，进行工业化浪潮，并且提倡“文明开化”，社会生活欧洲化，大力发展教育等。这次改革使日本成为亚洲第一个走上工业化道路的国家，跻身于世界强国之列，是日本近代化的起航，但是也使日本走上了对外侵略扩张的军国主义道路，给亚洲邻国造成了沉重的灾难。明治维新毁灭了旧的封建秩序，开创了新时代，无论在日本历史还是世界史上都具有深远的影响。随着西南战争中萨摩军的失败，由天皇操纵、主导政权的封建军国主义国家建立，标志着日本资本主义革命的结束。1885年实行内阁制，翌年开始制宪。1889年正式颁布宪法，1890年召开第一届国会。在政治改革的同时，也进行经济和社会改革。明治政府的主要目标是实现工业化。军事工业以及交通运输都得到很大发展。1872年建成第一条铁路，1882年成立新式银行。为了满足现代化的需要，大量介绍西方的科学技术。到20世纪初，明治维新的目标基本上已经完成，日本在现代工业国的道路上前进。1871年，明治政府派出以右大臣岩仓具视为首的大型使节团出访欧美，考察资本主义国家制度。在富国强兵、殖产兴业、文明开化的口号下，政府积极引进西方科学技术，以高征地税等手段进行大规模原始积累，建立了一批以军工、矿山、铁路、航运为重点的国营企业。明治政府，这是一个政府，天皇是最高层。https://wiki.mbalib.com/wiki/%E6%98%8E%E6%B2%BB%E7%BB%B4%E6%96%B011/21成功完成了激活码的生成和获取机制，LeanCloud大法好啊。继续补充测试caserelease期间草稿箱打点补充11/20图片预上传加密测试通过，代码提交进版补充测试11/18修复完毕所有的半屏发布器UI问题，提交代码到gerrit.修复release期间，SendPoint潜在的序列化问题，并提交release。11/14番茄工作法挺好，昨天已经说了，所以昨晚我已经规划好了第二天的事项。但是就是这么巧，昨晚马上要睡觉了，微信群里开始报bug，然后开始查bug、找原因，最终在同事的帮助下，查到半夜两点钟找到的问题原因以及解决方案。今天大半部分的时间都是在解决这个问题，从而原本今天的番茄计划也就泡汤了…由于线上bug，今天早晨，从到公司就开始联系架构组同事，使用热修复开始打patch包，验证patch、发patch，patch一条龙，这一天几乎就发patch了…😳😳😳年底将至，发patch可不是好事。到微博后这是第二次发patch，其中最近这一年多的时间内，我都没有踩过这种大坑，也没有触发过大问题，但是黑天鹅事件就这样发生了。对待代码要严谨，尤其是那种底层调用，不论多小的改动，都要确保明白改动的上下文，以及使用影响。开发遇到bug是常态，我认为对一个团队来说，快速解决bug是一种必要的能力，但是更重要的，应该是在不停的处理问题过程中，逐步去完善发现bug的体系。这包括自动化测试case、代码review机制、以及一切其他的工程手段，bug永远有，而一个好的开发体系可以最大可能的降低出bug的几率。打算给公众号换一个名字，但是目前还不知道应该用哪个，一开始公众号的名字跟我的微博账号一样—大侠咕咚，后来被自己改成了现在的咕喱咕咚，我认为这个名字并不好记，也不好读，现在想换回大侠咕咚，跟我微博名一致。同时还想到了另一个名字—咕咚的日记本或者咕咚的小本子，纠结中…😖OK，今天就这样了，明天要继续我的番茄工作计划。还有明天中午可以去打球啦~开兴😊工作修复转发微博光标位置异常的问题，并在架构组支持下，发布patch。提交修复代码到release9113版本排查编辑微博时，某些微博带入橱窗异常问题，结果：下发数据错误。11/13最近一直都在听书，《软技能-代码之外的生存指南》，昨晚在听关于生产力的章节，其中作者讲到了番茄工作法。之前对此也稍有了解，但是并没有用过，这次听完后决定在今天工作时实践一次，这也是作者所推荐的，要立刻Action。今天第一次尝试效果还不错。早晨完成了三个番茄钟，下午完成了四个。其中五个均是工作任务，有两个是个人业余的任务。执行过程中有一些打断，这也是工作当中执行番茄钟必须要面对的，我觉得自己处理的并不好，后面继续改进。关于执行番茄钟有什么感受，我觉得感受还挺深刻的。之前工作中对于完成任务的时间是没有计量的，现在使用了番茄钟后，现在对今天的任务用时就很清楚。比如今天要修复编辑微博时的一个bug，这个任务是今天优先级最高的任务，早晨开始便使用番茄钟监督执行，一开始我预计用一个番茄钟的时间（25分钟）就可以，结果最终花了两个番茄钟，后来还花了其他的时间，要算真实时间的话，最终这个任务应该花了有三个番茄钟的时间，也就是75分钟。看，如果像往常那样，不使用番茄钟计时，这个任务的耗时自己是完全没把握的，这就是番茄钟的好处之一，让自己对时间计算更加精确。另外，使用番茄钟还有一个好处就是—Focus，在那25分钟内，自己主要就做一件事，不关心别的事，其他事可以安排到其他的番茄钟，所以内心更踏实，另外5分钟的休息时间内，自己也可以很放松的去看会手机或者刷微博，内心没有负担。以上就是自己对番茄钟的两点认识，后续继续实践，希望可以更好的利用番茄钟。具体我用的APP是番茄todo。在今天午饭前，自己用了一个番茄钟的时间把芽庄旅行记录的文章做了补充。文章是昨晚夜里写的，回顾记录了10月份去芽庄的旅行记录，昨晚由于没有带当时拍照的手机，所以今天主要就是补充了一些照片，重新读了一遍文章，修改增加了部分文字，想要查看我的芽庄之旅文章可以点击文末的阅读原文。下午练习一道Python算法题时，我需要用PyCharm编辑器，但是打开后却发现它需要激活才可用，否则只能用30分钟，便会自动关闭编辑器。然后自己下意识的去搜了下激活方法，都很麻烦。不过稍微想了下，30分钟，不是整好是一个番茄钟的时间吗，那我干脆把它当做一个番茄钟来用岂不很合适，30分钟不长不短，对练习一道题来说，时间刚刚好，到时间了自动提示我关闭编辑器，有意思。我一直有个习惯，每天去记录当天发生的事、或者一些感悟。之前都是记在博客或者日记软件，时而记时而不记，最近有个想法，想把这些内容发表出来，发表在这里，一是督促自己更严谨的措辞，二是将自己的一些想法分享出来，不管有没有人看，不重要，关键在于磨砺自己、不断去输出一些内容。点击阅读原文查看我的芽庄旅行记录。工作修复完毕付费图片再次编辑的bug。之前发布付费图片后，选择再次编辑，接着用户如果删除完所有的图片，然后接着添加新图片，会导致新图片失去付费可见的特性。半屏发布器样式优化开发。根据UI标注更改样式。11/12下线AB开关。本以为很简单的事，花掉了我今天80%的时间，很不值得，尤其是下线图片相关的一个开关，本来就不是自己的业务，自己还要下，下次这种事，做之前先要考虑下，原则！原则懂吗，不是自己的不要动。而对我最重要的一个进版需求，只花了不到10分钟吧，就有好的解决方案了。这两天计划执行的并不好，除了早晨每天坚持波比跳，还挺好的，其余的都没有严格执行，我觉得跟周末有很大关系，以及上周用力过猛有关系，下一步继续找节奏，找到合适的节奏。对了，昨天因为把稍后阅读重新启动了，导致花了很多时间在上面，尽管也有收获，但是破坏了自己的整体节奏，得不偿失，还是要把事情都规划起来再执行。11/11天气不错，送儿子的路上双十一，剁手节，剁了1000多终于修复了稍后阅读客户端网页不显示图片的问题，搞了这么久最后对比github上一个项目发现是少设置了enableJavaScript这个选项，有点衰啊，不知道启用js跟显示图片有什么必然关系。以后终于可以安心的用自己的稍后阅读客户端读文章了，可能要优化的地方还有可能，有意思，好玩就行。中午打球，还是挺开心的，这周继续只打两次，周五再打，每次打完把衣服都洗一下，回家首先洗澡，养成习惯，不拖延，否则到睡觉时在洗就迟了。儿子做的灯塔工作修复了alpha期间报出的问题，一个是多线程操作List导致的索引异常问题，一个是activity已经销毁了，但是加载图片的问题发布器菜单增加描述信息需求测试通过，代码提交gerit.把枚举文章发布了。11/07篮球鸡腿激励顺利完成日志的问题，加密还有问题，明天解决。老妈炒的菜，油有点多…波比跳进行顺利，马上到周五了，计划执行的不错…这周的篮球鸡腿奖励计划成功，今晚买了一桶鸡腿，好吃，目前看这周方式很有效，继续坚持。11/06早晨看android技术点，看到了Binder，唯术的那篇文章非常棒，继续阅读，读完对Binder有了更深的理解，Binder机制需要了解操作系统的知识，比如用户态、内核态还有进程隔离等等特性。继续学习，需要写一个AIDL的demo感受一下。中午投篮，没打球，这周的计划继续进行中。炸鸡腿~~~下午，上次的保险哥们来微博，跟他聊了40分钟，医疗险，我要了解并准备购买了，谢谢哥们。博客增加了评论和访问量，感觉不错。报销下来了。报销了3200，比例56%。医保就是好。但打球还是要当心，不要伤自己，也不要伤别人。11/05安排了一整天今天自己安排的一天，所有事项均完成。给我的感觉是，严格按照预想的计划，这样事情更可控，要注意的就是及时纠正自己想要放纵的心，管理自己。中午带着海龙一起打球。发布器需求开发的很快，早晨开发，下午提测。枚举那篇文章自我感觉不错，再Review下，联系鸿翔发布在它的公众号，以后的技术文章都可以联系大V发布啊，Goodidea.今晚吃炒面，开兴。回家11/04今天比较轻松，需求中午搞完，下午把Enum的文章写完并发表在博客，感觉还可以，需要继续体系化写文章的套路，继续总结吧。把少年的你发布到了公众号，还开启了打赏，如果这次没人打赏，暂时就不开了。文章被自己延迟了两天发布，很正确。昨晚听书，听完一节一定要听写做笔记，我觉得以后看东西，应该强迫自己写下来，或多或少都要写，让着成为一个好习惯。今天开始，晚上规划第二天的事项。明天中午打球。追踪上传图片文件代码，重新设置加密字段的上传，上周一股脑的添加有问题，这次通过读代码，精确的找到了对应的代码。尤其是发博需要添加加密参数这块，这里的key为medias，通过全局搜索找到了设置的地方，然后顺藤摸瓜，将上传文件完毕后的回调信息跟发博过程关联了起来。确认发博预上传日志打点。测试Typoratag搜索，#test#typora11/03昨天去看了《少年的你》，被易烊千玺的表演惊喜到了，表演的很棒，另外剧情也不错，故事性很强，昨晚就写了部分影评，今天趁着孩子午睡把文章写完了。这周开始每周一篇技术文章，一遍思考记录类文章。10/27这两天更新了Blog，优化了列表展示，丰富了展示元素，模仿了DongSuo-徐晓飞的个人博客，另外，今天突发奇想，博客一直缺少一个展示每年发表了多少博客的页面，也就是经常说的归档页面，今天给补上了，挺不错，Blog|咕咚带孩子去了篮球训练课，效果不理想。晚上妈妈做的窝窝饭，非常好吃，吃完去小区转了两圈。反共识当我们完全相信一个思想时，我们就被思想控制了，而不是我们拥有了这种思想，这是一种可怕的现象，因为生活中这种情况还是挺多的，对名人的盲目崇拜，对权威的全盘吸收等都是如此。对于此，我们要做的就是脱钩，让我们的思想不等于“我”，from反过来想10/241024今天是程序员节啊，改了一天的bug，该回家了。优化了编辑微博的效率问题提测标签缺失、原图标志丢失的问题个人博客用了2017年的一张照片，感觉良好。从芽庄回来已经三天了，改天记录一下。10/16明天去越南芽庄。这是自己第一次出国，体验不一样的旅行。中午去打球了，现在挺好，天气好，自己对自己状态也比较满意，总之都不错。昨天接孩子回来了，不喜欢他调皮的样子。但是真的很好玩。老妈做了酸汤，还有南瓜丸子，回去喽。10/10你的价值就是现在，把事情想清楚，利益谈明白，不要占别人的便宜，也别让人占你的便宜，拿着兄弟，道德来说事情，多是给你套道德枷锁，占便宜的，你听着舒服，损失的是利益。别想将来，做好每个现在，就不愁将来。不要义气用事，人这一生实际上时间很短，你有父母双亲赡养，有妻儿老小要呵护，回头想想有多少事情，是自己感情用事，自己给自己挖的坑，又用了多少代价趴出来，还有多少爬不出来的冤魂孤鬼，他们只能悔不当初，但有什么用呢?https://weibo.com/2189910831/IaQK83D6k?type=repost10/04参加婚礼，晚上回家，没什么想说的10/01到家两天前天晚上到家，在老爹房子里睡了一晚，昨天早晨带轩轩去了广场，顺便在一种买了感冒药，轩轩很可爱，买药的阿姨很喜欢他。然后去看他的姐姐，顺便买了面包，但是姐姐不在，我就在哥哥家呆了一会，跟哥哥嫂子聊了一会。完了吃了拉面，但是不怎么好吃，改天再去找一家更真宗的。下午买了面皮、牛奶去东寨，不怎么好打车，让轩轩跟我走了好久的路，一路上问我哪个是我们的出租车。打到车后，司机是一个不错的年轻人，很喜欢。到他外婆家，然后去数羊、吃东西、抓虫子、喂鸡，干了好多事，玩的最有意思的还是抓虫子。他胆小，但是又特别想玩，后来抓了四五只虫子便去喂鸡，小鸡很爱吃。后来我在朋友圈发了他数羊时的图片，大家一致被他搞笑到了，小孩真的很可爱。。。09/28坐火车回家从早折腾了一天，一天之内买了三次东西，吃了两顿饭，很忙碌。最好吃的是自己做的油蒙大虾，做法简单，味道也不错，轩轩吃了很多。下午买了腊肠，炒了蒜苔，味道很好，但是不敢多吃，不多吃的好处就是晚上肚子很舒服。相反，妈妈晚上吃了一些肚子就不舒服了，妈妈还是少吃…轩轩对回永昌很兴奋。叫了一天晚上迫不及待的去做火车，跟妈妈再见时也是非常轻松，当然妈妈也是，没有任何放不下，就回去了。没有换到下铺，晚上只能睡上铺，他居然也十分兴奋，我喜欢高高在上，但是爬到床沿时又害怕的不行，睡下后各种推脱，最终还是睡着了。妈妈回家后，应该是被家里的媳妇触动了大脑，然后激发了一个想法，然后被想法控制，回到了另一个模式，相比她自己，这方面我比他了解她自己，无奈无助09/27放假了十一前的最后一天，昨天的bug算是解决了，一会继续看看问问，争取明天可以提测。报销顺利完成今天忘了发周报啊，连泽关注了我的微博晚上吃完饭在思考，这段时间俯卧撑不能继续锻炼了，所以每天坚持的习惯就少了一个，实际上，坚持了这么久后，我深深的喜欢上了坚持的感觉，他让我觉得踏实，所以今天在心中给自己加了新任务，每天记一件事或者现象，然后发表自己的思考09/26优衣库中午永超同学叫去打球了，然后今天背书包去了，感觉有个打包确实方便多了。打球这么多年，在球场上永远有人会教你怎么打球，包括投篮姿势以及跑位等，就像一个学生，我一直在学习。触摸冲突的问题必须处理好了，一个实际上影响并不大的问题，产品一定觉得问题很大，同样的问题，不同人的感受完全不一样，在微博内问题太多了，如果细究根本没完没了，这次首先自己没有处理好…另外，连泽给自己挡了许多麻烦，他是一个好领导，这次把问题处理妥了。发布进度的卡顿问题要解决。晚上优衣库买了一件外衣，不错，挺喜欢..基金加仓了12000，另外增加了创业板跟医药指数基金的定投。09/23中午肚子不舒服，去了球场路上听了微信读书。这么多年一直没有做职业规划，真的就是漫无目的的漂流，你可以挣不到钱，但是得有目标，得有规划，有目标了实现不了是另一回事，但是没有设立目标就是自己对自己的放纵了。工作：同步了视频发布队列的相关代码逻辑，明天提测…09/22有必要经常看看自己之前写过的文章。重新看的时候可能会有一个不同的视角。消费主义害死人收入的绝大部分要投入到收生产资料，少部分用来消费，资产能给人带来被动收入攒钱最重要的是攒资产积累很重要，要成事，积累很重要，暴富是小概率，而积累可以让小概率变成大概率，积累很难但有效多输出也是积累的一个提现沉默成本人做决定时总是倾向于关注眼前的情况，实际上很多时候别人给自己挖坑就是看准了这点，给你设局，所以很多事关利益的决定都要思考下，他是不是让你进入他的局。说到这里就想到了所有买房的过程，都是让你先交点钱，这就是典型的套路。有目的性地制造对方的沉没成本，有利于提高交易的成功率。相反，如果能够克服这种沉没成本，不被这种情绪所左右，将有可能做出更加理性的判断09/21周六的一天，打羽毛球，买菜买鱼，睡觉，莫名的累~媳妇要看我日记，就让她看吧…秋天到了，今天的啤酒也到了，味道不错，媳妇也爱喝…完成了每日一题，并把技术积累分享到了issue.床头有必要放一本数据结构的书，坚持多看相关的书籍。09/20任何时候都要记得一件事让自己变得更好，更有价值这是永远也不会晚的一件事。做事要有结果，有反馈，不论是给自己，还是给领导。中午购买移动充值卡，顺便约福生聊天，工作、生活、技术都聊了聊，还是以前的感觉，我们都有了白头发。几个问题解决的挺顺利。09/19打球，中午投篮，下午4V4，收着打，安全第一，时刻谨记。自律，坚持非常重要，凡事都需要积累，要有量变才会带来质变。今天的SheetLayout进展不错，要坚持搞，事件分发一定要结合实战才会影响更深刻。09/17中午戴面具试着打了会球，感觉还可以，只是出汗后会有点滑，另外今天两次被打到面具，面具有用。我要把SheetLayout给整出来。09/16上月的今天8月16，哪天是周五，鼻子伤了，一个月后一切都已经基本回到了正常，时间是最好的疗药。每天所有的事情，都要回到原来的样子，回到正轨，下班前记录日志。购买了小米任我行，以后更好的打理微信消息，拒绝消息泛滥。用好我的list，继续规划每一天。面具到了，可以。09/09最近一段时间没怎么更新日志，可能跟换了语雀有关，也可能是太忙了，我觉得有必要好好总结一下这段时间。今天我还是把日志通过坚果云做同步，感觉靠谱，书写也方便，后续可以在一本日记中记录，然后粘贴过来。最近事情挺多的，感觉最近花了不少钱。网费欠费了需要续费，昨天去昌平东关排队，营业亭效率极低，一个下午也没有把事情办妥，索性这次换了移动，今天早晨看到了他家的广告，下午已经让师傅弄好了，599一年。医院消费，手术18000，还好可以报销，明天把新街口的门诊发票也打了，然后包门诊费用也报销。打车、吃饭、景区、都还好，主要的还有幼儿园的学费，一年的话3万多…啧啧09/08圆明园昨天把老爹送走了，本打算送到站里就可以了，但是看到老爹不安的神情，我还是直接把老爹送到了车厢里，人老了，对于外面的环境总是不那么容易去了解，就像我们刚到一个陌生的地方。其实早晨本来打算带老爹他们去天安门，但是国庆封闭了，只好去了圆明园，非常好，很值得。09/07天坛带老爹老妈还有轩轩去了天坛公园，主要是他们都没有去过，天坛是背景的地标之一，很有必要去一次。跟老爹站一起，我好庞大，老爹好瘦。老爹老妈天坛08/30出院后，重回上班…08/10一个舒服的早晨。带孩子去体能训练，自己去打了会球，全场5v5打的很尽兴，轩轩还在旁边做我的观众，享受这种感觉。打完球去买了烤鸭，轩轩一直说，我最爱吃烤鸭，回去后买了一瓶啤酒，啤酒+烤鸭，完美的组合，爽。08/07转眼已经是七号了，最近图片编辑的需求够呛，今天完成了。中午去练球，一号院碰到一个初中生，天赋不错，有钱真好。刷题继续中，加油，坚持…07/31买了小米的键盘，很期待，赶紧解决一下我的键盘输入问题，篮球没劲了。07/30早晨自己做了宫保鸡丁，火候掌握的不好，火大了，但最终味道还行，中午吃的很不错。07/29下雨，把日记挪到了语雀，感觉还不错，免费图床。另外把昨天想到的技术日志也加了进来。加入了千古一号的优质内容分享群，有意思。他看到我之前微博的一句话便邀请了我…07/28带孩子去体验篮球训练他还挺喜欢跟他们一起拍球，训练（玩），看到他很开兴的样子，结束后便报名了。我还是觉得他身体有一部分的运动基因，身高也高，篮球可以训练一下…中午饭后，因为我们在家他不怎么睡觉，所以我骑车子带媳妇去了农学院，学了没多久回来了，天气比较差。但是链表又看了一遍，掌握的可以，继续保持。07/21今天更新咕咚翻译很久没打开咕咚翻译的项目了，之前每次打开都是编译错误，今天终于找时间把编译调通了。同时修复了之前影响我使用的一些细节，修复时还删除了好多旧代码，旧逻辑。这次把背单词这个功能直接删除了，之前自己曾花了很多时间开发这个功能，但是事实上他并不好，这个功能是一个鸡肋。删代码时便在思考他们的意义是什么，我认为最大的意义对我而言就是这个过程，让我意识到核心功能的重要，决策的重要，否则很多事便是无用功，感谢这些东西带给我的思考。经过几次删代码，自己对产品有了更多理解。功能一定不是越多越好，专业，深入才是方向。陪媳妇来北京农学院学习之前说了很多次，今天终于陪他来了。学校挺大，树很多，没有开放的自习室，但是有一些公共空间可以用，中午的饭挺好吃。学校的球场很多。07/16今天把火币清仓了，从一月份跟着今朝买火币，到现在半年的时间，收益不错，事实上跟对人很重要，今朝很厉害，眼光独到，是一个非常不错的投资者。跟他实操学了不少。但是投资是自己的事，一直依靠别人并不是长远之计，还是自己多思考。一直都在说，币圈最好的投资就是拿得住币，事实上很少人能做到，现在想明白了，为什么很少人能做到，因为如果要想拿得住币，你只有以相当低的筹码才行，否则币市这种上上下下的波动，搁谁谁也慌，所以前提是你能以较低的筹码拿到币，否则还是老老实实高抛低吸吧。但是高抛低吸也并不简单，因为你要跟自己做斗争，很多时候贪婪占据了上风，在执行时总是很难做到，一句话赚钱并不容易，投资的过程就是发现自己的过程。07/05轩轩最喜欢的玩具，邪恶猪排博士，大的小的都喜欢。这里是一个非常好的地方，想什么写什么，我的秘密花园经常性的怀疑自己做需求时，面对没做过的东西，总是没信心，已经好几次了，但是每次真的去做了，却发现并不是想象的那么难，终归自信心不足思考当下对自己最重要的是什么事，这事老是想不明白，或者说想的很明白，但是却不能执行。老妈的炒面片太好吃了晚上很堵，回来做了一个vlog07/03房子到期了，让房东换了洗衣机跟电视房子还没续约，房东很忙的样子家里不愉快孩子很可爱看录像找到了投篮的关键点，任何事只要用心真的可以找到门道06/30这是我的爸爸今天听到最暖心的话，一个孩子拉着我的手要走，轩轩急忙跑过来拉住我，很严肃的说…06/26昨天是四周年结婚纪念日，晚上跟媳妇约定去吃饭，去了汉拿山，我下午吃了一点东西，所以并不是很能吃。伴随着四年时光，发生了很多事，总归很多事在越来越好的方向发展，也有些东西，是那么难以改变。席间，我跟媳妇说，你最怕得知的消息是什么？他说是面试，我说是我妈的电话，因为最怕电话里说轩轩感冒、生病之类的。话音刚结束不久，真的来电话了，只是这个消息远比生病让人难以震惊，“轩轩找不到了…”很难想想当时的感觉，很蒙。。。这怎么可能，很快我让我妈去大声喊，我们收拾东西开始赶紧回去，打了快车，我还准备打110，人生中第一次打110，没接通！！！好在一会儿，那边来电话，找到了…因为骑滑板车太快，没注意就丢了，跑到了跳舞的人的地方…06/23开发稍后阅读，进展不错，功能挺好…带老爹去泰康看保洁工作06/12轩轩不想去上学现在有了新的说辞：“我下课了…”端午放了三天假，硬是没抽出时间去写月总结05/23骑电动车带他去幼儿园，之前在家里跟他说去外面找龙猫，他很高兴，但是龙猫没找到，只找到了大树。过红绿灯时，他挥手示意车停下，可爱。05/18早晨决定要来加班，儿子听到后，先是说你去加班，我跟妈妈、奶奶玩，接着等我去卧室换衣服时，我妈跟我说，中午没饭吃怎么办，他便拿了桌子上一个花卷过来，让我带上。顿时好感动，同时也有点难受，他总是习惯了分离，面对分离总是能很轻松的接受，sosorry…05/16最好的教育一定是帮助孩子成为最好的他自己最好的教育一定是帮助孩子成为最好的他自己05/14成功把歪说后端进行了代码部署。后续只要写完业务，直接push到github,就会自动部署服务到生产环境，非常爽。最近把自己的各个小APP都打理了一下，感觉不错。利用leancloud做了一个云收藏，目前提供了简陋的api收藏取消收藏收藏列表老爹在内蒙古打工，今天发过来的照片。是一个原始森林。05/13周末下雨去了公司加班安静的环境完成项目首页搭建easy梳理项目结构，有点复杂媳妇晚饭不错，鸡腿+土豆肚子不舒服，少吃、忌油腻adapter05/04仰望星空，会让自己进入片刻的宁静。天很高，星星很远，我们好渺小，如同沧海一粟。万般皆为虚，奋斗为何，发光发亮又如何。疲惫不堪，心力交瘁。一切的一切应该很简单，为自己快乐，让一家人快乐足矣。奈何做到这一点，很不容易。命运把你推到了今天，若没有足够的勇气，很难回到起点。这个世界，当大家压抑，就会去寻找自己的解压方式。写字就是一种很有效的方式，我很喜欢。我喜欢把这些写下来，写完的感觉就像是倾诉，倾诉完了，也许就会好点，心里获得了些许的藉慰，尽管他可能并不能产生长期的作用，但就如其他的泄压方式，它的意义其实就在于解压的那个过程。04/24火币大跌，还是没学会止损。于此同时也没有去止盈，对于做短线，一定要掌握这个。04/10投篮的感觉越来越好。还是少穿跑步鞋打篮球了。穷则变，变则通。组织架构要调整了，谁知道以后会咋样….04/05早晨骑电动车去媳妇到地铁，顺便带着孩子，他可高兴了，可喜欢做地铁了，所以我带他去了地铁里面。他很喜欢帮妈妈过安检，他经常要把妈妈的包抢到自己手里，然后过安检，今天竟然看错了人，拉着一个男生的盒子就要过安检，好有意思。我带他去了南邵，他要吃好吃的，我带他去了两个超市，最后他要了一个玩具吃的，然后带他去文化广场，等他吃完，跟我说，让我去打球，我投了一会篮，他就叫我回去，于是我便也回来了。回来跟他种了蒜，蒜应该会长得挺快的吧….今天终于把之前落的Java文章写完了。做完一件事很重要，做完就不去想了，要做做彻底。04/02又到交房租的日期了。该送孩子上学去了。打球次数要限制，不能随心所欲，精力很重要。三月总结结束。继续早起。03/23今天带孩子媳妇去沙河水库转悠，天空很蓝，还有点风，哪里人也不多，走在河边很舒服。02/28博文增加工作内容记录，主要记录工作中大的项目，以及开发过程中学习到的东西、思考，微博工作记录02/24这周决定使用Weekly的形式强制自己去做深度思考和持续输出，试行了一周，坚持的不错，发现压力也不是很多，300多字的感悟很容易写，也比较容易发挥。只希望自己可以坚持久一点，目前在博客也响应了开设了Weekly一栏。昨天带父母去了公司还有颐和园。02/17到幼儿园给儿子报名，因为接送孩子有一段距离，今天还买了一辆电动车，比较喜欢这个车型02/16带孩子去做入园体检。他太乖了，不论验口腔还是最后的抽血，都十分配合，尤其是抽血时，他竟然主动把手伸过去让抽血，疼了但是没怎么哭，准备买电动车。看了两家店，还是想买贵点的.2500不想将就。打球。媳妇陪着打球，投篮特别好，几乎都进了，篮下都已经非常不错的抓拍，太帅，感谢老婆。02/13-基金前天在知乎搜问题的时候，看到了一个基金专栏，基金：从0开始学基金投资-知乎，专栏对基金的基础框架做了一些较为全面的讲解，包括基金与股票、债券的区别，基金的分类，以及如何买卖基金。对自己而言，从14年接触基金，但是却一直缺乏系统性的学习，在专栏的末尾，作者也说了系统的知识框架学习，是提高效率，节省学习成本很有效的方法。我很认同这句话，尤其是看了这个专栏后，更加认可。我们需要的学的东西有很多，工作中需要学习，生活中学习，要学习的地方很多，但是对待新东西很多时候都是头疼医头，脚疼医脚式的学习，好多时候，我们回去网上搜一些文章、教程看看，了解就算完事。当然一些技能本来对自己也不太重要，所以了解一点点就可以。但是生活、工作中有很多东西是需要我们系统性的进行学习了解的，否则自己永远可能是个门外汉。基金学习的文章记录地址02/03工作日的最后一天，写了一篇文章进行总结写在2019春节前的最后一个工作日01/30晚上去室内球场打球，但是打球前却发现球鞋忘在昨天的大巴车了，所以今天我还是去打了，穿着牛仔鞋，发挥的不错，勾手进了不少球，感觉很好。另外最近在折腾孩子的幼儿园问题，终于还是决定去瑞嘉幼儿园，今年该搬家了，01/26今天早晨看天气不错，就临时决定去滑雪，跟福生确定后，没有带孩子，后来我在美团定了票便去了，结果很尴尬，票买错了，买了夜场票，后来退票，给美团客服打电话，后来买了三个小时的套餐，给媳妇要了一个头盔，但是后来发现意义不大。但是自己还是太粗心了，夜场票我居然没看到害得自己浪费了不少时间，自己粗心的习惯很久了。反思下，我认为对自己做的事，尤其是手续类的事，多检查一遍绝不是坏事，小心驶得万年船。滑雪时，一开始并不顺利，但相比15年，已经好多了。后来滑了初级坡，前两次都不好，不知道如何去控制，后来第三次突然就会了，感觉不错。下午回来陪媳妇去了理发店，剪了头发，晚上发布器又出问题了，又出问题了，这真是揪心。01/25昨天老爹老妈在家炸了老家过年时吃的油香还有油条，回家后就吃了三个油条两个油香，很好吃。今天我要把图床这个是什么做完，不像拖着了。一段时间搞好一件事。最近连续三天完成了简书上的文章发表。01/13早晨去参加了李世忠的结婚酒席，吃的杨家火锅，还挺不错的。忠哥结完婚，我们12年来北京的同学大部分都已经结婚了，后续这种结婚聚会的机会也会很少了，这意味着大家见面的机会也会越来越少，现在大部分人开启了另一个人生阶段。吃过饭去了家乐福超市，由于之前公司发的福利卡只能在家乐福消费，这次积累了200多，可以一次性消费完，所以早超市里开始大肆购物，200多块钱如果买日用品还是可以买不少的。后来便买了不少肉还有一些吃的、玩具等…晚上回来吃糖醋鱼、还有炸鸡块，由于太久不做了，我炸的不好，火候有点大，鸡块没有炸熟，第二次才炸好。轩轩貌似很喜欢糖醋鱼的味道，下次还是吃鲤鱼啊。还要买个小的。晚上抽空把我的奶奶发表在了公众号。01/10早晨妈妈做的炸糕，很好吃。妈妈现在很喜欢网上找食物教程，这个炸糕也是看的教程后做的，我该买点豆沙了。带孩子去了沙河，他很喜欢向水里丢石头。01/04微博工程模式快捷入口完成，昨天还在AndroidStudio插件中集成了，感觉很不错。今天决定把奶奶那篇文章发布了，补了一些照片，修正了部分语句。今天去体检，大都正常良好，视力下降了，需要调整。在考虑学习转战机器学习方向，我认为自己有优势，现在不学更待何时。01/01飞机游览北京航空博物馆，飞机很多，山洞里展示了中国航空发展史。2019.01.01北京航空博物馆游览_腾讯视频</li>
  <li>DaybyDay12/30今天放假了，媳妇去公司学习去了，白天带着孩子跟父母去沙河边。但是轩轩就像坐地铁，所以后来我一个人带他去做地铁。去了南邵。轩轩在南邵那个广场，我在投篮他还喜欢做地铁了。最近思绪很乱，突然就不知道该做什么了，对很多事都提不起劲来，难道是年前综合征吗？需要静静，现在能安静的时候太少了，我需要找到可以让自己安静下来的方法。一年要结束了。该总结一番了，想想也没有什么好写的，这篇日志已经把自己很多事都记录了，挺好的方式。我明年后年应该还会这样记录下去。12/28今天周五，老爹从永昌坐飞机来北京，老爹第一次坐飞机。但是之前万万没想到，今晚我们有最后的三四名比赛，我很想拿下这场比赛，我不在的话，这场比赛会很难。老爹一个人来北京，下飞机后本打算去接老爹，但是现在怎么办呢？就来考虑再三，我还是没去接老爹，下飞机后我给老爹打电话，让他做出租车回来，还好一切顺利。晚上我们成功击败了微博运营，然后夺得了新浪篮球赛第三名的成绩，这已经是我们能拿到的最好成绩，前两名都是赛前的种子选手。赢球的感觉非常爽，最后一场比赛大家打的都不错，都有不错的发挥。篮球是一项团队运动，靠一个人赢不了比赛，再次感谢每一个队员。朋友圈说说12/24明天圣诞节了今天修了发布器的bug，有时确实需要把问题叙述出来，让别人听一听，自己研究问题久了容易掉进死胡同。thankszsl最近胃不舒服，早晨的时候我跟妈说，也许是妈来北京后做的东西好吃，我吃的就多了，然后胃承受不了，所以关键还在于自己，要克制饮食。现在重新思考了自己的清单机制，果断把每天的事情减少到一条。很好…12/15折腾一下Https域名重新梳理自己的学习重点https://blog.csdn.net/Cowry5/article/details/8031005212/13lessismore年末突然就想把博客主题换为这种简洁风格的，从这点可以看到，每年自己的审美都会变化。之前喜欢简单，但是同时喜欢页面元素多，内容多，现在反而喜欢安静的博客。工作上面对问题，始终需要抱着解决问题的态度，而不是去逃避问题.这一点，自己最近体会很深刻，也是自己需要加强和改变的地方，可能会难，但是对于自己而言，是一种打破自己平静的一种方式。最近还给项目工程模式优化了开发体验，但是很累，有时自己在跟自己做斗争，“要不要做哪些？有意义吗?”我时常这样思考，但是现在需要借鉴lessismore,现在自己时间变得越来越紧张，应该要优化时间分配机制，让自己的时间更有价值。11/30白天今天新浪20周年庆，公司很热闹.另外要说的是，今天玉龙离职了，到公司后跟他一直是搭档，一个很真实的人。祝他越来越好。晚上打篮球比赛，状态很不错，一开始就在内线如鱼得水，抓了不少前场板，并且转化成了得分，可就在正有状态时，膝盖被撞了，好在撞的不重，休息了一会好了。最终有惊无险的赢得了比赛，开兴。11/30凌晨一不小心已经11月末，真快，好久不来博客写文章了，今天把Flutter的介绍文章发布了。最近几周在工作之余断断续续的研究Flutter，Flutter真实特别好的技术，文档丰富、思路初衷，尽管目前生态还差点，但是相信跨平台这条路是没错的，Flutter也会越来越好。另外看了不少书，一度觉得很压抑，后来不看书后，发现好了，不压抑了，[笑哭]，生活工作需要认真思考。看书的时候想法会特别多，现在有想法的时候我倒是更愿意把想法写在酷安里。感觉今年年终总结可以写很多内容。不过发现时间久了不写文章，写作能力真的会退化，一个安静、可以持续、不被打扰的环境真是太奢侈了。锻炼身体，早睡走起，6点起床，坚持俯卧撑…利用翻译技术去了解世界，而不是去背单词。10/13转眼已经10月13了，在十一前先是去了内蒙参加了大学舍友的婚礼，同时大学舍友终于聚了一次，挺不容易。后来得知孩子病了，然后赶快回家，所以十一就是在医院里度过的。现在他已经来北京了，很调皮，有点叛逆，需要花更多的心思在他身上了。老妈第一次坐了一次飞机。最近准备学学Flutter，挺有前景的技术。09/09今天在公司加班，昨天在家休息，不过也没闲着。昨天完成了一件想了很久的事，重新设计了柳叶清单的后台API，在Apizza上重新梳理完毕，并最终开放了部分API，最终api的介绍信息放在了github的issue中，后续可能会有地址的变动。https://github.com/maoruibin/maoruibin.github.com/issues/77重新设计api时主要从以下几方面入手：统一响应数据的输出格式支持httpsapi请求地址优化，更加具有可读性具体的响应格式为如下形式：{"code":100,"desc":"deletegroupsuccess","msg":"删除失败","data":{}}说真的，我很喜欢这种形式的输出。https其实挺简单，因为leancloud支持，所以就是一句代码的事。请求访问地址的优化主要参考了我所认为的RESTfulAPI最佳实践·ScienJus’sBlog哥们的文章写得很好，从中学到不少经验。不过在使用Flask的蓝图时遇到了点问题，就是关于urlPath的设置，后来还是解决了。优化完api地址后，不得不对柳叶web代码进行改造，因为path跟数据响应格式都变了，所以通过全局搜索的方式最终把应用内的地址都改了一遍。其实web应用里应该做一个工厂统一处理url,指不定以后还会变动呢。另外，前天买了leancloud的付费服务，之前一直在用体验版，导致柳叶清单会经常性的下线，自己使用也很无语，这次全天在线。使用了付费服务后，为了价值最大化，顺便开发了两个定时云函数，利用爬虫每天间隔两小时自动爬取EOS的价格，然后邮件给我，挺好，不过邮件目前被网易定为垃圾邮件了，总是系统退信，有点伤神。终归这些折腾都挺有意思，好玩，后续还会继续挖掘可玩的东西。嗯嗯，Leancloud的云函数是个不错的东西。09/06北京的秋天是个美丽的季节，温度适宜，秋高气爽，很舒服。最近在学习纠正自己的投篮动作，很有成效，投篮比以前好多了。08/16最近打球比较多，每周大概会打两三次球，主要是发现了一群新的球友，还有那个新的篮球场。一直觉得自己打球够积极的了，但是最近跟这些球友认识后，发现他们跟我一样积极。打球是特别好的放松方式，从接触篮球到现在10年多了，对篮球的始终如一，我应该感谢这位伙伴。发现Gitlab很好用，在枯燥的工作中，一些有意思的工具会带来一些心理上的刺激。否则太乏味了。说道乏味，个人受不了乏味，我总会自己去寻找一些陌生的东西，让它可以牵动我的心，让我可以为之心动。08/15天气不错，中午吃过饭一个人去附近的公园转了一圈，拍了几张照片。已经是初秋了，天气渐渐凉了，这个季节很舒服。08/04他喜欢水枪，我们就陪他玩。我们的未知旅途还在继续….08/05前段时间回家了，很好，回来的途中认识了坐在对面的两个小男孩。他俩是兄弟，哥哥八岁，弟弟七岁。我尤其喜欢这个弟弟，天真烂漫，嘻嘻哈哈，容易激动，说话很大声，带着浓重的地方口音，印象最深的是打牌时那句“赢~嘞~~”。下车时，因为他们从新疆带了很多吃的，所以我帮他们把东西拿下车，但是我最终没有要他们的联系方式，我觉得认识就好，跟他们聊一程就好。07/25每次更新日志的时候也就是更新博客的时候了。最近工作比较忙，接了很多活比较杂比较乱。这段时间打球比较多，夏天打球还是太热了，每次打完都大汗淋漓，但是出汗的感觉很爽。上周去了东单体育场打球，记得上次去哪里时已近时2014年了，时间很快，但是对篮球的感觉却一直没变，那天打球很爽，主要是有一个很能投三分的后卫跟我搭档。最近北京下了很多雨，小区附近的空地俨然是一个杂草地。06/26这月事情很多搬家：房子到期了，房租涨了700不过最终还是续租了，找房子很麻烦。清单最近耽搁了，有点忙接手了微博发布器最近接了CardList的bug,CardList代码很差啊跟龙哥去奥林匹克散步办理天津户口清单小程序版被驳回了功能不完善06/09昨天高考结束了，距离自己第一次高考已经过去整整10年了，我依旧记得第一次高考时的情形，恍如昨日，那时懵懂少年，如今却是孩子的爸爸，此刻我更怀念以前的角色，同时对自己也有很多不满。我需要继续前行，不断迎接挑战，迎接对自己的挑战。另外最近一直在开发自己的第一个web应用柳叶清单，这是一个开始纯粹的demo项目，后来觉得自己可以做的更好，而且自己一直在使用Trello，自己一直想写一个类似的应用，而且自己今年给自己定了预期，做学习前端技术，所以种种因为，一触即发，自己便开发了柳叶清单。自己一个月的时间，花了很多晚上在完善它，把它当做自己的孩子一样在努力浇灌它，一次次的commit、一次次的Bugfix,纵使以后没有那么多的用户，我也无怨无悔，本来就是要取悦于自己的，当然能帮助到更多的人，我更高兴。另外，这次使用了LeanCloud的云引擎，省的自己去搭建后台开发环境，所以我很感激LeanClode这个平台，谢谢。今天看了李安的《少年派的奇幻旅游》，看到开头的时候，差点切到别的电影，最终还是幸运的看完了这部电影，真实很棒的电影，深刻有内涵，简直不要太好，关于人性、信仰。。。导演真实煞费苦心，佩服这样的导演。好电影。04/01Vue+LeanCloud+Flask+GithubPage做了一个网页Todo还在完善中，有意思的实践。maoruibin/TodayTodo:todoisfunny随手给博客换了个评论系统imsun/gitment:AcommentsystembasedonGitHubIssues.03/31一个普通的生日03/29用LeanCloud云引擎开发了一个简单的网页-歪说。这是之前的一个小想法，正好拿LeanCloud玩玩，顺便再次了解学习一下前端相关的技能。03/26记录昨天的一个bug线下crash很刺激，问题原因很蛋疼。另外最近体验了一段时间的Web开发，用了用VUE还有React，作为初学者，个人感觉Vue的使用体验更好。03/12好快，怎么已经三月了，还有很多事在等着做呢，最近都做了啥发布了今年过年时的一个微记录2018回家记录-月牙湖-咕咚_腾讯视频顺便做了一个微名片02/27一转眼已经过完年回到北京了，像梦一样。最近思考比较多，什么是对，什么是错，对错重要吗？自己用二十多年铸就了自己的梦，却用一年多的时间给自己编织了一个密不透风的网难道这就是成长的代价活着的意义是什么，为自己而活or为爱的人而活？最近一直在咳嗽，平安健康的一天就是幸福快乐的一天，为什么要追求那么多，或者为什么一定要那么累？什么是好，可以不用跟别人对比吗？你就是你，好也是，坏也是，追求自己内心的感觉。。。02/04看了阿米尔汗的《神秘巨星》阿米尔汗就像是印度鲁迅，用电影在解放印度女性的心灵最近听到一首不错的歌，好听Time-MKJ01/27最近在开发微博中除夕节投放的功能，胆战心惊的回家的票买了很多年货，都是吃的，给妈妈买了一双鞋01/18每周五的篮球我很准时01/16一月份各种破财，好衰~~~碎屏、维修。。。小心翼翼的活着…Forwhat???01/08优化博客文章Title部分布局，参考（Ling）使用了字数统计压缩首页背景图片去掉Google统计01/06优化博客文章背景选项，并梳理到Readme去掉RSStwitter以及简书联系方式龙猫很好看，这可是1988年的电影了01/03替换了博客的主题颜色以及首页背景修复了打赏按钮的css问题上线了2017年终总结01/022018年第一个工作日修改了首页slogan【重要的事只有一件】每一年、每一月，每一天，每一小时，最重要的事只有一件，专心做好一件事。也只有聚焦才会把一件事做好。LogArchive201720162015</li>
  <li>2017/12/31替换首页背景图以及日志页面的背景2017/12/24增加打赏页面(CSS有点问题)通过shang这个标志进行控制增加了一篇文章gruntwatch-&gt;https://github.com/Huxpro/huxpro.github.io/issues/572017/12/19有段时间没在这里写东西了。这段时间都干啥了呢公司内部的篮球赛结束了，很尴尬的连季军都没有拿到，但是在三个月期间的10多场比赛中认识了不少微博的朋友，很值得。开始思考一些问题2017/10/26早晨再一次经体验了早高峰，看到沙河的长队我还是选择了摩拜去高教园坐车，事后证明这是一个正确的选择。1小时候到北京南站，然后乘坐高铁开始了我的第一次南下之旅，很激动。下午到达黄山北，先来到了老街。我一直比较喜欢古街，旁边还有一条水很清澈的河流新安河，夕阳西下，风景不错，后续再补图。晚上吃了徽菜，老板娘比较有意思，很霸气，一点不在乎我们的态度。嗯嗯休息，明天爬黄山。2017/10/25明天就要去黄山。第一次南下，小激动另外，今天在内部发布了开发的AndroidStudio插件，反响不错。中午去公园投篮，感觉不错，三分也是可以有的。公园旁边就是西山一号院，北京豪宅就是这个样子。2017/10/17公园里的秋天是一个美丽的季节另外，明天NBA要开赛了，不错不错。2017/10/13中午去小公园偶遇网易的几个哥们在打球，然后加入他们打了一中午球，打的很过瘾。其中有一个篮下强起砸框进球，感觉就像是扣篮，特别棒，终于知道扣篮是会上瘾的，尤其是前面还有一个人站在那里。晚上参加了公司内部比赛，输了，但是很开心，打的很轻松，跑完了整场。2017/10/12（内部AndroidStudio插件开发基本完成）放假前就开始开发一个AndroidStudio插件，Wei-studio-tools这是专为微博Android项目开发的用户修改gradle配置以及上传apk到内部仓库。后期打算把ADB那个工具开放出来，其他Android项目也就可以用了。主要是之前受够了在浏览器中上传时的麻烦，不过开始想的简单，功能很快就做完了，但是自己是个追求细节完美的人，所以在很多交互细节上又花了很多功夫，还在回家的路上用sketch设计了界面，总体现在还是比较满意的，除了有一个比较难缠的bug,目前已经在feed项目组使用，准备在完善下，把几个严重的bug修复了在跟架构组推荐下。另外很感谢SM的图床很好用啊推荐SM开关hideLasthideHothideTizihideFriendhideTagif或于2017/10/02(回家)在家里呆了5天，老家天气很好，8号回京2017/09/26永远不要害怕问题顶部消息提示impl2017/09/22很久没有赢球了。happy~2017/09/19（使用来比利评论系统）还是更换了一个评论系统，来必力优点可以评论设置提醒2017/09/18(时间好快)不知不觉已经找完工作在新公司工作了快三个月了。自从到了新公司现在很少打理博客了，甚至连一篇文章都没有。其实又准备过一篇关于Drawable的，这段时间对Drawable有了更多的了解，写写还是可以写出一些有意思的东西的，不过好几次动笔都没写完，先搁着吧。前段时间玩了玩Chrome插件，拿咕咚翻译做了个实验，顺便练练HtmlCSS，今晚发布了1.1，于以往做的APP不同，这次自己用sketch设计了界面，尽管界面很简单，不过还是体验到了sketch的专业，使用sketch可以方便的做一些平面图，挺好的，包括简单的图标，不说了，我的咕咚翻译插件地址不早了，睡觉去了。2017/09/15晚上跟同事打球，左脚又扭了一次，吓死我了，脆弱的脚踝，以后是不是应该去外线打球呢。。。2017/09/08(补图)公司附近是百望山，中午时我会自己去溜一圈，很喜欢户外的感觉，哪怕是一会儿2017/08/24(新浪微博)hereisnewstart2017/06/13(尴尬的一个时间段)上周五打球崴脚了，当时正在篮下进行拼抢，不幸在落地时落在了别人的脚面上，我听到了『咔』的一声，我很清楚这是从右脚踝传来的，然后就到底了。从高中开始打球到现在，尽管我一直擅长打篮下，篮板也很不错，但是从来没有在篮下崴过脚，终究还是来了。短暂休息的过程中，我用微信搜了搜一般的处理方法，然后叫同事去帮我买了一袋冰块进行冰敷，效果不错。周末在家休息了两天，第一天不能很方便的走路，在跟媳妇商量后我最终买了拐，后来到第二天就发现这是个错误，因为第二天行走已经没有什么大碍。然后今天已经基本好了，今天下午还有公司的篮球赛，不过我一定不会去了。崴脚的经历告诉我以后打球风格可能要改变啦，而且确实应该在打球时记得保护自己。2017/05/31(放假回来)从家里回来上班，在家里的几天每天过的都很快，农村很漂亮，我喜欢那些绿色，可以在田野里大口的呼吸，感觉好极了。回家的途中火车真的很拥挤！我的在线简历（2017-墨迹天气）2017/05/21(添加访问次数)最近一直在忙面试，今天看到一微博私信要互加友链，发现对方有一篇文章分享如何给jekyll主题的博客加访问统计，随即就加了，毕竟惦记这个功能很久了。//网站倒计时运行代码&lt;script&gt;window.setInterval('counter()',1000);functioncounter(){vardate=newDate();varstartDate=newDate(2016,11,07,0,0,0);vartime=(date-startDate)/1000;varday=Math.floor(time/(24*60*60));varhour=Math.floor(time%(24*60*60)/(60*60));varminute=Math.floor(time%(24*60*60)%(60*60)/60);varsecond=Math.floor(time%(24*60*60)%(60*60)%60);varstr="我的博客已默默运行了"+day+"天"+hour+"时"+minute+"分"+second+"秒";document.getElementById('count').innerHTML=str;}&lt;/script&gt;2017/05/08(优化首页博客描述文案显示逻辑)隐藏文章显示在首页设置文章的hide属性为falsejekyllifelse语法以及字符串空判断2017/04/28(完善个人作品展示)增加了全国空气质量展示手动设置主页背景高度，通过修改./css/hux-blog-min.cssintro-header.page-heading{text-align:center;height:450px;}2017/04/27(公众号二维码增加开关)qrcode_mp新增的一个page属性用于控制页面底部是不是显示公众号二维码2017/04/25(博客增加了公众号)突然心血来潮，看到小黑屋的公众号后，自己终于把申请了好久的公众号再次打扮了一下，并且在博客中放置了二维码。昨晚添加了自定义菜单，并且编辑了四篇文章。尽管还有很多问题，但是公众号总算是跑起来了。接下来要认真学习，写一写技术文章。如果你看到这里了，不妨关注下公众号？*_*2017/04/24最近这段时间做了不少好玩的东西。先做了一个App易剪,本打算开源，后来赖的没做。然后倒是开源了OneDrawable这一按钮按下效果处理方案，当然这个方案对一般MD设计没太大用处，基本做给iOS设计的UI效果。最近在看Java虚拟机。感觉比以前理解的深入多了。有用的查询网址企业注册信息查询2017/02/15今天更新了Android6.0自定义文本操作的一篇文章，并且投稿给了鸿洋，第一次投稿，看看效果！2017/02/04适配了Chrometabthankshttps://teaink.com/archives/270.html2017/02/03不知不觉已经17了，我的2017会不一样一点。今天终于把G键的映射通过一个映射软件修改了。运行草稿jekyllserver--draftsTopreviewyoursitewithdrafts,simplyrunjekyllserveorjekyllbuildwiththe--draftsswitch.</li>
  <li>2016/11/28今天还是把去年特别喜欢的一个背景图上传作为了我的博客背景。一年的时间，经历了太多，人生就是不断认识自己的过程，自己会对以前的一些决定进行思考，大多数时候，自己不会去太深刻的思考那些已经发生的事，但是这一年发生的一系列事，不由得让你去重新审视自己。幼稚、人心、生活。。。。。2016/11/07今天新增了一篇介绍ReView的文章，昨天就想写，但是净忙着写ViewControler的文章了，就没有顾上，今天即使再晚也要补上。另外，今天因为自己的原因（一行log引发的惨案），公司项目日志数据上传异常，日志数据成倍增长，着实吓我一跳，自己确实需要对上千万的用户负责啊，你的一个小错误，到用户那里累计起来的影响太大了。好在并没有造成什么大面积事故，以后要小心。2016/10/25昨天是1024程序员节,依旧记得去年是一个人过的,那天是周日,我一人宅在家里宅了一天,还写了一篇长长的日志,记得特别清楚,那天为自己换了一个jekyll主题,很喜欢的主题。不过现在已经被我换了,哈哈。黄玄的这个主题确实没法拒绝,太多特性是自己期待了很久的东西。很快,今年的1024这么快已经到了,到今天已经过去一天了,但是昨天的事却历历在目,今年的1024,我不在是程序员,而是作为一个人民群众去所在地派出所办理户口、身份证相关手续。整整一天,我从早晨6.30起床,到晚上8点多坐车回永昌,终于将整个其实只需要半小时就能办完的手续办完了。我目睹了地方机构办事效率的地下,以及鸡毛当令箭使得形式主义作风。终归办完了,思考良多,一方面这种办事机构有问题,另一方面地方群众的素质也是一个问题,不想展开说了!字符串包含判断还是记录下一个Liquid语法问题,检查一个字符串是不是包含一个字符串Liquidtemplatelanguage//定义一个全局site常量theme_color:"#607D8B"//判断双括号{page.cover}contains'zzz'自定义背景至此,我的博客背景支持了自定义纯色背这个特性,默认使用一张箭头背景图片,如果不喜欢,可以为post设变量cover这个属性用于设置文章头部背景颜色//使用自定义颜色cover:"#f78789"//表示使用博客主题颜色cover:"zzz"//使用指定图片作为背景图header-img:assets/header/header_image_road.jpg自定义Titlecolor因为一些背景是亮色背景,但是默认所有title都是白色,所以在一些文章中,如果选用了浅色的背景,标题就会不清晰,所以今天加了一个新特性,可以用来设置title颜色,如下所示,直接在post使用titleColor属性即可。titleColor:"#404040"2016/10/22今天回家了,火车没事干,想起自己的博客草稿箱还有好几篇文章已经放了好久,感觉可以趁这个空修理下,然后就把5.0的元素共享那篇博文更新了。今晚给post新增了一个属性conver用于控制头部背景颜色,如果不设置默认使用一张转为博客设计的背景图片,也很好看。background-image:url('/');background-color:;修改CSS使用gruntwatch2016/07/02不知不觉，已经放弃上一个博客主题好久了，现在福生还在使用我的主题sunfusheng今天，终于有时间可以搞下博客了，这段时间都太忙了。2016/03/27项目主颜色设置在less目录下的variables.less2016/03/26今天已经修改自己博客的主题为另一个主题了2016/02/29隐藏了post页面的tag、category点击相应，因为jekyllarchive不支持GithubPage使用了新的代码高亮样式减小了padding值2016/02/26指定引用图片的宽度大小，可通过如下方式&lt;imgsrc="/assets/over_draw_color_2.png"style="width:50%;margin:auto;"&gt;&lt;br&gt;##2016/01/20修改代码块的主题样式在_include/head.html文件中修改可以再bootcdn下载&lt;!--thankstohttp://www.bootcdn.cn/lightbox2/--&gt;&lt;!--thankstohttp://www.bootcdn.cn/highlight.js/--&gt;&lt;!--thankstohttps://highlightjs.org/static/demo/--&gt;&lt;linkrel="stylesheet"href="//cdn.bootcss.com/highlight.js/8.5/styles/androidstudio.min.css"&gt;&lt;linkrel="stylesheet"href="//cdn.bootcss.com/lightbox2/2.8.2/css/lightbox.css"&gt;修改代码块的paddingfont在_sass/_layout.scssprecode.hljs{font-size:modular-scale(0);padding:1.5em;}##2016/01/12修改底部四个按钮大小在footer.html.fa-lg{font-size:1.5em;}设置顶部Title(咕咚)的高度.logo{float:left;height:4em;border:0pxsolid#000;padding-top:0.6em;@includemedia($tablet){padding-left:$em-base;}设置底部的按分类查看为隐藏&lt;pstyle="display:none;"&gt;&lt;ahref="posts"&gt;ViewAllPostsbyCategory&lt;/a&gt;&lt;/p&gt;</li>
  <li>抓住机会做自己喜欢做的事崔娃每月去刻意练习一种思维整理视频到个人移动硬盘备份密码到坚果云mouthreview时给轩轩写信mouthreview其实就可以是轩轩的信打造自己的被动收入付费APP+写文章(这个是一个长远计划)不断提升自己的价值，给别人带来的价值越大，自己的价值也就越大，渡人渡己。看书，一定要做笔记，思考，这非常重要。Daily可以继续优化风格，但是不要占用太多时间，用一个体系化的东西，在体系上可以多花时间。四月回归正常俯卧撑、学习英语每天听书学习PicPlus全选、费用可配ß三月月初的计划基本没执行，很差。也没有来这里进行check工作忙于做需求，需求没有尽头，组长一直说工作时要有Owner精神，我认为他自己做的很好，凡事应该如此，自己做主人，而不是把自己当客人，这样才会给人越来越多的信赖感。面试这次试试的心态，参加了面试，准备了两周，还是挂了，有点失望，但是面试过程中发现的问题也确实存在。你以为的自己跟真实的自己有区别，当某一天知道这种区别的时候，就会很受打击工作的业务还是没有透彻的去掌握对于技术，还是尝鲜心态，没有足够深入的学习使用需要从心态上转变关于技术的学习使用数据结构算法还要继续练习，接下来的时间多多练习家庭一言难尽，总觉得问题越来越多，自己的脾气也越来越差，不喜欢紧张的气氛，也不想吵架，但是总是不喜欢媳妇说话的那种语气。孩子开始练习写字，有点懒，总说自己累，这段时间给他拍照记录，记录了很多有意思的话。但是在时间上，我们花的时间并不够多。PicPlus用户很稳定，接下来加入多选上传跟坚果云，加入多选会提升价格，这里需要把价格做成动态可配的。这个月在上面花费了不少时间，但相比上月还是少了点。这段时间的节奏完全是不对的，复工后要调整，调回正常的状态，看书，写字，做APP，还要继续复习数据结构。股市比较不如意，仓位管理很差，还是小白的阶段，但是目前不想割肉，目前股市开始有点恐慌，我想着如果有反弹减掉一些。小学资质继续确认核心技术攻坚确认上班后把Daily恢复起来减仓3月20号两会结束前，应该减到50%还是要规律一点才好，最近在PicPlus上很疯狂PicPlus数据备份机制确认清楚自动发邮件支持阿里云与友拍云二月孩子上学资质确认办理居住证代码之外的生存指南读书读后感记录技术攻坚点确认咕咚Markdown完成付费功能逻辑坚果云同步逻辑实现做市场推广（阮一峰、微博等渠道）咕咚Write支持打开坚果云Markdown文件总结二月在家呆了一个月再次看之前的计划，执行的不好，几乎没有完成，原因有很多。不上班后习惯乱了家里不好执行计划居住证并不是那么重要，下周办好第一次付费应用尝试这个月都在家里，不少时间开发PicPlus，付费逻辑已经写完一段时间了，三月1号前一天发布了alpha版本，第二天就有用户开始付费，让我很激动。这是这个月最成功的事吧，也是让我最开兴的，因为第一次尝试，这种靠应用赚钱的感觉很不错，尽管金额并不大。有用户购买了，就多了很多朋友，周一正式发布了正式版。那一天有13个付款用户，很意外。工作在家办公，一开始不忙，后来事情越来越多，最近两周特别忙，一些工作的感觉渐渐的好了，但是核心重点还没有确认。孩子淘气、可爱，一个月没出门家庭跟老爹老妈孩子合影了一张，老爹他们老了，让他们多开心才是。一月已经是19年的最后一月了，明天就是2020年1月1号，崭新的一年又来了。期望每天听书15分钟，记录笔记工作居住证落实，其他证件办理情况落实借款合同恢复每天锻炼身体的习惯花时间建立体系，让体系解决问题。咕咚图床一月计划加入url转化功能改名为咕咚Markdown助手首页布局改为功能入口，历史记录后移加入GitHub图床支持（免费）联调通付费逻辑以及UI，可以让用户正常付费总结Daily坚持的不错，越来越随意，假期结束后要继续开始开发了自己的WriteAPP，后续的写作都会使用自己的App，它的定位安全、可靠简单够用优秀的分类管理草稿箱咕咚Markdown助手按照计划完成了90%，尤其是GitHub的支持，花了点时间，但是结果不错，首页的结构更改让我满意，数据也不错。付费功能没有按期完成，这是下月的重点。工作这个月不多，但是定时微博花了不少时间，前期不少东西没有落地，导致后期工作增加，这需要注意。孩子这个月交流能力大幅提升，可以很深入的交流聊天，这个月开始听书《人性的弱点》，非常好的一本书，感觉听晚了，里面又不少东西让我很受启发，尤其是与人交谈时，尊重对方这一点。要占到对方的角度，要用心去尊重对方的感受，三个是的原则，与人交流先让他说三个是。《代码之外的生存指南》已经看完了，但是读书笔记一直没写，2月要补上这个月过年，整体有点松，年末的肺炎很突然，七天都在家里，还担惊受怕，很不一样的春节。投资，这个月怎么说呢，2019最后一天的交易日有点轻举妄动了，明天开盘不会割肉。老爹老妈身体很重要，健康很重要~因为焦虑买了不少药，不要怕，但是确实是，一个病对家庭的影响太大了。</li>
  <li>2015/12/5为博文增加了一个开关，如下所示---layout:mypostauthor:咕咚title:"在Android5.0以上设备实现过度动画"description:""categories:Technologypublish:falsetags:AndroidAnimation---只要设置publish为false，那么这篇博文将不会出现在主页列表，不设置默认表示文章处于发布状态2015/10/27修改了默认的博客头部背景颜色设置。在写博客时，在博客一开始指定cover时，现在可以有四种可选项了，cover:"assets/1024_programer.png"cover:"#f8f8f8"cover:"zzz"不设置四种设置分别对应下面的四种表现在博文中设置cover属性为assert下面的图片，必须是assets下面此时文章头部背景将会是一张大图style="background-image:url(/////);"在博文中设置cover属性为以#开头的颜色值此时文章头部背景将会是纯色style="background-color:#xxxxxx;"在博文中设置cover属性为”zzz”此时文章头部背景将会是主题指色，这个颜色在config中指定theme_color:"#607D8B"在博文中不设置cover属性此时文章头部将不会显示任何大背景色，只有一个分割线2015/10/25当设置博客北京的conver属性后，如果没有设置图片，则会显示一个纯色的背景，这个纯色的背景的设置具体在/sass/layout.scss下面.scrim{padding:3em1em;&amp;.has-cover{background-color:$action-color;padding:6em1em!important;@includemedia($tablet){padding:9em1em!important;}}}$action-color在/sass/base/variables.scss下面//FontColors$base-background-color:#fff;$base-font-color:$dark-gray;$action-color:$blue;$highlight-color:tint($action-color,33%);真心佩服作者这种清晰明了的设置方案。经验证上面的方式有问题，background-color必须为半透明颜色，还是改回来，换个颜色就行！</li>
  <li>从16年开始，陆续有很多好友对咕咚翻译进行了数量不等的捐赠，这里再次谢过你们对咕咚翻译的支持。为表谢意，这里将列出所有捐赠者名单以及数额：捐赠者金额(元)备注时间阳5软件很实用，感谢！2017-10-18缄默10.00 2017-10-17葛2 2017-10-11冬*2.33灰常好用2017-10-13往**峰1感谢有你的，咕咚，希望越来越好。支持支持2017-09-28ma**et15谢谢大佬的翻译软件2017-10-07麦提***布拉1 2017-08-28n***110.00感谢作者 陈***都1.00学生党感觉很好用，赞一下 胡***娟1.00  k***i1.00  良***5.00实用的软件，请保持小而美，支持你！ 劲***2.00  lwy***21.00  大***团5.00应该不够你喝咖啡吧，作为学生党十分感谢你 徐***0.59  咩1.00支持作者大大 华***酱10.00软件很便捷，希望继续单词本能再有所改进！ 尘***0.50很棒的软件，高中生一枚，钱不多，还望见谅 田***5.55加油 3**7510.00  刘***伟1.00咕咚翻译很好用，谢谢！ 彼***10.00爱你！望世上能有越来越多这样的好app~ Cod***e6.60咕咚翻译实用。开发不易，开源不易，感谢！ 辛辣***燎原5.00好用至极，希望能长按选自动复制查词 逝水无痕1.10咕咚翻译 b***布0.50捐赠 志***20.00聊表心里，感谢作者。且希望有个单词本导出 Ts***g6.66咕咚真的很不错，谢谢！希望能一直用下去！ Da***n5.00加油，支持下国内开发者 拉***日5.00支持 大***良50.00请继续加油。咕咚翻译用户。 h***o0.10第一次捐赠 刘***民3.00用过类似的但你这款最好解决痛点小小心意 hu***rt2.33加油(???_??)? 极***3.00你们的软件很好用，谢谢啦！ irid***ent2.33软件非常好，一点心意，支持作者！ lin***ang20.00希望记住努力！ 奥特***爷5.00虽然不多，还是支持一下啦。咕咚真的很好用 Hu***潘2.00支持开发者 俊***5.00感谢个人开发者的付出。 叶***10.00穷学生请你喝可乐 鸡蛋***扬3.00加油 流***2.00小小的支持一下下 </li>
  <li>每月去刻意练习一种思维整理视频到个人移动硬盘备份密码到坚果云mouthreview时给轩轩写信29794–91566–q–q.comzhuan–xuna1511–g–mail.com十二月总结让体系解决问题发布器整个框架优化点罗列出来，汇总成文档=====每周五个算法、Android知识点学习更加深入，算法应该结合极客时间课程====搞定房子纠纷，拿到钥匙，下来的问题，房产证==我跟媳妇的保险落地==试着建立用脑图的习惯=确定工作居住证跟上学的关系下月回顾已经是19年的最后一月了，明天就是2020年1月1号，崭新的一年又来了。期望去头条，找到一个可以最大化自己价值的团队（效率开发），这需要算法+Android不断准备。打造自己的被动收入付费APP+写文章(这个是一个长远计划)不断提升自己的价值，给别人带来的价值越大，自己的价值也就越大，渡人渡己。看书，一定要做笔记，思考，这非常重要。Daily可以继续优化风格，但是不要占用太多使用，用一个体系化的东西，在体系上可以多花时间。check算法练习后来跟媳妇坚持了五周，还可以，但是感觉效果一般这月10号左右交了7万的欠款，拿到了钥匙，房子到手，房产证接下来每周每月催。保险未落地Android学习最近坚持并不好，云图APP打乱了一些节奏。工作居住证跟上学的关系确认总体完成一般。这个月两个事画的心思最多：Daily咕咚云图但是云图APP对自己带了更大的影响，很多时间被打乱。Daily进展目前进展还可以。我的主要目的是每天持续输出，持续不断练习自己的思考能力，写作能力，还有，每天的听书很重要，它是一种输入，跟Daily相辅相成，我甚至觉得这是自己坚持下来的一个重要因素。发现写Daily有一个很有意思的发现。一些事，脑袋汇总想是一回事，写出来就是另一回事。而且写出来的过程会帮助自己获得更深刻的思考。一开始可能只是想写这个话题，没想到深入，但是当下笔的时候，会发现一些可深挖的思考。这个思考很关键，尤其是对自己，是提升自己思考深度的方式。写了已经45天左右，也就是45篇文章，最难的就是有时会遇到不开心的事，因为内心的不愉快，有时会想要不要写，写了有什么用，自己所处的事情这么糟，还写文章给读者看，有什么意义。这种时候，我就会告诉自己，写作这个事是一个独立的事，你并没有为别人而写，你写给自己，练习自己的思维，提升自己的思考能力。这是一个好习惯，不要让它跟每天的情绪关联起来。你可以利用好情绪去写作，但是不要助长坏情绪。健步看书这是这两个月形成最好的习惯，没有之一。每天听一节代码之外的生存指南，感觉他就像泉水，每天听他就像在接受一种滋养，从他那里能得到无穷的力量。我觉得好习惯就是这样，他会让你主动去完成他，因为它能给您内心不一样的感受，更深刻的感受，这样的感受激励你不断去坚持，其实这时已经不是坚持，而是一种自然而然的习惯。《代码之外的生存指南》上周听完了这本书，这是自己听完的第一本书，然后从这本书开始，自己便喜欢上了听书，尤其时配合健步，一举两得，这真是一个非常好的习惯。我要写读书笔记已经总结。我真心感谢这本书的作者。房子天津跑了两次，房子已经是一个累赘，但是既来之，则安之，只能让利益最大化，目前最重要的就是房产证，然后落户。还有房子，我总觉得，事情变得很坏的时候，事情可能会出现转机，所以有时不必太过沮丧。孩子今天完了，就开始修寒假了，两个月的时间，还是要带他看书，晚上给他读故事听，重新买一本睡前故事给他听，现在的有点深奥。上周四去参加了开放日活动，很少爸爸参加，他在教室里表现跟家里完全不一样。他又可以完成所有事的潜能，所以在家里我们应该也去激发他。《人性的弱点》中说，多鼓励，多激发，少批评，批评不能让别人变好。思考能力进步明显，思考深度增加。语言也是，词汇量继续提升。带他去外面盖房子，去沙河，他很开兴，希望他健健康康的长大，做个有思想，有特点的人。篮球每周一次左右，没有三次的时间。对于自己还是要继续练习运球，还有手感，篮下技术是老本。这月还去检查了一次脚踝，没什么大碍，做了一次冲击波，300大洋，目前感觉并不是那么划算，后续还是应该打球注意，多练习运球，胯下。上次过玉华就是一次成功的运球过人。技术练习因为咕咚云图的原因被耽搁了，但是这块还是很重要，目前比较乱，我认为有几个关键点：要多挖一次，看源码整理出来这个月技术进展一般般。工作开发了几个大需求，整体工期不是很满，来了两个新同学，团队Android队伍在壮大。咕咚云图狂风暴雨般的开发，已经迭代带了109版本，整体功能体验的第一阶段完成，目前还是应该保持好的节奏，一步步来，做好URL解析后，然后在做付费功能，但是开发可以并行开发。后来数据统计很重要，微软的AppCenter非常好，有一个盆友在适当的时候给你指点，真是很棒。这个工具很简单，功能还很稳定，我觉得咕咚云图也应该如此。十一月总结求知求真，搜索一切，拥抱体系。一个好的体系可以让自己高效率的产出。这是最近明白的一个道理，偶尔的心血来潮可能会带来一个意想不到的收获，但是要持续性的输出一定需要一个自己的体系，只要你呼吸，这个体系就伴随着你，前提是去刻意练习，在自己身上建立出这样一个体系。面对任何不知道的东西、技术点，第一时间用搜索工具进行查询。学习回归正常节奏(每天刷题、练习Android知识点，深挖知识点)初步：每周一篇技术文章，一篇思考类文章，工作日输出碎片，周末合并产出（如果转账效果不错，后续效仿）每周中午最多打两次球，不多打，通过支付宝给公共账号转账进行监督。总结看了十月设定的目标，十一月整体都在节奏上，目前算法练习、Android练习都在正常进行，技术文章也不是问题，每周坚持学习五个知识点。打球频率成功得到了控制，我觉得主要原因有天气的因素，后续要坚持。目前两个方向：工作要认真干，还要不断学习研究发布器的知识点，要认清现状，实际上这块技术能做的并不多，单靠自己也很难，总之微博这样的成熟产品，机会太少，这是不争的事实，要在这样环境下发挥自己的能力，其实要求更高。技术学习继续保持，算法+Android知识都要同步进行，算法对自己更重要，放到每天第一个任务。Action做好当下事，深挖发布器知识点，总结学习微博其他业务优化方案，向Feed学习，看文档严格按照当前计划学习房子已经这样了，这是一场惨痛的教训，今天找了律师，律师从专业的角度回答了我的问题，这样心里也踏实，只是自己不想走到难堪的地步，所以还是想的去把剩余的路走完，事到如今只能这样，很多错误都是如此，中间想止损，却已经被堵死了，就像后会无期中的青蛙一样，悲剧，来日方长，房子也不是要死要活的事，凡事都可以过去，可能自己要走更多的路。孩子教育问题，一直是我心头最大的事。最近一段时间，他的沟通水平已经越来越好了。这月过了他的第四个生日，很开心。最近的积木堆得越来越好了，第一次吃披萨。保险今天给老爹老妈买了百万医疗，一年两个人2500，还比较划算，我心里也踏实，寿险买不了，我们媳妇准备买寿险，但是现在需要体检，我想了想，可以先买个百万医疗，然后到34岁再买寿险，目前没有可以用寿险的钱定投基金。父母老爹十七号来的北京，老家无聊，还是觉得这边好。我觉得以前是对的，很多事，说多了没意义，有时自己慢慢也就放下了，老爹算是想开了，只是媳妇，她依旧有成见，不过也是，时间可以改变很多想法。后续还是要思考以后的路，怎么可以更好。眼前的事：孩子上学，房子问题、工作问题。钱能借到钱的朋友不一般。我会永远记得借我钱的朋友，不过自己还是要努力赚钱，开源节流才是。Daily可能是受到看书的启发，这月14号开始，自己开始日更日记到公众号，今天已经坚持了15天，目前感觉走在正确的节奏上。后面我还是想一周执行6次，一天请假。我希望这个习惯可以保持的久一点，还是我一开始写的那几点，要写的有价值，有意思，好玩，取悦于自己的前提下，取悦别人，不断优化改进自己。十月总结反共识大人都认为对的事、认为对的路，尽管都是对的，但自己加进去，还是一个分母，跟大家一起分享收益，收益并不大，与其如此，不如另辟蹊径，找没人发现的路，有风险，但是收益就特别大，这里主要是这个收益比很大。这跟之前校长说的，用小资本博大机会，找赔率高的事做不谋而合。工作整体比较忙，一直还是在忙需求，这周领导让找一个优化点，对发布器模块做一个大的技术需求，目前还没有想好点，但是这个事一定比做需求有意义，把这个事当做重点对待。生活回老家十一回家了，带着孩子还有妈妈，终于回到了老家，非常愉快，还在公众号里发布了一篇文章为什么要回家，因为家在哪里，回家影响最深的是去后山。自己好久没去了，这次骑摩托终于完成了一个心愿，在山里行走时那才是自由的感觉。回家还跟自己的哥哥们都见了面，跟他们喝酒聊天，每人都有自己的家，每个家就有每个家的故事，什么是成功的人生？往简单了想，成功没那么难，把自己的家经营好，大家平平淡淡的生活，就是成功，但是即使如此，做到也不容易。感恩每个平凡的一天，跟自己和解，认真做好手里的事。去芽庄跟团队去越南一个海滨城市团建，非常愉快的一次出行。这是自己第一次出国，每个人对自己的第一次总是影响深刻，这次的芽庄行对我也是如此，来到一个从来没有踏足的国度，这里有自己的历史、文化、语言，来之前自己还是挺好奇越南是什么样子的。从下飞机后，那边就下雨了，沿海城市下雨很快、停雨也很快，打车到了住的地方，是一个靠海的商务酒店，他有一个非常好的阳台，可以清楚的看到大海，视野非常不错。后来陆续去了当地的教堂、海滩还有一个大型的娱乐城，珍珠岛，有很多好玩好看的景，在珍珠岛尤其对哪里的动物园影响深刻，很干净，没有异味，好多非洲的动物，第一次看到了河马还有犀牛。总之，芽庄之行算是一次发现之旅，随手上万的花销、食物味道很赞，但是价格跟国内差不多、摩托车是主要的交通工具、芒果很好吃、基础建设差，中国太厉害了、海岛真好看，世界很打，好玩的很多。努力赚钱，多读书，提高自己，让自己更好。孩子轩轩越来越懂事，也越来越会聊天了，我平时说的话，他会记住，指不定哪天自己就用上了，他很可爱，但是一些时候，确实又非常调皮，不听话，很无奈。早晨不愿意去上学，但是送到学校门口，又不排斥，在学校，他的管束还是比较多吧。现在可以自己刷牙、自己洗脸，我让他每天刷完牙、洗完脸后，在我的习惯APP中画勾勾，他还比较喜欢。现在幼儿园开始教认字了，他认字很快，很好奇为什么他可以认的那么快，每天有空了，我们都会教他认字，他也不排斥，脸、多、山、蓝、绿、上、出、泡。。。好多了他不喜欢打球，拍球也很差，这跟我当初预想的不一样，跟他一起的小朋友很多都可以，所以我觉得现在并非他太小了，而是拍球确实还没有那么多的天赋，不过我并觉得他不适合打篮球，后续继续观察，继续培养他的兴趣。妈妈肚子涨，吃药了，但是还是没好，父母老了，就需要我们多照顾，现在他们还要帮我照顾孩子，尽管她很乐意照顾我们，但是作为儿子，不能觉得这是理所应当，要感恩，多关心。老爹月中要来北京，一家人在一起挺好，每周都能看到老爹。九月总结*工作中把发布器的发布队列等技术要掌握，还有微博的一些通用技术，可以通过wiki去学习掌握。*Android基础知识、进阶知识再次认真学习一遍九月感觉花了很多的钱，也许每次花的并不多，但是频繁的花钱，累计起来，我感觉到花了很多。主要是车票、还是有事买东西，需要做预算。工作完成了发布器两个大需求，超九图、发布器进度展示，也因此在前两周加了两周的班，很辛苦，轩轩到晚上总是找我们找不到。一直都在做需求，还是应该利用做需求的期间，找机会提升自己。学习数据结构落下了，九月因为手术耽搁了不少事，包括每日俯卧撑，手术影响真不小，我打算十一回去后全部恢复正常。生活老爹要提前回去，在离开前带老爹老妈去了圆明园，第一次坐船很不错前一天还去了天坛，公园很大，完了后带去一起吃了肯德基，味道一般回家孩子这回他开始叫我了过去了我说你以后别叫外奶奶了，改叫外婆，他说太难听了，不叫。八月总结*每日练习面试题*住院做鼻子复位手术*轩轩练习篮球*住院时带老妈吃了一顿凡事多想一层，一层即可，不要轻易给自己一个答案，多问一个问什么，养成了解原理的习惯学习、复习已经是头等大事了，androidJava一起开始复习吧，重新过一遍，基础很重要。数据结构与算法学习购房资格调查（社保卡还要继续跟进）生活八月都是绿色的，是今年最热的一个月了。这个月开始练习数据结构算法，每日练习面试题，每天一个重点，然后去找资料练习，坚持的节奏不错，但是数据结构、算法还是不够理想，后来工作开始变忙了，所以每天坚持练习就越来越不容易了。直到16号打球，鼻子被打骨折受伤，然后检查，住院，手术，整个八月的后半段就是在跟医院打交道，灰暗的日子，好在家人、同事都比较支持。具体医院感悟：第一次住院后的一点碎碎念|咕咚人生是该去多经历一些事，会发现不一样的风景，但是最好还是去主动的创造一些。工作图片编辑功能开发完后，开始发布器两个大需求，都比较麻烦，发布器发布进度、发布器支持超九图，这两个需求在住院前都提交了测试，但是完成度还不高，所以出院后继续开发。九月的开始都把时间花在了发布器超九图，出院后就加班，整整两周，煎熬，但是也是成长的好时机。孩子轩轩最近一段时间变化很大，尤其是语言方面，他可以跟我们完成一些简单的聊天，主要是有了自己的意识，会自己思考。只是早晨不爱去幼儿园，暂时也不知道为什么，但是到学校他却不怎么排斥，每次送到学校他都自己高高兴兴的奔向教室。七月总结*数据结构学习*购房资格调查（已经快五年了）*孩子教育上还需要多看书*远见阅读工作主要在做微博图片项目，做了超九图、以及图片编辑，都是在原有基础上添加新功能，维护，技术输出并没有多少，其中有一些View事件分发的知识点。图片编辑页面的UI/UE改动花费了不少时间，主要是开发效率太低，改UI后要查看效果，运行一次5、6分钟，伤不起。业余用Kotlin开发了一个桌面清单插件，可以方便的查看今天要做的时，以及添加新任务，还学习了协程，这是kotlin1.3后才加入的新特性，使用协程可以很轻松的处理Android中异步回调，同时相比线程，他也更加轻量级，由用户控制操作，不像线程由操作系统控制。另外也学习了桌面插件的开发，其实还是挺麻烦的，因为是View的操作都是跨进程的，所以时间的点击处理，ListView的更新都比往常要麻烦，但是也是固定的套路，只要按照官方文档，就会避免采坑。在我找资料的过程中，因为找了中文资料，而这些资料比较旧，跟现在官方的有出入，导致一开始的点击事件处理老是失败，后来打开蓝灯能，看了官方文档，才知道问题的所在，看一手资料很重要。学习这个月配媳妇去了农学院学习，这是自己周围为数不多的向外界开放的学校，只是有点远，在朱兴庄，去了两个周末，陪媳妇学习，其实自己也是，数据结构、算法都需要重新认真学习一篇，八月到了，再不能耽搁了，认认真真复习啊。农学院树很多，篮球场也不错。篮球经历了前几个月的疯狂，最近对篮球热情下降。一方面是身体原因，跟腱部位感觉还是疼，需要保护，另外也是说不出的感觉，那次在农大玩了一会，突然觉得没意思，现在太热了，也需要把热情转移一下了。好好学习生活上周末准备去更改社保卡绑定手机号，无奈周末他们不上班，我去扑了个空，下次办事不论如何，一定要先打个电话啊，否则就是这种无用功，不过我顺道去了趟五路居，那个我到北京后开始工作的地方，哪里有我不少美好的回忆，重新走了一遍那边的路，真是感触颇多。道路干净多了，但是一样拥挤，还新修了了部分建筑，我还去以前住的地方看了看，哎~以前经常吃饭的地方被拆了，哪家的盖饭很好吃。转眼间六年过去了，TMD太快了，我站在慈寿寺那个桥上真是感慨万千，以前每次打完球过来的时候，总要照张相，现在在照相已经是六年后了。我还去了首师大，以前经常打球的地方，这么多年发现打球时一直都是一个人过来的。我觉得我可以写很多，但是就这样吧…购物/花钱这个月开销不小，外面吃了不少，也买了不少东西，拼多多真的很便宜，主要是他们活动力度大，在小米买了外接蓝牙键盘，现在的MAC电脑键盘问题太多了，买了伦纳德的短袖还有运动短裤。伦纳德的衣服我在总决赛期间就答应自己，他们要是赢了冠军就买一件他的衣服，算是对自己的奖励吧。还买了电脑桌，130我觉得挺贵的。六月总结上半年的最后一个月，忧多于喜。篮球这两年一直在练习投篮，18年已经有不少长进，这个月依旧有新的突破，于此同时，我发现改变是多么的难。练习纠正投篮有一个很好的方法就是看录像。之前从没有觉得，现在才发现这是一种很科学的方式，通过录像可以暂停、回放自己的动作，然后对比汤普森的投篮进行学习，很有成效。一切事情都有自己的方法论，找到它很重要，而且要坚持去寻找生活老爹来北京了，然后一周后就在媳妇的公司找到了保洁的工作，一开始觉得语言可能是问题，发现问题不大，另外就是距离，因为上班较早，所以只能住宿，老爹有点路盲，出了地铁总是迷路，慢慢会好起来吧。另外，问题总归还是问题，老问题一直没能解决，感觉就是一道坎…工作一直在加班，工作上确实也比较忙，但很多时候其实是效率比较低。这个月主要做了发布器自动存草稿，同时衍生除了不少bug，另外还理了发布队列的逻辑，当然这个月最重要的是全量了微博正文页重构的代码逻辑，后来待审核出了点小问题，其余都算正常，挺好，这是来微博最大的一个工作任务，完成的不错。其余都是发布器内一些小改，加参数、改按钮、适配等工作，意义不大，都是重复劳动…学习购买了极客时间的数据结构，跟媳妇一起学，最近学到了队列，效果不错，对自己来说是很好的课程，我要再努力一点，多花点时间，把他们重新学学，大学时真的太不当回事了，其实它们非常重要，还有就是刷题，至今没怎么刷。孩子淘气，很活泼，很喜欢跟别的小孩玩耍，但是语言方面，因为在老家带的缘故，方言影响很大，所以平常我还是继续努力的矫正他的发音。另外，他的记忆力不错，背了不少古诗，挺厉害。五月总结看球赛，精彩纷呈的季后赛，超级英雄莱昂纳德。重新发现了语雀，让它成为我的知识管理中心，目前良好罗盘·语雀稍后阅读专注于学习一个技术点，吃透读懂生活媳妇找了一个月工作，很辛苦，但是没结果，今年工作普遍不好找，还需要加强自身水平。轩轩越来越爱说话了，很活波，淘气。教育孩子并不容易。6.1带孩子去了公司，很喜欢玩。季后赛看到很过瘾，早晨很多时间都花在看直播了，周末跟老妈、媳妇看到了四加时，精彩。印象最深的还是莱昂纳德，今年他要拿总冠军了，我一定要买一个他的衣服，很喜欢他，今年路转粉。这个绝杀是自己在大巴上看的，感觉这球要绝杀，投出去的时候很像，但是一直在颠，后来看到球从网子里出来了，太厉害了。自己烤的土豆片超好吃。开发有一段时间空闲时间不少，我开始继续折腾leanclode云，很好玩，我用玩android和Gank的搜索API做了Gogo搜索，Gogo，在搜索技术文章时非常有用。学习技术点。最重要的，我做了稍后阅读，早就有了这个想法，那几天收到Darkeet鼓舞，下午花了点时间便把APP雏形完成了。这个雏形框架用到了之前外包项目的代码。重新走查了一遍柳叶清单开放API，然后发布了，还在玩android推了一下。maoruibin/liuye:柳叶清单开放API文档自己算是满足了自己的小愿望，成功开发了API，尽管目前貌似还没什么人用。工作开发抽奖功能、补充完成投票功能，不容易呢。发布器自动存草稿四月总结计划不如变化，有孩子了健康才是第一位。彷徨、挣扎生活轩轩已经基本适应了幼儿园。我把他送到幼儿园门口后，他可以自己一个人去教室了，这真是巨大的进步，也不哭闹了。但是让人难过的是他的感冒。这个月连续的感冒让我们一家人头顶上一团乌云，当他感冒发烧了，就需要吃药、输液，很折腾。总之，以后对于冰凉的东西杜绝给他吃了，两次病情跟冰激凌都可能有关系。他也免疫力有点差吧，听说小孩上幼儿园大都有这么一个过程，希望慢慢好起来。他的语言能力更强了，现在已经可以一起聊天，聊得还挺不错，他很喜欢火箭、宇宙飞船，喜欢去月球。感觉关于他，我可以写很多。这个月还有一件大事就是计划去旅游，从月初打算去上海、苏州三日游，高铁票酒店都已经订好了，但是最终在28号把票退了，因为轩轩的感冒，有点小失望，不过相比健康，不去旅游也值得了。坚持每天写文章，坚持了六周，每天写200字左右的短文。这个月中断了俯卧撑，牵一发而动全身，自己其他的习惯也噶然而自，习惯这个东西很奇妙啊，五月重拾起来。写文章不在简书了，感觉简书越来越low,我能理解他为什么会变low,但不可接受这种策略，所以后来权衡了下，决定在掘金发表。工作自己换了项目组，开始独立负责发布器了，之前还在想终于可以把发布器交出去了，最终在连泽的建议下，考虑再三我还是决定了换组去独立做发布器。新的组对自己也不陌生，只是换了领导，不同的领导不同的风格，踏实做事，做好自己分内事。另外独立负责后，还要加强对项目稳定的意识。投资虚拟币重仓了HT，但感觉还是在投机，不过对于虚拟币来说，大部分人都在投机，反正怎么能赚钱怎么来。放假钱两个两万多的基金，还有5000多的股票，打算节后再补补，好好投资一下A股。总结/展望工作缺乏动力，干劲不足，表现的很挣扎。工作时让自己更有效率一点。尽管这很难，这也是自己不想长期呆着的原因。搬家、幼儿园等事宜需要进行实地考察，沙河的代价还是太高了，5月应该去考察一次。三月总结生活送孩子去上幼儿园了，是一家私立学校。跟其他孩子一样，他也是闹了两周才开始慢慢适应了上学，自己每天骑电动车去送他，一段时间后，他已经有明显的变化，话变多了，也更懂事了。学费2650，伙食费400多，一个月3100，书本费一学期860。第二周上学生病了，感冒咳嗽，一度很厉害，最后在附近诊所治好了。孩子生病大人也不好过，平安是福，生活保暖、卫生等都是要注意的。一次治疗花了900多，好在都好了，没去医院。带孩子去了昌平一个山，去登山，他很任性，非要买玩具，最后没买，这也是平时没有给惯的，该严厉就得严厉。媳妇写简历，准备面试了，信心满满。妈妈这段时间终于可以休息了，白天送完孩子就是自己的时间，可以锻炼身体，健身。老爹去了内蒙栽树，还感冒了，那边有点冷，健康很重要，今年该买的保险还是要买啊。Weekly坚持到了第六周，现在在简书更新，继续坚持吧，主要目的还是每日思考、输出成习惯。投资基金定投给自己的收益不错，坚持定投，沪深300跟中证500的指数基金分别投资，每周三投2000。开始学习股票投资。目前的交易单位还是在千元量级的，所以盈利也就是以百为单位，看好时机，如果还有底部，继续买入。币市，跟着微博一个小V投了HT，三个多月时间赚了一倍，只是开始时投的不多，也是按照千投的，昨天全部清仓了，后续观察其他机会吧。不能停止学习。工作大部分时间在忙投票发布器，拖了两个版本，发布器是特别复杂的模块，各个组件设计的很杂，有很多设计的并不合理的地方。尤其是发布器元素共存，目前都是手动维护，特别麻烦。好在，连泽快要接手了，自己马上就不会负责了，经过半年的开发，对发布器的整体思路已经有了大的了解。昨天花了发布器的架构图，对自己理解发布器也是好事。详情页重构一二期均完成，这是到微博后，自己负责最大的重构，主要就是“分而治之”，接下来要好好测一下请求量以及打码日志有没有问题，确保不影响以前。日志回传解码失败的问题，终于解决了。不过是在别人的帮助下，我还是想继续去完善它，做成在线解密。微博首页tab改版的代码开关全量，删掉了所有大加号相关的代码。二月总结生活安静过年糟糕的胃带父母看3D电影考察幼儿园帮孩子选幼儿园以及报名带父母孩子去公司参观，去颐和园送老爹回老家工作发布器增加扩展参数修复微博发布器因Android版本导致的问题完成微博详情页结构拆分胃是自己的，需要对它呵护，先要管好自己嘴，别每次胃不舒服了才想起来胃是很脆弱的。有机会就多陪陪父母，跟他们聊天，带他们吃没吃过的东西，体验没体验过的东西需求、优化有时并不难，难得是下决心去做。2月3号除夕，4号到10号是春节假期，2月基本是从假期开始。今年在北京过年，父母孩子都在北京，这边也没有亲戚，所以今年是这几年过的最清净的一个年。但是从月初开始，自己的胃便开始出问题。不能多吃东西，或者吃甜食，否则胃就难受，每当难受时，我就出去走路，走很远。后来想，应该从根本上去解决问题，控制自己的饮食，少吃东西，另外应该改变自己吃东西的速度。自己一直吃饭较快，这样对胃也会造成额外的压力。于此同时，我也提醒我妈，给我少吃并督促我。最终从多方面着手后，到现在，胃明显好转。我希望让父母体验没体验过的事。所以过年时带父母去看了3D电影-《流浪地球》，看到他们欣喜的样子，我很开心。</li>
  <li>TextViewmaxEms这个属性用于设置view显示的长度，如设置TextView的maxEms为10，那它表示TextView显示的最大长度为10个M的长度。而maxLength则用于设置最多的字符数目，中英文都算一个字符。System.arraycopy参数解释publicstaticnativevoidarraycopy(Objectsrc,intsrcPos,Objectdest,intdestPos,intlength);复制指定源数组src到目标数组dest。复制从src的srcPos索引开始，复制的个数是length，复制到dest的索引从destPos开始。##JVMJVM是一个虚拟的计算机，跟实际的计算机一样，它具有指令集并使用不同的存储区域，JVM负责执行指令，还要管理数据、内存和寄存器。Java是一种编译性语言，同时也是一种解释性语言，它在编译阶段，把Java源码通过编译工具编译为与平台无关的字节码文件（.class），然后在JVM中解释运行，JVM是一套规范，它有一套抽象接口，不同的平台都有自己的一个实现，这样就确保了Java的跨平台性，JVM解释运行字节码文件。李刚《疯狂Java讲义》指令重排指令重排是指JVM在编译java代码，或者CPU在执行字节码时，对现有的指令顺序重新排序。指令重排的目的是在不改变程序运行结果的前提下，提高指令运行的效率，不过要注意，这里是说的不改变程序运行结果，是指在单线程环境下。这里可想而知，尽管指令重排进行了优化，但是在多线程环境下，就有可能出现问题。在公众号里搜到一篇不错的谅解指令volatile一个java关键字，作用有两个1.保证内存可见性2.防止指令重排线程安全多个线程访问时不会出现问题的代码就可以称为线程安全的代码，比如类初始化就是线程安全的，而一般的方法，如果多个线程调用，就很很容易出现多线程不同步的问题。协程协程是1964年就有的概念，不少语言已经支持，比如kotlin,在安卓中使用它，可以使网络交互代码变得更简单，因此现在变得很流行。协程解决了安卓中两个主要问题耗时任务运行时间过长阻塞主线程主线程安全，允许主线程调用任何同步代码协程提供了一种永远不会阻塞主线程的代码方式。协程提供了两个操作来构造常规的功能，挂起和恢复，挂起Suspend挂起当前协程的执行，保存所有局部变量恢复Resume从挂起协程的地方继续执行协程就是通过挂起和恢复来替换之前的回调形式。我认为挂起就是一个语法糖，协程框架帮你把标识为挂起的函数放入了子线程，然后挂起函数调用完毕，通过记住的栈启动协程使用launch或者async即可启动一个协程，启动后的协程可控制，可以手动取消。启动后，遇到耗时任务它会开启一个新的线程进行操作，具体通过Dispatcher控制，多个协程会公用一个线程，具体都在Dispatcher完成。在切换时，协程会把当前方法的上下文进行入栈保存操作，当挂起操作完成后，会唤醒协程，从上下文恢复挂起前的操作，继续下一步。切换线程withContext协程使用withContext进行线程切换，如下：withContext(Dispatchers.IO){Logger.d("2"+Thread.currentThread().name+""+Thread.currentThread().id+"isDeman"+Thread.currentThread().isDaemon)vallist:List&lt;Todo&gt;?=DataCenter.getInstance(this@MainActivity).getUnCompleteList()Logger.d("3"+Thread.currentThread().name+""+Thread.currentThread().id+"isDeman"+Thread.currentThread().isDaemon)}2DefaultDispatcher-worker-156442isDemantrue3DefaultDispatcher-worker-156442isDemantrue可以看到其实withContext会把耗时任务放到子线程中，它就是一个语法糖，然后执行完回到主线程。而且多个耗时任务会公用一个线程，这也是demo验证后的结论。协程可以用withContext方法方便的切换线程，如果使用rxJava只是用于线程切换，可以考虑使用协程替换，还需要继续学习。链表去农学院学习，很困，先休息了半小时，接着学习数据结构，一节链表。链表的很多操作都要遍历，遍历时设置临时变量会让操作变得简单，接着在循环中不断更改变量值。另外，一定要搞清楚next的意义，否则有时容易出错。链表的删除插入操作高效，但是单向链表在执行真真的操作前需要遍历，所以实际的时间复杂度还是O(n)，双向链表可以很好的解决这个问题，这也是空间换时间的典型应用。</li>
</ul>